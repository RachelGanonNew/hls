{"ast":null,"code":"/*\n@license\nThe following license applies to all parts of this software except as\ndocumented below.\n\n    Copyright (c) 2019, Twilio, inc.\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are\n    met:\n\n      1. Redistributions of source code must retain the above copyright\n         notice, this list of conditions and the following disclaimer.\n\n      2. Redistributions in binary form must reproduce the above copyright\n         notice, this list of conditions and the following disclaimer in\n         the documentation and/or other materials provided with the\n         distribution.\n\n      3. Neither the name of Twilio nor the names of its contributors may\n         be used to endorse or promote products derived from this software\n         without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThis software includes javascript-state-machine under the following license.\n\n    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\nThis software includes loglevel under the following license.\n\n    Copyright (c) 2013 Tim Perry\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\nThis software includes q under the following license.\n\n    Copyright 2009–2014 Kristopher Michael Kowal. All rights reserved.\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to\n    deal in the Software without restriction, including without limitation the\n    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n    sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    IN THE SOFTWARE.\n\nThis software includes platform.js under the following license.\n\n    Copyright 2014 Benjamin Tan <https://d10.github.io/>\n    Copyright 2011-2015 John-David Dalton <http://allyoucanleet.com/>\n\n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n    \"Software\"), to deal in the Software without restriction, including\n    without limitation the rights to use, copy, modify, merge, publish,\n    distribute, sublicense, and/or sell copies of the Software, and to\n    permit persons to whom the Software is furnished to do so, subject to\n    the following conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');\n\nvar _createClass = require('@babel/runtime/helpers/createClass');\n\nvar _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');\n\nvar _inherits = require('@babel/runtime/helpers/inherits');\n\nvar _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');\n\nvar _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');\n\nvar _defineProperty = require('@babel/runtime/helpers/defineProperty');\n\nvar _classCallCheck = require('@babel/runtime/helpers/classCallCheck');\n\nvar _regeneratorRuntime = require('@babel/runtime/regenerator');\n\nvar _typeof = require('@babel/runtime/helpers/typeof');\n\nvar loglevelLog = require('loglevel');\n\nvar iso8601Duration = require('iso8601-duration');\n\nvar JsonDiff = require('rfc6902');\n\nvar _slicedToArray = require('@babel/runtime/helpers/slicedToArray');\n\nvar operationRetrier = require('operation-retrier');\n\nvar twilsock = require('twilsock');\n\nvar twilioNotifications = require('twilio-notifications');\n\nvar twilioSync = require('twilio-sync');\n\nvar twilioMcsClient = require('twilio-mcs-client');\n\nvar _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');\n\nvar twilioSdkTypeValidator = require('twilio-sdk-type-validator');\n\nvar uuid = require('uuid');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);\n\nvar _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);\n\nvar _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);\n\nvar _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);\n\nvar _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);\n\nvar _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);\n\nvar _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);\n\nvar _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);\n\nvar _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);\n\nvar _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);\n\nvar loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);\n\nvar JsonDiff__namespace = /*#__PURE__*/_interopNamespace(JsonDiff);\n\nvar _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);\n\nvar _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof__default['default'](Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __metadata(metadataKey, metadataValue) {\n  if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof__default['default'](Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nvar domain; // This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\n\nfunction EventHandlers() {}\n\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n} // nodejs oddity\n// require('events') === require('events').EventEmitter\n\n\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.usingDomains = false;\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\n\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function () {\n  this.domain = null;\n\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active) ;\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}; // Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\n\n\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n}; // These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\n\n\nfunction emitNone(handler, isFn, self) {\n  if (isFn) handler.call(self);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) listeners[i].call(self);\n  }\n}\n\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn) handler.call(self, arg1);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);\n  }\n}\n\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn) handler.call(self, arg1, arg2);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);\n  }\n}\n\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn) handler.call(self, arg1, arg2, arg3);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn) handler.apply(self, args);else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n\n    for (var i = 0; i < len; ++i) listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var doError = type === 'error';\n  events = this._events;\n  if (events) doError = doError && events.error == null;else if (!doError) return false;\n  domain = this.domain; // If there is no 'error' event listener then throw.\n\n  if (doError) {\n    er = arguments[1];\n\n    if (domain) {\n      if (!er) er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n\n    return false;\n  }\n\n  handler = events[type];\n  if (!handler) return false;\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n\n    default:\n      args = new Array(len - 1);\n\n      for (i = 1; i < len; i++) args[i - 1] = arguments[i];\n\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = target._events;\n\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n\n      events = target._events;\n    }\n\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    } // Check for listener leak\n\n\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\n\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n\n  function g() {\n    target.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n}; // emits a 'removeListener' event iff the listener was removed\n\n\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n  events = this._events;\n  if (!events) return this;\n  list = events[type];\n  if (!list) return this;\n\n  if (list === listener || list.listener && list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = new EventHandlers();else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length; i-- > 0;) {\n      if (list[i] === listener || list[i].listener && list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n\n    if (list.length === 1) {\n      list[0] = undefined;\n\n      if (--this._eventsCount === 0) {\n        this._events = new EventHandlers();\n        return this;\n      } else {\n        delete events[type];\n      }\n    } else {\n      spliceOne(list, position);\n    }\n\n    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);\n  }\n\n  return this;\n}; // Alias for removeListener added in NodeJS 10.0\n// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\n\n\nEventEmitter.prototype.off = function (type, listener) {\n  return this.removeListener(type, listener);\n};\n\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events;\n  events = this._events;\n  if (!events) return this; // not listening for removeListener, no need to emit\n\n  if (!events.removeListener) {\n    if (arguments.length === 0) {\n      this._events = new EventHandlers();\n      this._eventsCount = 0;\n    } else if (events[type]) {\n      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];\n    }\n\n    return this;\n  } // emit removeListener for all listeners on all events\n\n\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n\n    for (var i = 0, key; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n\n    this.removeAllListeners('removeListener');\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n    return this;\n  }\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    do {\n      this.removeListener(type, listeners[listeners.length - 1]);\n    } while (listeners[0]);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n  if (!events) ret = [];else {\n    evlistener = events[type];\n    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);\n  }\n  return ret;\n};\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n}; // About 1.5x faster than the two-arg version of Array#splice().\n\n\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];\n\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n\n  while (i--) copy[i] = arr[i];\n\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n\n  return ret;\n}\n\nfunction prepareLine(prefix, args) {\n  return [\"\".concat(new Date().toISOString(), \" Chat \").concat(prefix, \":\")].concat(Array.from(args));\n}\n\nvar log$b = loglevelLog__namespace.getLogger('twilio-chat'); // twilio-chat is used by Flex SDK. Please DO NOT change\n\nvar Logger = /*#__PURE__*/function () {\n  function Logger(prefix) {\n    _classCallCheck__default['default'](this, Logger);\n\n    _defineProperty__default['default'](this, \"prefix\", '');\n\n    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0 ? prefix + ' ' : '';\n  }\n\n  _createClass__default['default'](Logger, [{\n    key: \"setLevel\",\n    value: function setLevel(level) {\n      log$b.setLevel(level);\n    }\n  }, {\n    key: \"trace\",\n    value: function trace() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      log$b.trace.apply(null, prepareLine(this.prefix + 'T', args));\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      log$b.debug.apply(null, prepareLine(this.prefix + 'D', args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      log$b.info.apply(null, prepareLine(this.prefix + 'I', args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      log$b.warn.apply(null, prepareLine(this.prefix + 'W', args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      log$b.error.apply(null, prepareLine(this.prefix + 'E', args));\n    }\n  }], [{\n    key: \"scope\",\n    value: function scope(prefix) {\n      return new Logger(prefix);\n    }\n  }, {\n    key: \"setLevel\",\n    value: function setLevel(level) {\n      log$b.setLevel(level);\n    }\n  }, {\n    key: \"trace\",\n    value: function trace() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      log$b.trace.apply(null, prepareLine('T', args));\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      log$b.debug.apply(null, prepareLine('D', args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      log$b.info.apply(null, prepareLine('I', args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n\n      log$b.warn.apply(null, prepareLine('W', args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n\n      log$b.error.apply(null, prepareLine('E', args));\n    }\n  }]);\n\n  return Logger;\n}();\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$4(Object(source), true).forEach(function (key) {\n        _defineProperty__default['default'](target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$4(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar TYPING_TIMEOUT = 5;\nvar HTTP_CACHE_LIFETIME = 'PT5S';\nvar CONSUMPTION_HORIZON_SENDING_INTERVAL = 'PT5S';\nvar USER_INFOS_TO_SUBSCRIBE = 100;\nvar MINIMUM_RETRY_DELAY = 1000;\nvar MAXIMUM_RETRY_DELAY = 4000;\nvar MAXIMUM_ATTEMPTS_COUNT = 3;\nvar RETRY_WHEN_THROTTLED = true;\n\nvar Configuration = function Configuration() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var configurationResponse = arguments.length > 1 ? arguments[1] : undefined;\n  var logger = arguments.length > 2 ? arguments[2] : undefined;\n\n  _classCallCheck__default['default'](this, Configuration);\n\n  _defineProperty__default['default'](this, \"typingIndicatorTimeoutDefault\", TYPING_TIMEOUT * 1000);\n\n  var constructorOptions = options.Chat || options.IPMessaging || options || {};\n  this.productId = constructorOptions.productId;\n  this.links = {\n    myConversations: configurationResponse.links.my_conversations,\n    conversations: configurationResponse.links.conversations,\n    users: configurationResponse.links.users,\n    currentUser: configurationResponse.links.current_user,\n    typing: configurationResponse.links.typing,\n    mediaService: configurationResponse.links.media_service,\n    messagesReceipts: configurationResponse.links.messages_receipts\n  };\n  this.typingIndicatorTimeoutOverride = constructorOptions.typingIndicatorTimeoutOverride;\n  this.backoffConfiguration = _objectSpread$4({\n    min: MINIMUM_RETRY_DELAY,\n    max: MAXIMUM_RETRY_DELAY,\n    maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT\n  }, constructorOptions.backoffConfigOverride);\n  this.retryWhenThrottled = constructorOptions.retryWhenThrottledOverride !== undefined ? constructorOptions.retryWhenThrottledOverride : RETRY_WHEN_THROTTLED;\n  this.userInfosToSubscribe = constructorOptions.userInfosToSubscribeOverride || configurationResponse.options.user_infos_to_subscribe || USER_INFOS_TO_SUBSCRIBE;\n  this.reachabilityEnabled = configurationResponse.options.reachability_enabled;\n  this.userIdentity = configurationResponse.identity;\n  this.userInfo = configurationResponse.sync_objects.my_user_info;\n  this.myConversations = configurationResponse.sync_objects.my_conversations;\n  var httpCacheInterval = constructorOptions.httpCacheIntervalOverride || configurationResponse.options.http_cache_interval || HTTP_CACHE_LIFETIME;\n\n  try {\n    this.httpCacheInterval = iso8601Duration.toSeconds(iso8601Duration.parse(httpCacheInterval));\n  } catch (_unused) {\n    logger.error(\"Failed to parse http cache interval \".concat(httpCacheInterval, \", using default value \").concat(HTTP_CACHE_LIFETIME));\n    this.httpCacheInterval = iso8601Duration.toSeconds(iso8601Duration.parse(HTTP_CACHE_LIFETIME));\n  }\n\n  var consumptionReportInterval = constructorOptions.consumptionReportIntervalOverride || configurationResponse.options.consumption_report_interval || CONSUMPTION_HORIZON_SENDING_INTERVAL;\n\n  try {\n    this.consumptionReportInterval = iso8601Duration.toSeconds(iso8601Duration.parse(consumptionReportInterval));\n  } catch (_unused2) {\n    logger.error(\"Failed to parse consumption report interval \".concat(consumptionReportInterval, \", using default value \").concat(CONSUMPTION_HORIZON_SENDING_INTERVAL));\n    this.consumptionReportInterval = iso8601Duration.toSeconds(iso8601Duration.parse(CONSUMPTION_HORIZON_SENDING_INTERVAL));\n  }\n};\n/**\n * Checks if objects are equal\n */\n\n\nfunction isDeepEqual(o1, o2) {\n  return JsonDiff__namespace.createPatch(o1, o2).length === 0;\n}\n/**\n * Deep-clone an object. Note that this does not work on object containing\n * functions.\n * @param {object} obj - the object to deep-clone\n * @returns {object}\n */\n\n\nfunction deepClone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nfunction parseToNumber(value) {\n  if (typeof value !== 'undefined' && !isNaN(Number(value))) {\n    return Number(value);\n  }\n\n  return null;\n} // timeString cannot be typed `string` because in member.ts\n// call to parseTime(data.lastConsumptionTimestamp) uses number not a string for timestamp.\n\n\nfunction parseTime$1(timeString) {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction parseAttributes(rawAttributes, warningMessage, log) {\n  var attributes = {};\n\n  if (rawAttributes) {\n    try {\n      attributes = JSON.parse(rawAttributes);\n    } catch (e) {\n      log.warn(warningMessage, e);\n    }\n  }\n\n  return attributes;\n}\n/**\n * Construct URI with query parameters\n */\n\n\nvar UriBuilder = /*#__PURE__*/function () {\n  function UriBuilder(base) {\n    _classCallCheck__default['default'](this, UriBuilder);\n\n    this.base = base.replace(/\\/$/, '');\n    this.args = [];\n    this.paths = [];\n  }\n\n  _createClass__default['default'](UriBuilder, [{\n    key: \"arg\",\n    value: function arg(name, value) {\n      if (typeof value !== 'undefined') {\n        this.args.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"path\",\n    value: function path(name) {\n      this.paths.push(encodeURIComponent(name));\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var result = this.base;\n\n      if (this.paths.length) {\n        result += '/' + this.paths.join('/');\n      }\n\n      if (this.args.length) {\n        result += '?' + this.args.join('&');\n      }\n\n      return result;\n    }\n  }]);\n\n  return UriBuilder;\n}();\n\nvar RestPaginator = /*#__PURE__*/function () {\n  /*\n  * @constructor\n  * @param {Array} items Array of element for current page\n  * @param {Object} params\n  * @private\n  */\n  function RestPaginator(items, source, prevToken, nextToken) {\n    _classCallCheck__default['default'](this, RestPaginator);\n\n    this.state = {\n      prevToken: prevToken,\n      nextToken: nextToken,\n      source: source,\n      items: items\n    };\n  }\n\n  _createClass__default['default'](RestPaginator, [{\n    key: \"hasNextPage\",\n    get: function get() {\n      return !!this.state.nextToken;\n    }\n  }, {\n    key: \"hasPrevPage\",\n    get: function get() {\n      return !!this.state.prevToken;\n    }\n  }, {\n    key: \"items\",\n    get: function get() {\n      return this.state.items;\n    }\n  }, {\n    key: \"nextPage\",\n    value: function nextPage() {\n      return this.hasNextPage ? this.state.source(this.state.nextToken) : Promise.reject(new Error('No next page'));\n    }\n  }, {\n    key: \"prevPage\",\n    value: function prevPage() {\n      return this.hasPrevPage ? this.state.source(this.state.prevToken) : Promise.reject(new Error('No previous page'));\n    }\n  }]);\n\n  return RestPaginator;\n}();\n\nvar log$a = Logger.scope('ChannelDescriptor');\n/**\n * Contains channel information.\n * Unlike {@link Channel}, this information won't be updated in realtime.\n * To have a fresh data, user should query channel descriptors again.\n *\n * @property {any} attributes - The Channel's custom attributes\n * @property {String} createdBy - The identity of the User that created Channel\n * @property {Date} dateCreated - The Date Channel was created\n * @property {Date} dateUpdated - The Date Channel was last updated\n * @property {String} friendlyName - The Channel's name\n * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)\n * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in Channel\n * @property {Number} membersCount Number of members in a channel\n * @property {Number} messagesCount Number of messages in a channel\n * @property {String} sid - The Channel's unique system identifier\n * @property {Channel#Status} status - The Channel's status\n * @property {Channel#Type} type - The Channel's type\n * @property {String} uniqueName - The Channel's unique name\n */\n\nvar ChannelDescriptor = /*#__PURE__*/function () {\n  /**\n   * @param {Client} client Chat client instance\n   * @param {Object} descriptor Channel descriptor data object\n   * @private\n   */\n  function ChannelDescriptor(client, descriptor) {\n    _classCallCheck__default['default'](this, ChannelDescriptor);\n\n    this.client = client;\n    this.descriptor = descriptor;\n    this.sid = descriptor.sid || descriptor.conversation_sid;\n    this.channel = \"\".concat(this.sid, \".channel\");\n    this.uniqueName = descriptor.unique_name;\n    this.friendlyName = descriptor.friendly_name;\n    this.attributes = parseAttributes(descriptor.attributes, 'Failed to parse channel attributes', log$a);\n    this.createdBy = descriptor.created_by;\n    this.dateCreated = parseTime$1(descriptor.date_created);\n    this.dateUpdated = parseTime$1(descriptor.date_updated);\n    this.messagesCount = descriptor.messages_count;\n    this.membersCount = descriptor.participants_count;\n    this.type = descriptor.type;\n    this.isPrivate = descriptor.type === 'private';\n    this.lastConsumedMessageIndex = descriptor.last_consumed_message_index;\n    this.notificationLevel = descriptor.notification_level || undefined;\n    this.status = descriptor.status || 'unknown';\n  }\n  /**\n   * Get channel object from descriptor.\n   * @returns {Promise<Channel>}\n   */\n\n\n  _createClass__default['default'](ChannelDescriptor, [{\n    key: \"getChannel\",\n    value: function getChannel() {\n      return this.client.getChannelBySid(this.sid);\n    }\n  }]);\n\n  return ChannelDescriptor;\n}();\n/**\n * Public channels collection\n * It's a cassandra-backed pull-based collection\n */\n\n\nvar PublicChannels = /*#__PURE__*/function () {\n  function PublicChannels(client, services, url) {\n    _classCallCheck__default['default'](this, PublicChannels);\n\n    this.client = client;\n    this.services = services;\n    this.url = url;\n  }\n\n  _createClass__default['default'](PublicChannels, [{\n    key: \"getChannels\",\n    value: function () {\n      var _getChannels = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var _this = this;\n\n        var args,\n            url,\n            response,\n            _args = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                args = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                url = new UriBuilder(this.url).arg('PageToken', args.pageToken).build();\n                _context.next = 4;\n                return this.services.network.get(url);\n\n              case 4:\n                response = _context.sent;\n                return _context.abrupt(\"return\", new RestPaginator(response.body.conversations.map(function (x) {\n                  return new ChannelDescriptor(_this.client, x);\n                }), function (pageToken) {\n                  return _this.getChannels({\n                    pageToken: pageToken\n                  });\n                }, response.body.meta.previous_token, response.body.meta.next_token));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChannels() {\n        return _getChannels.apply(this, arguments);\n      }\n\n      return getChannels;\n    }()\n  }, {\n    key: \"getChannelBySid\",\n    value: function () {\n      var _getChannelBySid = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(sid) {\n        var url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                url = new UriBuilder(this.url).path(sid).build();\n                _context2.next = 3;\n                return this.services.network.get(url);\n\n              case 3:\n                response = _context2.sent;\n                return _context2.abrupt(\"return\", new ChannelDescriptor(this.client, response.body));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getChannelBySid(_x) {\n        return _getChannelBySid.apply(this, arguments);\n      }\n\n      return getChannelBySid;\n    }()\n  }, {\n    key: \"getChannelByUniqueName\",\n    value: function () {\n      var _getChannelByUniqueName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(uniqueName) {\n        var url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                url = new UriBuilder(this.url).path(uniqueName).build();\n                _context3.next = 3;\n                return this.services.network.get(url);\n\n              case 3:\n                response = _context3.sent;\n                return _context3.abrupt(\"return\", new ChannelDescriptor(this.client, response.body));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getChannelByUniqueName(_x2) {\n        return _getChannelByUniqueName.apply(this, arguments);\n      }\n\n      return getChannelByUniqueName;\n    }()\n  }]);\n\n  return PublicChannels;\n}();\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$2(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);\n}\n\nfunction _arrayLikeToArray$2(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar Network = /*#__PURE__*/function () {\n  function Network(configuration, services) {\n    _classCallCheck__default['default'](this, Network);\n\n    this.configuration = configuration;\n    this.services = services;\n    this.cache = new Map();\n    this.cacheLifetime = this.configuration.httpCacheInterval * 100;\n    this.cleanupCache();\n  }\n\n  _createClass__default['default'](Network, [{\n    key: \"isExpired\",\n    value: function isExpired(timestamp) {\n      return !this.cacheLifetime || Date.now() - timestamp > this.cacheLifetime;\n    }\n  }, {\n    key: \"cleanupCache\",\n    value: function cleanupCache() {\n      var _iterator = _createForOfIteratorHelper$2(this.cache),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray__default['default'](_step.value, 2),\n              k = _step$value[0],\n              v = _step$value[1];\n\n          if (this.isExpired(v.timestamp)) {\n            this.cache.delete(k);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (this.cache.size === 0) {\n        clearInterval(this.timer);\n      }\n    }\n  }, {\n    key: \"pokeTimer\",\n    value: function pokeTimer() {\n      var _this = this;\n\n      this.timer = this.timer || setInterval(function () {\n        return _this.cleanupCache();\n      }, this.cacheLifetime * 2);\n    }\n  }, {\n    key: \"executeWithRetry\",\n    value: function executeWithRetry(request) {\n      var _this2 = this;\n\n      var retryWhenThrottled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return new Promise(function (resolve, reject) {\n        var codesToRetryOn = [502, 503, 504];\n\n        if (retryWhenThrottled) {\n          codesToRetryOn.push(429);\n        }\n\n        var retrier = new operationRetrier.Retrier(_this2.configuration.backoffConfiguration);\n        retrier.on('attempt', function () {\n          request().then(function (result) {\n            return retrier.succeeded(result);\n          }).catch(function (err) {\n            if (codesToRetryOn.indexOf(err.status) > -1) {\n              retrier.failed(err);\n            } else if (err.message === 'Twilsock disconnected') {\n              // Ugly hack. We must make a proper exceptions for twilsock\n              retrier.failed(err);\n            } else {\n              // Fatal error\n              retrier.removeAllListeners();\n              retrier.cancel();\n              reject(err);\n            }\n          });\n        });\n        retrier.on('succeeded', function (result) {\n          resolve(result);\n        });\n        retrier.on('cancelled', function (err) {\n          return reject(err);\n        });\n        retrier.on('failed', function (err) {\n          return reject(err);\n        });\n        retrier.start();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(url) {\n        var _this3 = this;\n\n        var cacheEntry, headers, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                cacheEntry = this.cache.get(url);\n\n                if (!(cacheEntry && !this.isExpired(cacheEntry.timestamp))) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", cacheEntry.response);\n\n              case 3:\n                headers = {};\n                _context.next = 6;\n                return this.executeWithRetry(function () {\n                  return _this3.services.transport.get(url, headers, _this3.configuration.productId);\n                }, this.configuration.retryWhenThrottled);\n\n              case 6:\n                response = _context.sent;\n                this.cache.set(url, {\n                  response: response,\n                  timestamp: Date.now()\n                });\n                this.pokeTimer();\n                return _context.abrupt(\"return\", response);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }]);\n\n  return Network;\n}();\n\nvar NotificationTypes = function NotificationTypes() {\n  _classCallCheck__default['default'](this, NotificationTypes);\n};\n\n_defineProperty__default['default'](NotificationTypes, \"TYPING_INDICATOR\", 'twilio.ipmsg.typing_indicator');\n\n_defineProperty__default['default'](NotificationTypes, \"NEW_MESSAGE\", 'twilio.channel.new_message');\n\n_defineProperty__default['default'](NotificationTypes, \"ADDED_TO_CHANNEL\", 'twilio.channel.added_to_channel');\n\n_defineProperty__default['default'](NotificationTypes, \"INVITED_TO_CHANNEL\", 'twilio.channel.invited_to_channel');\n\n_defineProperty__default['default'](NotificationTypes, \"REMOVED_FROM_CHANNEL\", 'twilio.channel.removed_from_channel');\n\n_defineProperty__default['default'](NotificationTypes, \"CONSUMPTION_UPDATE\", 'twilio.channel.consumption_update');\n\nfunction _createSuper$8(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$8() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$9 = Logger.scope('Member');\n/**\n * @classdesc A Member represents a remote Client in a Channel.\n * @property {any} attributes - Object with custom attributes for Member\n * @property {Channel} channel - The Channel the remote Client is a Member of\n * @property {Date} dateCreated - The Date this Member was created\n * @property {Date} dateUpdated - The Date this Member was last updated\n * @property {String} identity - The identity of the remote Client\n * @property {Boolean} isTyping - Whether or not this Member is currently typing\n * @property {Number} lastConsumedMessageIndex - Latest consumed Message index by this Member.\n * Note that just retrieving messages on a client endpoint does not mean that messages are consumed/read,\n * please consider reading about [Consumption Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}\n * to find out how to mark messages as consumed.\n * @property {Date} lastConsumptionTimestamp - Date when Member has updated their consumption horizon\n * @property {String} sid - The server-assigned unique identifier for the Member\n * @property {Member#Type} type - The type of Member\n * @fires Member#typingEnded\n * @fires Member#typingStarted\n * @fires Member#updated\n */\n\nvar Member = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Member, _EventEmitter);\n\n  var _super = _createSuper$8(Member);\n\n  function Member(data, sid, channel, links, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Member);\n\n    _this = _super.call(this);\n    _this.channel = channel;\n    _this.links = links;\n    _this.services = services;\n    _this.services = services;\n    _this.state = {\n      attributes: parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for member: ' + sid, log$9),\n      dateCreated: data.dateCreated ? parseTime$1(data.dateCreated) : null,\n      dateUpdated: data.dateCreated ? parseTime$1(data.dateUpdated) : null,\n      sid: sid,\n      typingTimeout: null,\n      isTyping: false,\n      identity: data.identity || null,\n      roleSid: data.roleSid || null,\n      lastConsumedMessageIndex: Number.isInteger(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,\n      lastConsumptionTimestamp: data.lastConsumptionTimestamp ? parseTime$1(data.lastConsumptionTimestamp) : null,\n      type: data.type || 'chat',\n      userInfo: data.userInfo\n    };\n\n    if (!data.identity && !data.type) {\n      throw new Error('Received invalid Member object from server: Missing identity or type of Member.');\n    }\n\n    return _this;\n  }\n  /**\n   * The update reason for <code>updated</code> event emitted on Member\n   * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |\n    'lastConsumedMessageIndex' | 'lastConsumptionTimestamp')} Member#UpdateReason\n   */\n\n  /**\n   * The type of Member\n   * @typedef {('chat' | 'sms' | 'whatsapp')} Member#Type\n   */\n\n\n  _createClass__default['default'](Member, [{\n    key: \"sid\",\n    get: function get() {\n      return this.state.sid;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.state.attributes;\n    }\n  }, {\n    key: \"dateCreated\",\n    get: function get() {\n      return this.state.dateCreated;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.state.dateUpdated;\n    }\n  }, {\n    key: \"identity\",\n    get: function get() {\n      return this.state.identity;\n    }\n  }, {\n    key: \"isTyping\",\n    get: function get() {\n      return this.state.isTyping;\n    }\n  }, {\n    key: \"lastConsumedMessageIndex\",\n    get: function get() {\n      return this.state.lastConsumedMessageIndex;\n    }\n  }, {\n    key: \"lastConsumptionTimestamp\",\n    get: function get() {\n      return this.state.lastConsumptionTimestamp;\n    }\n  }, {\n    key: \"roleSid\",\n    get: function get() {\n      return this.state.roleSid;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.state.type;\n    }\n    /**\n     * Private method used to start or reset the typing indicator timeout (with event emitting)\n     * @private\n     */\n\n  }, {\n    key: \"_startTyping\",\n    value: function _startTyping(timeout) {\n      var _this2 = this;\n\n      clearTimeout(this.state.typingTimeout);\n      this.state.isTyping = true;\n      this.emit('typingStarted', this);\n      this.channel.emit('typingStarted', this);\n      this.state.typingTimeout = setTimeout(function () {\n        return _this2._endTyping();\n      }, timeout);\n      return this;\n    }\n    /**\n     * Private method function used to stop typing indicator (with event emitting)\n     * @private\n     */\n\n  }, {\n    key: \"_endTyping\",\n    value: function _endTyping() {\n      if (!this.state.typingTimeout) {\n        return;\n      }\n\n      this.state.isTyping = false;\n      this.emit('typingEnded', this);\n      this.channel.emit('typingEnded', this);\n      clearInterval(this.state.typingTimeout);\n      this.state.typingTimeout = null;\n    }\n    /**\n     * Private method function used update local object's property roleSid with new value\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(data) {\n      var updateReasons = [];\n      var updateAttributes = parseAttributes(data.attributes, 'Retrieved malformed attributes from the server for member: ' + this.state.sid, log$9);\n\n      if (data.attributes && !isDeepEqual(this.state.attributes, updateAttributes)) {\n        this.state.attributes = updateAttributes;\n        updateReasons.push('attributes');\n      }\n\n      var updatedDateUpdated = parseTime$1(data.dateUpdated);\n\n      if (data.dateUpdated && updatedDateUpdated.getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n        this.state.dateUpdated = updatedDateUpdated;\n        updateReasons.push('dateUpdated');\n      }\n\n      var updatedDateCreated = parseTime$1(data.dateCreated);\n\n      if (data.dateCreated && updatedDateCreated.getTime() !== (this.state.dateCreated && this.state.dateCreated.getTime())) {\n        this.state.dateCreated = updatedDateCreated;\n        updateReasons.push('dateCreated');\n      }\n\n      if (data.roleSid && this.state.roleSid !== data.roleSid) {\n        this.state.roleSid = data.roleSid;\n        updateReasons.push('roleSid');\n      }\n\n      if ((Number.isInteger(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null) && this.state.lastConsumedMessageIndex !== data.lastConsumedMessageIndex) {\n        this.state.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n        updateReasons.push('lastConsumedMessageIndex');\n      }\n\n      if (data.lastConsumptionTimestamp) {\n        var lastConsumptionTimestamp = new Date(data.lastConsumptionTimestamp);\n\n        if (!this.state.lastConsumptionTimestamp || this.state.lastConsumptionTimestamp.getTime() !== lastConsumptionTimestamp.getTime()) {\n          this.state.lastConsumptionTimestamp = lastConsumptionTimestamp;\n          updateReasons.push('lastConsumptionTimestamp');\n        }\n      }\n\n      if (updateReasons.length > 0) {\n        this.emit('updated', {\n          member: this,\n          updateReasons: updateReasons\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Gets User Descriptor for this member. Supported only for <code>chat</code> type of Members\n     * @returns {Promise<UserDescriptor>}\n     */\n\n  }, {\n    key: \"getUserDescriptor\",\n    value: function () {\n      var _getUserDescriptor = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.type != 'chat')) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error('Getting User Descriptor is not supported for this Member type: ' + this.type);\n\n              case 2:\n                return _context.abrupt(\"return\", this.services.users.getUserDescriptor(this.state.identity));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getUserDescriptor() {\n        return _getUserDescriptor.apply(this, arguments);\n      }\n\n      return getUserDescriptor;\n    }()\n    /**\n     * Gets User for this member and subscribes to it. Supported only for <code>chat</code> type of Members\n     * @returns {Promise<User>}\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function () {\n      var _getUser = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.type != 'chat')) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('Getting User is not supported for this Member type: ' + this.type);\n\n              case 2:\n                return _context2.abrupt(\"return\", this.services.users.getUser(this.state.identity, this.state.userInfo));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getUser() {\n        return _getUser.apply(this, arguments);\n      }\n\n      return getUser;\n    }()\n    /**\n     * Remove Member from the Channel.\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.channel.removeMember(this));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Edit member attributes.\n     * @param {any} attributes new attributes for Member.\n     * @returns {Promise<Member>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _updateAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.services.commandExecutor.mutateResource('post', this.links.self, {\n                  attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n                });\n\n              case 2:\n                return _context4.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function updateAttributes(_x) {\n        return _updateAttributes.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n  }]);\n\n  return Member;\n}(EventEmitter);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Member.prototype, \"updateAttributes\", null);\n/**\n * Fired when Member started to type.\n * @event Member#typingStarted\n * @type {Member}\n */\n\n/**\n * Fired when Member ended to type.\n * @event Member#typingEnded\n * @type {Member}\n */\n\n/**\n * Fired when Member's fields has been updated.\n * @event Member#updated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n\n\nfunction _createSuper$7(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$7() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$8 = Logger.scope('Members');\n/**\n * @classdesc Represents the collection of members for the channel\n * @fires Members#memberJoined\n * @fires Members#memberLeft\n * @fires Members#memberUpdated\n */\n\nvar Members = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Members, _EventEmitter);\n\n  var _super = _createSuper$7(Members);\n\n  function Members(channel, members, links, configuration, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Members);\n\n    _this = _super.call(this);\n    _this.channel = channel;\n    _this.members = members;\n    _this.links = links;\n    _this.configuration = configuration;\n    _this.services = services;\n    return _this;\n  }\n\n  _createClass__default['default'](Members, [{\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var entity;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.rosterEntityPromise) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.rosterEntityPromise;\n\n              case 3:\n                entity = _context.sent;\n                entity.close();\n                this.rosterEntityPromise = null;\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function unsubscribe() {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(rosterObjectName) {\n      var _this2 = this;\n\n      return this.rosterEntityPromise = this.rosterEntityPromise || this.services.syncClient.map({\n        id: rosterObjectName,\n        mode: 'open_existing'\n      }).then(function (rosterMap) {\n        rosterMap.on('itemAdded', function (args) {\n          log$8.debug(_this2.channel.sid + ' itemAdded: ' + args.item.key);\n\n          _this2.upsertMember(args.item.key, args.item.data).then(function (member) {\n            _this2.emit('memberJoined', member);\n          });\n        });\n        rosterMap.on('itemRemoved', function (args) {\n          log$8.debug(_this2.channel.sid + ' itemRemoved: ' + args.key);\n          var memberSid = args.key;\n\n          if (!_this2.members.has(memberSid)) {\n            return;\n          }\n\n          var leftMember = _this2.members.get(memberSid);\n\n          _this2.members.delete(memberSid);\n\n          _this2.emit('memberLeft', leftMember);\n        });\n        rosterMap.on('itemUpdated', function (args) {\n          log$8.debug(_this2.channel.sid + ' itemUpdated: ' + args.item.key);\n\n          _this2.upsertMember(args.item.key, args.item.data);\n        });\n        var membersPromises = [];\n        var that = _this2;\n\n        var rosterMapHandler = function rosterMapHandler(paginator) {\n          paginator.items.forEach(function (item) {\n            membersPromises.push(that.upsertMember(item.key, item.data));\n          });\n          return paginator.hasNextPage ? paginator.nextPage().then(rosterMapHandler) : null;\n        };\n\n        return rosterMap.getItems().then(rosterMapHandler).then(function () {\n          return Promise.all(membersPromises);\n        }).then(function () {\n          return rosterMap;\n        });\n      }).catch(function (err) {\n        _this2.rosterEntityPromise = null;\n\n        if (_this2.services.syncClient.connectionState != 'disconnected') {\n          log$8.error('Failed to get roster object for channel', _this2.channel.sid, err);\n        }\n\n        log$8.debug('ERROR: Failed to get roster object for channel', _this2.channel.sid, err);\n        throw err;\n      });\n    }\n  }, {\n    key: \"upsertMember\",\n    value: function () {\n      var _upsertMember = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(memberSid, data) {\n        var _this3 = this;\n\n        var member, links;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                member = this.members.get(memberSid);\n\n                if (!member) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", member._update(data));\n\n              case 3:\n                links = {\n                  self: \"\".concat(this.links.participants, \"/\").concat(memberSid)\n                };\n                member = new Member(data, memberSid, this.channel, links, this.services);\n                this.members.set(memberSid, member);\n                member.on('updated', function (args) {\n                  return _this3.emit('memberUpdated', args);\n                });\n                return _context2.abrupt(\"return\", member);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function upsertMember(_x, _x2) {\n        return _upsertMember.apply(this, arguments);\n      }\n\n      return upsertMember;\n    }()\n    /**\n     * @returns {Promise<Array<Member>>} returns list of members {@see Member}\n     */\n\n  }, {\n    key: \"getMembers\",\n    value: function getMembers() {\n      var _this4 = this;\n\n      return this.rosterEntityPromise.then(function () {\n        var members = [];\n\n        _this4.members.forEach(function (member) {\n          return members.push(member);\n        });\n\n        return members;\n      });\n    }\n    /**\n     * Get member by SID from channel\n     * @returns {Promise<Member>}\n     */\n\n  }, {\n    key: \"getMemberBySid\",\n    value: function () {\n      var _getMemberBySid = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(memberSid) {\n        var _this5 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.rosterEntityPromise.then(function () {\n                  var member = _this5.members.get(memberSid);\n\n                  if (!member) {\n                    throw new Error('Member with SID ' + memberSid + ' was not found');\n                  }\n\n                  return member;\n                }));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getMemberBySid(_x3) {\n        return _getMemberBySid.apply(this, arguments);\n      }\n\n      return getMemberBySid;\n    }()\n    /**\n     * Get member by identity from channel\n     * @returns {Promise<Member>}\n     */\n\n  }, {\n    key: \"getMemberByIdentity\",\n    value: function () {\n      var _getMemberByIdentity = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(identity) {\n        var _this6 = this;\n\n        var foundMember;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                foundMember = null;\n                return _context4.abrupt(\"return\", this.rosterEntityPromise.then(function () {\n                  _this6.members.forEach(function (member) {\n                    if (member.identity === identity) {\n                      foundMember = member;\n                    }\n                  });\n\n                  if (!foundMember) {\n                    throw new Error('Member with identity ' + identity + ' was not found');\n                  }\n\n                  return foundMember;\n                }));\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getMemberByIdentity(_x4) {\n        return _getMemberByIdentity.apply(this, arguments);\n      }\n\n      return getMemberByIdentity;\n    }()\n    /**\n     * Add user to the channel\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.services.commandExecutor.mutateResource('post', this.links.participants, {\n                  identity: identity\n                });\n\n              case 2:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function add(_x5) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Invites user to the channel\n     * User can choose either to join or not\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: \"invite\",\n    value: function () {\n      var _invite = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.services.commandExecutor.mutateResource('post', this.channel.links.invites, {\n                  identity: identity\n                });\n\n              case 2:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function invite(_x6) {\n        return _invite.apply(this, arguments);\n      }\n\n      return invite;\n    }()\n    /**\n     * Remove member from channel\n     * @returns {Promise<any>}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.services.commandExecutor.mutateResource('delete', \"\".concat(this.links.participants, \"/\").concat(identity));\n\n              case 2:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function remove(_x7) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n  }]);\n\n  return Members;\n}(EventEmitter);\n/**\n * Fired when member joined channel\n * @event Members#memberJoined\n * @type {Member}\n */\n\n/**\n * Fired when member left channel\n * @event Members#memberLeft\n * @type {Member}\n */\n\n/**\n * Fired when member updated\n * @event Members#memberUpdated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n\n/**\n * @classdesc A Media represents a media information for Message in a Channel.\n * @property {String} contentType - content type of media\n * @property {String} sid - The server-assigned unique identifier for Media\n * @property {Number} size - Size of media, bytes\n * @property {String} [filename] - file name if present, null otherwise\n */\n\n\nvar Media = /*#__PURE__*/function () {\n  function Media(data, services) {\n    _classCallCheck__default['default'](this, Media);\n\n    _defineProperty__default['default'](this, \"mcsMedia\", null);\n\n    this.services = services;\n    this.state = {\n      sid: data.sid,\n      filename: data.filename,\n      contentType: data.contentType,\n      size: data.size\n    };\n  }\n\n  _createClass__default['default'](Media, [{\n    key: \"sid\",\n    get: function get() {\n      return this.state.sid;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this.state.filename;\n    }\n  }, {\n    key: \"contentType\",\n    get: function get() {\n      return this.state.contentType;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.state.size;\n    }\n    /**\n     * Returns direct content URL for the media.\n     *\n     * This URL is impermanent, it will expire in several minutes and cannot be cached.\n     * If the URL becomes expired, you need to request a new one.\n     * Each call to this function produces a new temporary URL.\n     *\n     * @returns {Promise<String>}\n     */\n\n  }, {\n    key: \"getContentTemporaryUrl\",\n    value: function () {\n      var _getContentTemporaryUrl = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.mcsMedia) {\n                  _context.next = 8;\n                  break;\n                }\n\n                if (!this.services.mcsClient) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 4;\n                return this.services.mcsClient.get(this.state.sid);\n\n              case 4:\n                this.mcsMedia = _context.sent;\n                _context.next = 8;\n                break;\n\n              case 7:\n                throw new Error('Media Content Service is unavailable');\n\n              case 8:\n                return _context.abrupt(\"return\", this.mcsMedia.getContentUrl());\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getContentTemporaryUrl() {\n        return _getContentTemporaryUrl.apply(this, arguments);\n      }\n\n      return getContentTemporaryUrl;\n    }()\n  }]);\n\n  return Media;\n}();\n\nfunction _createSuper$6(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$6() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$7 = Logger.scope('Message');\n/**\n * @classdesc A Message represents a Message in a Channel.\n * @property {String} author - The name of the user that sent Message\n * @property {String} body - The body of the Message. Is null if Message is Media Message\n * @property {any} attributes - Message custom attributes\n * @property {Channel} channel - Channel Message belongs to\n * @property {Date} dateCreated - When Message was created\n * @property {Date} dateUpdated - When Message was updated\n * @property {Number} index - Index of Message in the Channel's messages list\n * @property {String} lastUpdatedBy - Identity of the last user that updated Message\n * @property {Media} media - Contains Media information (if present)\n * @property {String} memberSid - Authoring Member's server-assigned unique identifier\n * @property {String} sid - The server-assigned unique identifier for Message\n * @property {'text' | 'media' } type - Type of message: 'text' or 'media'\n * @fires Message#updated\n */\n\nvar Message = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Message, _EventEmitter);\n\n  var _super = _createSuper$6(Message);\n\n  function Message(index, data, channel, links, configuration, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Message);\n\n    _this = _super.call(this);\n    _this.channel = channel;\n    _this.links = links;\n    _this.configuration = configuration;\n    _this.services = services;\n    _this.state = {\n      sid: data.sid,\n      index: index,\n      author: data.author == null ? null : data.author,\n      body: data.text,\n      timestamp: data.timestamp ? new Date(data.timestamp) : null,\n      dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,\n      lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,\n      attributes: parseAttributes(data.attributes, \"Got malformed attributes for the message \".concat(data.sid), log$7),\n      type: data.type ? data.type : 'text',\n      media: data.type && data.type === 'media' && data.media ? new Media(data.media, _this.services) : null,\n      memberSid: data.memberSid == null ? null : data.memberSid\n    };\n    return _this;\n  }\n  /**\n   * The update reason for <code>updated</code> event emitted on Message\n   * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author')} Message#UpdateReason\n   */\n\n\n  _createClass__default['default'](Message, [{\n    key: \"sid\",\n    get: function get() {\n      return this.state.sid;\n    }\n  }, {\n    key: \"author\",\n    get: function get() {\n      return this.state.author;\n    }\n  }, {\n    key: \"body\",\n    get: function get() {\n      if (this.type === 'media') {\n        return null;\n      }\n\n      return this.state.body;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.state.dateUpdated;\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this.state.index;\n    }\n  }, {\n    key: \"lastUpdatedBy\",\n    get: function get() {\n      return this.state.lastUpdatedBy;\n    }\n  }, {\n    key: \"dateCreated\",\n    get: function get() {\n      return this.state.timestamp;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.state.attributes;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.state.type;\n    }\n  }, {\n    key: \"media\",\n    get: function get() {\n      return this.state.media;\n    }\n  }, {\n    key: \"memberSid\",\n    get: function get() {\n      return this.state.memberSid;\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(data) {\n      var updateReasons = [];\n\n      if ((data.text || typeof data.text === 'string') && data.text !== this.state.body) {\n        this.state.body = data.text;\n        updateReasons.push('body');\n      }\n\n      if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {\n        this.state.lastUpdatedBy = data.lastUpdatedBy;\n        updateReasons.push('lastUpdatedBy');\n      }\n\n      if (data.author && data.author !== this.state.author) {\n        this.state.author = data.author;\n        updateReasons.push('author');\n      }\n\n      if (data.dateUpdated && new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n        this.state.dateUpdated = new Date(data.dateUpdated);\n        updateReasons.push('dateUpdated');\n      }\n\n      if (data.timestamp && new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {\n        this.state.timestamp = new Date(data.timestamp);\n        updateReasons.push('dateCreated');\n      }\n\n      var updatedAttributes = parseAttributes(data.attributes, \"Got malformed attributes for the message \".concat(this.sid), log$7);\n\n      if (!isDeepEqual(this.state.attributes, updatedAttributes)) {\n        this.state.attributes = updatedAttributes;\n        updateReasons.push('attributes');\n      }\n\n      if (updateReasons.length > 0) {\n        this.emit('updated', {\n          message: this,\n          updateReasons: updateReasons\n        });\n      }\n    }\n    /**\n     * Get Member who is author of the Message\n     * @returns {Promise<Member>}\n     */\n\n  }, {\n    key: \"getMember\",\n    value: function () {\n      var _getMember = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var _this2 = this;\n\n        var member, errorMesage;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                member = null;\n\n                if (!this.state.memberSid) {\n                  _context.next = 5;\n                  break;\n                }\n\n                _context.next = 4;\n                return this.channel.getMemberBySid(this.memberSid).catch(function () {\n                  log$7.debug('Member with sid \"' + _this2.memberSid + '\" not found for message ' + _this2.sid);\n                  return null;\n                });\n\n              case 4:\n                member = _context.sent;\n\n              case 5:\n                if (!(!member && this.state.author)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 8;\n                return this.channel.getMemberByIdentity(this.state.author).catch(function () {\n                  log$7.debug('Member with identity \"' + _this2.author + '\" not found for message ' + _this2.sid);\n                  return null;\n                });\n\n              case 8:\n                member = _context.sent;\n\n              case 9:\n                if (!member) {\n                  _context.next = 11;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", member);\n\n              case 11:\n                errorMesage = 'Member with ';\n\n                if (this.state.memberSid) {\n                  errorMesage += 'SID \\'' + this.state.memberSid + '\\' ';\n                }\n\n                if (this.state.author) {\n                  if (this.state.memberSid) {\n                    errorMesage += 'or ';\n                  }\n\n                  errorMesage += 'identity \\'' + this.state.author + '\\' ';\n                }\n\n                if (errorMesage === 'Member with ') {\n                  errorMesage = 'Member ';\n                }\n\n                errorMesage += 'was not found';\n                throw new Error(errorMesage);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getMember() {\n        return _getMember.apply(this, arguments);\n      }\n\n      return getMember;\n    }()\n    /**\n     * Remove the Message.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.services.commandExecutor.mutateResource('delete', this.links.self);\n\n              case 2:\n                return _context2.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Edit message body.\n     * @param {String} body - new body of Message.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"updateBody\",\n    value: function () {\n      var _updateBody = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(body) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.services.commandExecutor.mutateResource('post', this.links.self, {\n                  body: body\n                });\n\n              case 2:\n                return _context3.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateBody(_x) {\n        return _updateBody.apply(this, arguments);\n      }\n\n      return updateBody;\n    }()\n    /**\n     * Edit message attributes.\n     * @param {any} attributes new attributes for Message.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _updateAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.services.commandExecutor.mutateResource('post', this.links.self, {\n                  attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n                });\n\n              case 2:\n                return _context4.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function updateAttributes(_x2) {\n        return _updateAttributes.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n  }]);\n\n  return Message;\n}(EventEmitter);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync('string'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Message.prototype, \"updateBody\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Message.prototype, \"updateAttributes\", null);\n/**\n * Fired when the Message's properties or body has been updated.\n * @event Message#updated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n\n\nfunction _createSuper$5(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$5() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$6 = Logger.scope('Messages');\n/**\n * Represents the collection of messages in a channel\n */\n\nvar Messages = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Messages, _EventEmitter);\n\n  var _super = _createSuper$5(Messages);\n\n  function Messages(channel, configuration, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Messages);\n\n    _this = _super.call(this);\n    _this.channel = channel;\n    _this.configuration = configuration;\n    _this.services = services;\n    _this.messagesByIndex = new Map();\n    _this.messagesListPromise = null;\n    return _this;\n  }\n  /**\n   * Subscribe to the Messages Event Stream\n   * @param {String} name - The name of Sync object for the Messages resource.\n   * @returns {Promise}\n   */\n\n\n  _createClass__default['default'](Messages, [{\n    key: \"subscribe\",\n    value: function subscribe(name) {\n      var _this2 = this;\n\n      return this.messagesListPromise = this.messagesListPromise || this.services.syncClient.list({\n        id: name,\n        mode: 'open_existing'\n      }).then(function (list) {\n        list.on('itemAdded', function (args) {\n          log$6.debug(_this2.channel.sid + ' itemAdded: ' + args.item.index);\n          var links = {\n            self: \"\".concat(_this2.channel.links.messages, \"/\").concat(args.item.data.sid),\n            conversation: _this2.channel.links.self,\n            messages_receipts: \"\".concat(_this2.channel.links.messages, \"/\").concat(args.item.data.sid, \"/Receipts\")\n          };\n          var message = new Message(args.item.index, args.item.data, _this2.channel, links, _this2.configuration, _this2.services);\n\n          if (_this2.messagesByIndex.has(message.index)) {\n            log$6.debug('Message arrived, but already known and ignored', _this2.channel.sid, message.index);\n            return;\n          }\n\n          _this2.messagesByIndex.set(message.index, message);\n\n          message.on('updated', function (args) {\n            return _this2.emit('messageUpdated', args);\n          });\n\n          _this2.emit('messageAdded', message);\n        });\n        list.on('itemRemoved', function (args) {\n          log$6.debug(_this2.channel.sid + ' itemRemoved: ' + args.index);\n          var index = args.index;\n\n          if (_this2.messagesByIndex.has(index)) {\n            var message = _this2.messagesByIndex.get(index);\n\n            _this2.messagesByIndex.delete(message.index);\n\n            message.removeAllListeners('updated');\n\n            _this2.emit('messageRemoved', message);\n          }\n        });\n        list.on('itemUpdated', function (args) {\n          log$6.debug(_this2.channel.sid + ' itemUpdated: ' + args.item.index);\n\n          var message = _this2.messagesByIndex.get(args.item.index);\n\n          if (message) {\n            message._update(args.item.data);\n          }\n        });\n        return list;\n      }).catch(function (err) {\n        _this2.messagesListPromise = null;\n\n        if (_this2.services.syncClient.connectionState != 'disconnected') {\n          log$6.error('Failed to get messages object for channel', _this2.channel.sid, err);\n        }\n\n        log$6.debug('ERROR: Failed to get messages object for channel', _this2.channel.sid, err);\n        throw err;\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var entity;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.messagesListPromise) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.messagesListPromise;\n\n              case 3:\n                entity = _context.sent;\n                entity.close();\n                this.messagesListPromise = null;\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function unsubscribe() {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n    /**\n     * Send Message to the channel\n     * @param {String} message - Message to post\n     * @param {any} attributes Message attributes\n     * @returns Returns promise which can fail\n     */\n\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(message) {\n        var attributes,\n            _args2 = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                attributes = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                log$6.debug('Sending text message', message, attributes);\n                _context2.next = 4;\n                return this.services.commandExecutor.mutateResource('post', this.channel.links.messages, {\n                  body: message || '',\n                  attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n                });\n\n              case 4:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n    /**\n     * Send Media Message to the channel\n     * @param {FormData | Channel#SendMediaOptions} mediaContent - Media content to post\n     * @param {any} attributes Message attributes\n     * @returns Returns promise which can fail\n     */\n\n  }, {\n    key: \"sendMedia\",\n    value: function () {\n      var _sendMedia = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(mediaContent) {\n        var attributes,\n            media,\n            mediaOptions,\n            _args3 = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                attributes = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                log$6.debug('Sending media message', mediaContent, attributes);\n\n                if (!(typeof FormData !== 'undefined' && mediaContent instanceof FormData)) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                log$6.debug('Sending media message as FormData', mediaContent, attributes);\n                _context3.next = 6;\n                return this.services.mcsClient.postFormData(mediaContent);\n\n              case 6:\n                media = _context3.sent;\n                _context3.next = 16;\n                break;\n\n              case 9:\n                log$6.debug('Sending media message as SendMediaOptions', mediaContent, attributes);\n                mediaOptions = mediaContent;\n\n                if (!(!mediaOptions.contentType || !mediaOptions.media)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                throw new Error('Media content <Channel#SendMediaOptions> must contain non-empty contentType and media');\n\n              case 13:\n                _context3.next = 15;\n                return this.services.mcsClient.post(mediaOptions.contentType, mediaOptions.media);\n\n              case 15:\n                media = _context3.sent;\n\n              case 16:\n                _context3.next = 18;\n                return this.services.commandExecutor.mutateResource('post', this.channel.links.messages, {\n                  media_sid: media.sid,\n                  attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n                });\n\n              case 18:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function sendMedia(_x2) {\n        return _sendMedia.apply(this, arguments);\n      }\n\n      return sendMedia;\n    }()\n    /**\n     * Returns messages from channel using paginator interface\n     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.\n     * @param {String} [anchor] Most early message id which is already known, or 'end' by default\n     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default\n     * @returns {Promise<Paginator<Message>>} last page of messages by default\n     */\n\n  }, {\n    key: \"getMessages\",\n    value: function getMessages(pageSize, anchor, direction) {\n      anchor = typeof anchor !== 'undefined' ? anchor : 'end';\n      direction = direction || 'backwards';\n      return this._getMessages(pageSize, anchor, direction);\n    }\n  }, {\n    key: \"wrapPaginator\",\n    value: function wrapPaginator(order, page, op) {\n      var _this3 = this; // We should swap next and prev page here, because of misfit of Sync and Chat paging conceptions\n\n\n      var shouldReverse = order === 'desc';\n\n      var np = function np() {\n        return page.nextPage().then(function (x) {\n          return _this3.wrapPaginator(order, x, op);\n        });\n      };\n\n      var pp = function pp() {\n        return page.prevPage().then(function (x) {\n          return _this3.wrapPaginator(order, x, op);\n        });\n      };\n\n      return op(page.items).then(function (items) {\n        return {\n          items: items.sort(function (x, y) {\n            return x.index - y.index;\n          }),\n          hasPrevPage: shouldReverse ? page.hasNextPage : page.hasPrevPage,\n          hasNextPage: shouldReverse ? page.hasPrevPage : page.hasNextPage,\n          prevPage: shouldReverse ? np : pp,\n          nextPage: shouldReverse ? pp : np\n        };\n      });\n    }\n  }, {\n    key: \"_upsertMessage\",\n    value: function _upsertMessage(index, value) {\n      var _this4 = this;\n\n      var cachedMessage = this.messagesByIndex.get(index);\n\n      if (cachedMessage) {\n        return cachedMessage;\n      }\n\n      var links = {\n        self: \"\".concat(this.channel.links.messages, \"/\").concat(value.sid),\n        conversation: this.channel.links.self,\n        messages_receipts: \"\".concat(this.channel.links.messages, \"/\").concat(value.sid, \"/Receipts\")\n      };\n      var message = new Message(index, value, this.channel, links, this.configuration, this.services);\n      this.messagesByIndex.set(message.index, message);\n      message.on('updated', function (args) {\n        return _this4.emit('messageUpdated', args);\n      });\n      return message;\n    }\n    /**\n     * Returns last messages from channel\n     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.\n     * @param {String} [anchor] Most early message id which is already known, or 'end' by default\n     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default\n     * @returns {Promise<SyncPaginator<Message>>} last page of messages by default\n     * @private\n     */\n\n  }, {\n    key: \"_getMessages\",\n    value: function _getMessages(pageSize, anchor, direction) {\n      var _this5 = this;\n\n      anchor = typeof anchor !== 'undefined' ? anchor : 'end';\n      pageSize = pageSize || 30;\n      var order = direction === 'backwards' ? 'desc' : 'asc';\n      return this.messagesListPromise.then(function (messagesList) {\n        return messagesList.getItems({\n          from: anchor !== 'end' ? anchor : void 0,\n          pageSize: pageSize,\n          order: order\n        });\n      }).then(function (page) {\n        return _this5.wrapPaginator(order, page, function (items) {\n          return Promise.all(items.map(function (item) {\n            return _this5._upsertMessage(item.index, item.data);\n          }));\n        });\n      });\n    }\n  }]);\n\n  return Messages;\n}(EventEmitter);\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray$1(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\n\nfunction _arrayLikeToArray$1(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createSuper$4(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$4() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$5 = Logger.scope('Channel');\nvar fieldMappings = {\n  lastMessage: 'lastMessage',\n  attributes: 'attributes',\n  createdBy: 'createdBy',\n  dateCreated: 'dateCreated',\n  dateUpdated: 'dateUpdated',\n  friendlyName: 'friendlyName',\n  lastConsumedMessageIndex: 'lastConsumedMessageIndex',\n  notificationLevel: 'notificationLevel',\n  sid: 'sid',\n  status: 'status',\n  type: 'type',\n  uniqueName: 'uniqueName',\n  state: 'state'\n};\n\nfunction parseTime(timeString) {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n/**\n * @classdesc A Channel represents a remote channel of communication between multiple Programmable Chat Clients\n * @property {any} attributes - The Channel's custom attributes\n * @property {String} createdBy - The identity of the User that created this Channel\n * @property {Date} dateCreated - The Date this Channel was created\n * @property {Date} dateUpdated - The Date this Channel was last updated\n * @property {String} friendlyName - The Channel's name\n * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)\n * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel\n * @property {Channel#LastMessage} lastMessage - Last Message sent to this Channel\n * @property {Channel#NotificationLevel} notificationLevel - User Notification level for this Channel\n * @property {String} sid - The Channel's unique system identifier\n * @property {Channel#State} state - The Channel's state\n * @property {Channel#Status} status - The Channel's status\n * @property {Channel#Type} type - The Channel's type\n * @property {String} uniqueName - The Channel's unique name (tag)\n * @fires Channel#memberJoined\n * @fires Channel#memberLeft\n * @fires Channel#memberUpdated\n * @fires Channel#messageAdded\n * @fires Channel#messageRemoved\n * @fires Channel#messageUpdated\n * @fires Channel#typingEnded\n * @fires Channel#typingStarted\n * @fires Channel#updated\n * @fires Channel#removed\n */\n\n\nvar Channel = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Channel, _EventEmitter);\n\n  var _super = _createSuper$4(Channel);\n\n  function Channel(descriptor, sid, links, configuration, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Channel);\n\n    _this = _super.call(this);\n    _this.sid = sid;\n    _this.links = links;\n    _this.configuration = configuration;\n    _this.services = services;\n    var attributes = descriptor.attributes || {};\n    var createdBy = descriptor.createdBy;\n    var dateCreated = parseTime(descriptor.dateCreated);\n    var dateUpdated = parseTime(descriptor.dateUpdated);\n    var friendlyName = descriptor.friendlyName || null;\n    var lastConsumedMessageIndex = Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;\n    var uniqueName = descriptor.uniqueName || null;\n\n    try {\n      JSON.stringify(attributes);\n    } catch (e) {\n      throw new Error('Attributes must be a valid JSON object.');\n    }\n\n    _this.entityName = descriptor.channel;\n    _this.channelState = {\n      uniqueName: uniqueName,\n      status: 'notParticipating',\n      type: descriptor.type,\n      attributes: attributes,\n      createdBy: createdBy,\n      dateCreated: dateCreated,\n      dateUpdated: dateUpdated,\n      friendlyName: friendlyName,\n      lastConsumedMessageIndex: lastConsumedMessageIndex\n    };\n\n    if (descriptor.notificationLevel) {\n      _this.channelState.notificationLevel = descriptor.notificationLevel;\n    }\n\n    var membersLinks = {\n      participants: _this.links.participants\n    };\n    _this.members = new Map();\n    _this.membersEntity = new Members(_assertThisInitialized__default['default'](_this), _this.members, membersLinks, _this.configuration, _this.services);\n\n    _this.membersEntity.on('memberJoined', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'memberJoined'));\n\n    _this.membersEntity.on('memberLeft', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'memberLeft'));\n\n    _this.membersEntity.on('memberUpdated', function (args) {\n      return _this.emit('memberUpdated', args);\n    });\n\n    _this.messagesEntity = new Messages(_assertThisInitialized__default['default'](_this), _this.configuration, services);\n\n    _this.messagesEntity.on('messageAdded', function (message) {\n      return _this._onMessageAdded(message);\n    });\n\n    _this.messagesEntity.on('messageUpdated', function (args) {\n      return _this.emit('messageUpdated', args);\n    });\n\n    _this.messagesEntity.on('messageRemoved', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'messageRemoved'));\n\n    return _this;\n  }\n  /**\n   * The Channel's state. Set to undefined if the channel is not a conversation.\n   * @typedef {Object | undefined} Channel#State\n   * @property {('active' | 'inactive' | 'closed')} current - the current state\n   * @property {Date} dateUpdated - date at which the latest channel state update happened\n   */\n\n  /**\n   * These options can be passed to {@link Channel#sendMessage}.\n   * @typedef {Object} Channel#SendMediaOptions\n   * @property {String} contentType - content type of media\n   * @property {String | Buffer} media - content to post\n   */\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Channel\n   * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |\n    'friendlyName' | 'lastConsumedMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |\n    'notificationLevel' )} Channel#UpdateReason\n   */\n\n  /**\n   * The status of the Channel, relative to the Client: whether the Channel\n   * is <code>notParticipating</code> to local Client, Client is <code>invited</code> to or\n   * is <code>joined</code> to this Channel\n   * @typedef {('unknown' | 'notParticipating' | 'invited' | 'joined')} Channel#Status\n   */\n\n  /**\n   * The type of Channel (<code>public</code> or <code>private</code>).\n   * @typedef {('public' | 'private')} Channel#Type\n   */\n\n  /**\n   * The User's Notification level for Channel, determines whether the currently logged-in User will receive\n   * pushes for events in this Channel. Can be either <code>muted</code> or <code>default</code>,\n   * where <code>default</code> defers to global Service push configuration.\n   * @typedef {('default' | 'muted')} Channel#NotificationLevel\n   */\n\n\n  _createClass__default['default'](Channel, [{\n    key: \"status\",\n    get: function get() {\n      return this.channelState.status;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.channelState.type;\n    }\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return this.channelState.uniqueName;\n    }\n  }, {\n    key: \"isPrivate\",\n    get: function get() {\n      return this.channelState.type === 'private';\n    }\n  }, {\n    key: \"friendlyName\",\n    get: function get() {\n      return this.channelState.friendlyName;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.channelState.dateUpdated;\n    }\n  }, {\n    key: \"dateCreated\",\n    get: function get() {\n      return this.channelState.dateCreated;\n    }\n  }, {\n    key: \"createdBy\",\n    get: function get() {\n      return this.channelState.createdBy;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.channelState.attributes;\n    }\n  }, {\n    key: \"lastConsumedMessageIndex\",\n    get: function get() {\n      return this.channelState.lastConsumedMessageIndex;\n    }\n  }, {\n    key: \"lastMessage\",\n    get: function get() {\n      return this.channelState.lastMessage;\n    }\n  }, {\n    key: \"notificationLevel\",\n    get: function get() {\n      return this.channelState.notificationLevel;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.channelState.state;\n    }\n    /**\n     * The Channel's last message's information.\n     * @typedef {Object} Channel#LastMessage\n     * @property {Number} index - Message's index\n     * @property {Date} dateCreated - Message's creation date\n     */\n\n    /**\n     * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.\n     * This or _subscribeStreams will need to be called before any events on Channel will fire.\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe() {\n      var _this2 = this;\n\n      if (this.entityPromise) {\n        return this.entityPromise;\n      }\n\n      return this.entityPromise = this.entityPromise || this.services.syncClient.document({\n        id: this.entityName,\n        mode: 'open_existing'\n      }).then(function (entity) {\n        _this2.entity = entity;\n\n        _this2.entity.on('updated', function (args) {\n          _this2._update(args.data);\n        });\n\n        _this2.entity.on('removed', function () {\n          return _this2.emit('removed', _this2);\n        });\n\n        _this2._update(_this2.entity.data);\n\n        return entity;\n      }).catch(function (err) {\n        _this2.entity = null;\n        _this2.entityPromise = null;\n\n        if (_this2.services.syncClient.connectionState != 'disconnected') {\n          log$5.error('Failed to get channel object', err);\n        }\n\n        log$5.debug('ERROR: Failed to get channel object', err);\n        throw err;\n      });\n    }\n    /**\n     * Load the attributes of this Channel and instantiate its Members and Messages.\n     * This or _subscribe will need to be called before any events on Channel will fire.\n     * This will need to be called before any events on Members or Messages will fire\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_subscribeStreams\",\n    value: function () {\n      var _subscribeStreams2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var messagesObjectName, rosterObjectName;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this._subscribe();\n\n              case 3:\n                log$5.trace('_subscribeStreams, this.entity.data=', this.entity.data);\n                messagesObjectName = this.entity.data.messages;\n                rosterObjectName = this.entity.data.roster;\n                _context.next = 8;\n                return Promise.all([this.messagesEntity.subscribe(messagesObjectName), this.membersEntity.subscribe(rosterObjectName)]);\n\n              case 8:\n                _context.next = 15;\n                break;\n\n              case 10:\n                _context.prev = 10;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (this.services.syncClient.connectionState !== 'disconnected') {\n                  log$5.error('Failed to subscribe on channel objects', this.sid, _context.t0);\n                }\n\n                log$5.debug('ERROR: Failed to subscribe on channel objects', this.sid, _context.t0);\n                throw _context.t0;\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 10]]);\n      }));\n\n      function _subscribeStreams() {\n        return _subscribeStreams2.apply(this, arguments);\n      }\n\n      return _subscribeStreams;\n    }()\n    /**\n     * Stop listening for and firing events on this Channel.\n     * @returns {Promise}\n     * @private\n     */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function () {\n      var _unsubscribe2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.isPrivate && this.entity)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.entity.close();\n\n              case 3:\n                this.entity = null;\n                this.entityPromise = null;\n\n              case 5:\n                return _context2.abrupt(\"return\", Promise.all([this.membersEntity.unsubscribe(), this.messagesEntity.unsubscribe()]));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _unsubscribe() {\n        return _unsubscribe2.apply(this, arguments);\n      }\n\n      return _unsubscribe;\n    }()\n    /**\n     * Set channel status\n     * @private\n     */\n\n  }, {\n    key: \"_setStatus\",\n    value: function _setStatus(status, source) {\n      var _this3 = this;\n\n      this.statusSource = source;\n\n      if (this.channelState.status === status) {\n        return;\n      }\n\n      this.channelState.status = status;\n\n      if (status === 'joined') {\n        this._subscribeStreams().catch(function (err) {\n          log$5.debug('ERROR while setting channel status ' + status, err);\n\n          if (_this3.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n      } else if (status === 'invited') {\n        this._subscribe().catch(function (err) {\n          log$5.debug('ERROR while setting channel status ' + status, err);\n\n          if (_this3.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n      } else if (this.entityPromise) {\n        this._unsubscribe().catch(function (err) {\n          log$5.debug('ERROR while setting channel status ' + status, err);\n\n          if (_this3.services.syncClient.connectionState !== 'disconnected') {\n            throw err;\n          }\n        });\n      }\n    }\n    /**\n     * If channel's status update source\n     * @private\n     * @return {Channels.DataSource}\n     */\n\n  }, {\n    key: \"_statusSource\",\n    value: function _statusSource() {\n      return this.statusSource;\n    }\n  }, {\n    key: \"_update\",\n    value:\n    /**\n     * Updates local channel object with new values\n     * @private\n     */\n    function _update(update) {\n      var _update$lastMessage, _update$lastMessage2, _this$channelState$la, _this$channelState$la2, _this$channelState$lo;\n\n      log$5.trace('_update', update);\n      Channel.preprocessUpdate(update, this.sid);\n      var updateReasons = new Set();\n\n      for (var _i = 0, _Object$keys = Object.keys(update); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var localKey = fieldMappings[key];\n\n        if (!localKey) {\n          continue;\n        }\n\n        switch (localKey) {\n          case fieldMappings.status:\n            if (!update.status || update.status === 'unknown' || this.channelState.status === update.status) {\n              break;\n            }\n\n            this.channelState.status = update.status;\n            updateReasons.add(localKey);\n            break;\n\n          case fieldMappings.attributes:\n            if (isDeepEqual(this.channelState.attributes, update.attributes)) {\n              break;\n            }\n\n            this.channelState.attributes = update.attributes;\n            updateReasons.add(localKey);\n            break;\n\n          case fieldMappings.lastConsumedMessageIndex:\n            if (update.lastConsumedMessageIndex === undefined || update.lastConsumedMessageIndex === this.channelState.lastConsumedMessageIndex) {\n              break;\n            }\n\n            this.channelState.lastConsumedMessageIndex = update.lastConsumedMessageIndex;\n            updateReasons.add(localKey);\n            break;\n\n          case fieldMappings.lastMessage:\n            if (this.channelState.lastMessage && !update.lastMessage) {\n              delete this.channelState.lastMessage;\n              updateReasons.add(localKey);\n              break;\n            }\n\n            this.channelState.lastMessage = this.channelState.lastMessage || {};\n\n            if (((_update$lastMessage = update.lastMessage) === null || _update$lastMessage === void 0 ? void 0 : _update$lastMessage.index) !== undefined && update.lastMessage.index !== this.channelState.lastMessage.index) {\n              this.channelState.lastMessage.index = update.lastMessage.index;\n              updateReasons.add(localKey);\n            }\n\n            if (((_update$lastMessage2 = update.lastMessage) === null || _update$lastMessage2 === void 0 ? void 0 : _update$lastMessage2.timestamp) !== undefined && ((_this$channelState$la = this.channelState.lastMessage) === null || _this$channelState$la === void 0 ? void 0 : (_this$channelState$la2 = _this$channelState$la.dateCreated) === null || _this$channelState$la2 === void 0 ? void 0 : _this$channelState$la2.getTime()) !== update.lastMessage.timestamp.getTime()) {\n              this.channelState.lastMessage.dateCreated = update.lastMessage.timestamp;\n              updateReasons.add(localKey);\n            }\n\n            if (isDeepEqual(this.channelState.lastMessage, {})) {\n              delete this.channelState.lastMessage;\n            }\n\n            break;\n\n          case fieldMappings.state:\n            var state = update.state || undefined;\n\n            if (state !== undefined) {\n              state.dateUpdated = new Date(state.dateUpdated);\n            }\n\n            if (isDeepEqual(this.channelState.state, state)) {\n              break;\n            }\n\n            this.channelState.state = state;\n            updateReasons.add(localKey);\n            break;\n\n          default:\n            var isDate = update[key] instanceof Date;\n            var keysMatchAsDates = isDate && ((_this$channelState$lo = this.channelState[localKey]) === null || _this$channelState$lo === void 0 ? void 0 : _this$channelState$lo.getTime()) === update[key].getTime();\n            var keysMatchAsNonDates = !isDate && this[localKey] === update[key];\n\n            if (keysMatchAsDates || keysMatchAsNonDates) {\n              break;\n            }\n\n            this.channelState[localKey] = update[key];\n            updateReasons.add(localKey);\n        }\n      }\n\n      if (updateReasons.size > 0) {\n        this.emit('updated', {\n          channel: this,\n          updateReasons: _toConsumableArray__default['default'](updateReasons)\n        });\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_onMessageAdded\",\n    value: function _onMessageAdded(message) {\n      var _iterator = _createForOfIteratorHelper$1(this.members.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var member = _step.value;\n\n          if (member.identity === message.author) {\n            member._endTyping();\n\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.emit('messageAdded', message);\n    }\n  }, {\n    key: \"_setLastConsumedMessageIndex\",\n    value: function () {\n      var _setLastConsumedMessageIndex2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(index) {\n        var result;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.services.commandExecutor.mutateResource('post', \"\".concat(this.configuration.links.myConversations, \"/\").concat(this.sid), {\n                  last_consumed_message_index: index\n                });\n\n              case 2:\n                result = _context3.sent;\n                return _context3.abrupt(\"return\", result.unread_messages_count);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _setLastConsumedMessageIndex(_x) {\n        return _setLastConsumedMessageIndex2.apply(this, arguments);\n      }\n\n      return _setLastConsumedMessageIndex;\n    }()\n    /**\n     * Add a participant to the Channel by its Identity.\n     * @param {String} identity - Identity of the Client to add\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.membersEntity.add(identity);\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function add(_x2) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Advance last consumed Channel's Message index to current consumption horizon.\n     * Rejects if User is not Member of Channel.\n     * Last consumed Message index is updated only if new index value is higher than previous.\n     * @param {Number} index - Message index to advance to as last read\n     * @returns {Promise<number>} resulting unread messages count in the channel\n     */\n\n  }, {\n    key: \"advanceLastConsumedMessageIndex\",\n    value: function () {\n      var _advanceLastConsumedMessageIndex = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(index) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                if (!(index < this.lastConsumedMessageIndex)) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                _context5.next = 5;\n                return this._setLastConsumedMessageIndex(this.lastConsumedMessageIndex);\n\n              case 5:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 6:\n                _context5.next = 8;\n                return this._setLastConsumedMessageIndex(index);\n\n              case 8:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function advanceLastConsumedMessageIndex(_x3) {\n        return _advanceLastConsumedMessageIndex.apply(this, arguments);\n      }\n\n      return advanceLastConsumedMessageIndex;\n    }()\n    /**\n     * Decline an invitation to the Channel and unsubscribe from its events.\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"decline\",\n    value: function () {\n      var _decline = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.services.commandExecutor.mutateResource('delete', \"\".concat(this.links.invites, \"/\").concat(this.configuration.userIdentity));\n\n              case 2:\n                return _context6.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function decline() {\n        return _decline.apply(this, arguments);\n      }\n\n      return decline;\n    }()\n    /**\n     * Delete the Channel and unsubscribe from its events.\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.services.commandExecutor.mutateResource('delete', this.links.self);\n\n              case 2:\n                return _context7.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _delete() {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * Get the custom attributes of this Channel.<br/>\n     *\n     * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>\n     * @returns {Promise<any>} attributes of this Channel\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function () {\n      var _getAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this._subscribe();\n\n              case 2:\n                return _context8.abrupt(\"return\", this.attributes);\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getAttributes() {\n        return _getAttributes.apply(this, arguments);\n      }\n\n      return getAttributes;\n    }()\n    /**\n     * Returns messages from channel using paginator interface.\n     * @param {Number} [pageSize=30] Number of messages to return in single chunk\n     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default\n     * @param {('backwards'|'forward')} [direction=backwards] - Query direction. By default it query backwards\n     *                                                          from newer to older. 'forward' will query in opposite direction\n     * @returns {Promise<Paginator<Message>>} page of messages\n     */\n\n  }, {\n    key: \"getMessages\",\n    value: function () {\n      var _getMessages = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee9(pageSize, anchor, direction) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context9.abrupt(\"return\", this.messagesEntity.getMessages(pageSize, anchor, direction));\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getMessages(_x4, _x5, _x6) {\n        return _getMessages.apply(this, arguments);\n      }\n\n      return getMessages;\n    }()\n    /**\n     * Get a list of all Members joined to this Channel.\n     * @returns {Promise<Member[]>}\n     */\n\n  }, {\n    key: \"getMembers\",\n    value: function () {\n      var _getMembers = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee10() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context10.abrupt(\"return\", this.membersEntity.getMembers());\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getMembers() {\n        return _getMembers.apply(this, arguments);\n      }\n\n      return getMembers;\n    }()\n    /**\n     * Get channel members count.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Chat system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * So this is quite useful for any UI badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"getMembersCount\",\n    value: function () {\n      var _getMembersCount = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee11() {\n        var url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                url = new UriBuilder(this.configuration.links.conversations).path(this.sid).build();\n                _context11.next = 3;\n                return this.services.network.get(url);\n\n              case 3:\n                response = _context11.sent;\n                return _context11.abrupt(\"return\", response.body.participants_count);\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getMembersCount() {\n        return _getMembersCount.apply(this, arguments);\n      }\n\n      return getMembersCount;\n    }()\n    /**\n     * Get a Member by its SID.\n     * @param {String} memberSid - Member sid\n     * @returns {Promise<Member>}\n     */\n\n  }, {\n    key: \"getMemberBySid\",\n    value: function () {\n      var _getMemberBySid = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee12(memberSid) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                return _context12.abrupt(\"return\", this.membersEntity.getMemberBySid(memberSid));\n\n              case 1:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getMemberBySid(_x7) {\n        return _getMemberBySid.apply(this, arguments);\n      }\n\n      return getMemberBySid;\n    }()\n    /**\n     * Get a Member by its identity.\n     * @param {String} identity - Member identity\n     * @returns {Promise<Member>}\n     */\n\n  }, {\n    key: \"getMemberByIdentity\",\n    value: function () {\n      var _getMemberByIdentity = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee13(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                return _context13.abrupt(\"return\", this.membersEntity.getMemberByIdentity(identity));\n\n              case 1:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getMemberByIdentity(_x8) {\n        return _getMemberByIdentity.apply(this, arguments);\n      }\n\n      return getMemberByIdentity;\n    }()\n    /**\n     * Get total message count in a channel.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Chat system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * So this is quite useful for any UI badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"getMessagesCount\",\n    value: function () {\n      var _getMessagesCount = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee14() {\n        var url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                url = new UriBuilder(this.configuration.links.conversations).path(this.sid).build();\n                _context14.next = 3;\n                return this.services.network.get(url);\n\n              case 3:\n                response = _context14.sent;\n                return _context14.abrupt(\"return\", response.body.messages_count);\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function getMessagesCount() {\n        return _getMessagesCount.apply(this, arguments);\n      }\n\n      return getMessagesCount;\n    }()\n    /**\n     * Get unconsumed messages count for a User if they are a Member of this Channel.\n     * Rejects if the User is not a Member of the Channel.\n     * <br/>\n     * This method is semi-realtime. This means that this data will be eventually correct,\n     * but will also possibly be incorrect for a few seconds. The Chat system does not\n     * provide real time events for counter values changes.\n     * <br/>\n     * So this is quite useful for any “unread messages count” badges, but is not recommended\n     * to build any core application logic based on these counters being accurate in real time.\n     * @returns {Promise<number|null>}\n     */\n\n  }, {\n    key: \"getUnconsumedMessagesCount\",\n    value: function () {\n      var _getUnconsumedMessagesCount = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee15() {\n        var url, response, unreadMessageCount;\n        return _regeneratorRuntime__default['default'].wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                url = new UriBuilder(this.configuration.links.myConversations).path(this.sid).build();\n                _context15.next = 3;\n                return this.services.network.get(url);\n\n              case 3:\n                response = _context15.sent;\n\n                if (!(response.body.conversation_sid !== this.sid)) {\n                  _context15.next = 6;\n                  break;\n                }\n\n                throw new Error('Channel was not found in the user channels list');\n\n              case 6:\n                unreadMessageCount = response.body.unread_messages_count;\n\n                if (!(typeof unreadMessageCount === 'number')) {\n                  _context15.next = 9;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\", unreadMessageCount);\n\n              case 9:\n                return _context15.abrupt(\"return\", null);\n\n              case 10:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getUnconsumedMessagesCount() {\n        return _getUnconsumedMessagesCount.apply(this, arguments);\n      }\n\n      return getUnconsumedMessagesCount;\n    }()\n    /**\n     * Invite a user to the Channel by their Identity.\n     * @param {String} identity - Identity of the user to invite\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"invite\",\n    value: function () {\n      var _invite = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee16(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this.membersEntity.invite(identity);\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function invite(_x9) {\n        return _invite.apply(this, arguments);\n      }\n\n      return invite;\n    }()\n    /**\n     * Join the Channel and subscribe to its events.\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"join\",\n    value: function () {\n      var _join = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee17() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.services.commandExecutor.mutateResource('post', this.links.participants, {\n                  identity: this.configuration.userIdentity\n                });\n\n              case 2:\n                return _context17.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function join() {\n        return _join.apply(this, arguments);\n      }\n\n      return join;\n    }()\n    /**\n     * Leave the Channel.\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"leave\",\n    value: function () {\n      var _leave = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee18() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!(this.channelState.status === 'joined')) {\n                  _context18.next = 3;\n                  break;\n                }\n\n                _context18.next = 3;\n                return this.services.commandExecutor.mutateResource('delete', \"\".concat(this.links.participants, \"/\").concat(this.configuration.userIdentity));\n\n              case 3:\n                return _context18.abrupt(\"return\", this);\n\n              case 4:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function leave() {\n        return _leave.apply(this, arguments);\n      }\n\n      return leave;\n    }()\n    /**\n     * Remove a Member from the Channel.\n     * @param {String|Member} member - Member to remove. Could either be an identity string or a Member instance.\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"removeMember\",\n    value: function () {\n      var _removeMember = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee19(member) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.membersEntity.remove(typeof member === 'string' ? member : member.sid);\n\n              case 2:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function removeMember(_x10) {\n        return _removeMember.apply(this, arguments);\n      }\n\n      return removeMember;\n    }()\n    /**\n     * Send a Message in the Channel.\n     * @param {String|FormData|Channel#SendMediaOptions|null} message - The message body for text message,\n     * FormData or MediaOptions for media content. Sending FormData supported only with browser engine\n     * @param {any} [messageAttributes] - attributes for the message\n     * @returns {Promise<number>} new Message's index in the Channel's messages list\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee20(message, messageAttributes) {\n        var _response, response;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                if (!(typeof message === 'string' || message === null)) {\n                  _context20.next = 5;\n                  break;\n                }\n\n                _context20.next = 3;\n                return this.messagesEntity.send(message, messageAttributes);\n\n              case 3:\n                _response = _context20.sent;\n                return _context20.abrupt(\"return\", parseToNumber(_response.index));\n\n              case 5:\n                _context20.next = 7;\n                return this.messagesEntity.sendMedia(message, messageAttributes);\n\n              case 7:\n                response = _context20.sent;\n                return _context20.abrupt(\"return\", parseToNumber(response.index));\n\n              case 9:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function sendMessage(_x11, _x12) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n    /**\n     * Set last consumed Channel's Message index to last known Message's index in this Channel.\n     * @returns {Promise<number>} resulting unread messages count in the channel\n     */\n\n  }, {\n    key: \"setAllMessagesConsumed\",\n    value: function () {\n      var _setAllMessagesConsumed = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee21() {\n        var messagesPage;\n        return _regeneratorRuntime__default['default'].wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                _context21.next = 4;\n                return this.getMessages(1);\n\n              case 4:\n                messagesPage = _context21.sent;\n\n                if (!(messagesPage.items.length > 0)) {\n                  _context21.next = 7;\n                  break;\n                }\n\n                return _context21.abrupt(\"return\", this.advanceLastConsumedMessageIndex(messagesPage.items[0].index));\n\n              case 7:\n                return _context21.abrupt(\"return\", Promise.resolve(0));\n\n              case 8:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function setAllMessagesConsumed() {\n        return _setAllMessagesConsumed.apply(this, arguments);\n      }\n\n      return setAllMessagesConsumed;\n    }()\n    /**\n     * Set all messages in the channel unread.\n     * @returns {Promise<number>} resulting unread messages count in the channel\n     */\n\n  }, {\n    key: \"setNoMessagesConsumed\",\n    value: function () {\n      var _setNoMessagesConsumed = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee22() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                _context22.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                _context22.next = 4;\n                return this._setLastConsumedMessageIndex(null);\n\n              case 4:\n                return _context22.abrupt(\"return\", _context22.sent);\n\n              case 5:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function setNoMessagesConsumed() {\n        return _setNoMessagesConsumed.apply(this, arguments);\n      }\n\n      return setNoMessagesConsumed;\n    }()\n    /**\n     * Set User Notification level for this channel.\n     * @param {Channel#NotificationLevel} notificationLevel - The new user notification level\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"setUserNotificationLevel\",\n    value: function () {\n      var _setUserNotificationLevel = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee23(notificationLevel) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this.services.commandExecutor.mutateResource('post', \"\".concat(this.configuration.links.myConversations, \"/\").concat(this.sid), {\n                  notification_level: notificationLevel\n                });\n\n              case 2:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function setUserNotificationLevel(_x13) {\n        return _setUserNotificationLevel.apply(this, arguments);\n      }\n\n      return setUserNotificationLevel;\n    }()\n    /**\n     * Send a notification to the server indicating that this Client is currently typing in this Channel.\n     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"typing\",\n    value: function typing() {\n      return this.services.typingIndicator.send(this.sid);\n    }\n    /**\n     * Update the Channel's attributes.\n     * @param {any} attributes new attributes for Channel.\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _updateAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee24(attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.services.commandExecutor.mutateResource('post', this.links.self, {\n                  attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n                });\n\n              case 2:\n                return _context24.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function updateAttributes(_x14) {\n        return _updateAttributes.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n    /**\n     * Update the Channel's friendlyName.\n     * @param {String} friendlyName - The new Channel friendlyName\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"updateFriendlyName\",\n    value: function () {\n      var _updateFriendlyName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee25(friendlyName) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if (!(this.channelState.friendlyName !== friendlyName)) {\n                  _context25.next = 3;\n                  break;\n                }\n\n                _context25.next = 3;\n                return this.services.commandExecutor.mutateResource('post', this.links.self, {\n                  friendly_name: friendlyName\n                });\n\n              case 3:\n                return _context25.abrupt(\"return\", this);\n\n              case 4:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function updateFriendlyName(_x15) {\n        return _updateFriendlyName.apply(this, arguments);\n      }\n\n      return updateFriendlyName;\n    }()\n    /**\n     * Set last consumed Channel's Message index to current consumption horizon.\n     * @param {Number|null} index - Message index to set as last read.\n     * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}\n     * @returns {Promise<number>} resulting unread messages count in the channel\n     */\n\n  }, {\n    key: \"updateLastConsumedMessageIndex\",\n    value: function () {\n      var _updateLastConsumedMessageIndex = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee26(index) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.next = 2;\n                return this._subscribeStreams();\n\n              case 2:\n                return _context26.abrupt(\"return\", this._setLastConsumedMessageIndex(index));\n\n              case 3:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function updateLastConsumedMessageIndex(_x16) {\n        return _updateLastConsumedMessageIndex.apply(this, arguments);\n      }\n\n      return updateLastConsumedMessageIndex;\n    }()\n    /**\n     * Update the Channel's unique name.\n     * @param {String|null} uniqueName - New unique name for the Channel. Setting unique name to null removes it.\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"updateUniqueName\",\n    value: function () {\n      var _updateUniqueName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee27(uniqueName) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                if (!(this.channelState.uniqueName !== uniqueName)) {\n                  _context27.next = 4;\n                  break;\n                }\n\n                if (!uniqueName) {\n                  uniqueName = '';\n                }\n\n                _context27.next = 4;\n                return this.services.commandExecutor.mutateResource('post', this.links.self, {\n                  unique_name: uniqueName\n                });\n\n              case 4:\n                return _context27.abrupt(\"return\", this);\n\n              case 5:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function updateUniqueName(_x17) {\n        return _updateUniqueName.apply(this, arguments);\n      }\n\n      return updateUniqueName;\n    }()\n    /**\n     * Gets User Descriptors for this channel.\n     * @returns {Promise<Paginator<UserDescriptor>>}\n     */\n\n  }, {\n    key: \"getUserDescriptors\",\n    value: function () {\n      var _getUserDescriptors = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee28() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                return _context28.abrupt(\"return\", this.services.users.getChannelUserDescriptors(this.sid));\n\n              case 1:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function getUserDescriptors() {\n        return _getUserDescriptors.apply(this, arguments);\n      }\n\n      return getUserDescriptors;\n    }()\n  }], [{\n    key: \"preprocessUpdate\",\n    value: function preprocessUpdate(update, channelSid) {\n      try {\n        if (typeof update.attributes === 'string') {\n          update.attributes = JSON.parse(update.attributes);\n        } else if (update.attributes) {\n          JSON.stringify(update.attributes);\n        }\n      } catch (e) {\n        log$5.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);\n        update.attributes = {};\n      }\n\n      try {\n        if (update.dateCreated) {\n          update.dateCreated = new Date(update.dateCreated);\n        }\n      } catch (e) {\n        log$5.warn('Retrieved malformed dateCreated from the server for channel: ' + channelSid);\n        delete update.dateCreated;\n      }\n\n      try {\n        if (update.dateUpdated) {\n          update.dateUpdated = new Date(update.dateUpdated);\n        }\n      } catch (e) {\n        log$5.warn('Retrieved malformed dateUpdated from the server for channel: ' + channelSid);\n        delete update.dateUpdated;\n      }\n\n      try {\n        if (update.lastMessage && update.lastMessage.timestamp) {\n          update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);\n        }\n      } catch (e) {\n        log$5.warn('Retrieved malformed lastMessage.timestamp from the server for channel: ' + channelSid);\n        delete update.lastMessage.timestamp;\n      }\n    }\n  }]);\n\n  return Channel;\n}(EventEmitter);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"add\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonNegativeInteger), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Number]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"advanceLastConsumedMessageIndex\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['undefined', twilioSdkTypeValidator.nonNegativeInteger], ['undefined', twilioSdkTypeValidator.nonNegativeInteger], ['undefined', twilioSdkTypeValidator.literal('backwards', 'forward')]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Number, Number, String]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"getMessages\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"getMemberBySid\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"getMemberByIdentity\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"invite\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync([twilioSdkTypeValidator.nonEmptyString, Member]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"removeMember\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', twilioSdkTypeValidator.literal(null), // Wrapping it into a custom rule is necessary because the FormData class is not available on initialization.\ntwilioSdkTypeValidator.custom(function (value) {\n  return [value instanceof FormData, 'an instance of FormData'];\n}), twilioSdkTypeValidator.objectSchema('media options', {\n  contentType: [twilioSdkTypeValidator.nonEmptyString, 'undefined'],\n  media: twilioSdkTypeValidator.custom(function (value) {\n    var isValid = typeof value === 'string' && value.length > 0 || value instanceof Uint8Array || value instanceof ArrayBuffer;\n\n    if (typeof Blob === 'function') {\n      isValid = isValid || value instanceof Blob;\n    }\n\n    return [isValid, 'a non-empty string, an instance of Buffer or an instance of Blob'];\n  })\n})], ['undefined', 'string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Object]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"sendMessage\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.literal('default', 'muted')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"setUserNotificationLevel\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"updateAttributes\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync('string'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"updateFriendlyName\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync([twilioSdkTypeValidator.literal(null), twilioSdkTypeValidator.nonNegativeInteger]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Number]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"updateLastConsumedMessageIndex\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Channel.prototype, \"updateUniqueName\", null);\n/**\n * Fired when a Member has joined the Channel.\n * @event Channel#memberJoined\n * @type {Member}\n */\n\n/**\n * Fired when a Member has left the Channel.\n * @event Channel#memberLeft\n * @type {Member}\n */\n\n/**\n * Fired when a Member's fields has been updated.\n * @event Channel#memberUpdated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n\n/**\n * Fired when a new Message has been added to the Channel.\n * @event Channel#messageAdded\n * @type {Message}\n */\n\n/**\n * Fired when Message is removed from Channel's message list.\n * @event Channel#messageRemoved\n * @type {Message}\n */\n\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Channel#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n\n/**\n * Fired when a Member has stopped typing.\n * @event Channel#typingEnded\n * @type {Member}\n */\n\n/**\n * Fired when a Member has started typing.\n * @event Channel#typingStarted\n * @type {Member}\n */\n\n/**\n * Fired when a Channel's attributes or metadata have been updated.\n * During Channel's {@link Client.create | creation and initialization} this event might be fired multiple times\n * for same joined or created Channel as new data is arriving from different sources.\n * @event Channel#updated\n * @type {Object}\n * @property {Channel} channel - Updated Channel\n * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons\n */\n\n/**\n * Fired when the Channel was destroyed or currently logged in User has left private Channel\n * @event Channel#removed\n * @type {Channel}\n */\n\n\nvar Deferred = /*#__PURE__*/function () {\n  function Deferred() {\n    var _this = this;\n\n    _classCallCheck__default['default'](this, Deferred);\n\n    this._promise = new Promise(function (resolve, reject) {\n      _this._resolve = resolve;\n      _this._reject = reject;\n    });\n  }\n\n  _createClass__default['default'](Deferred, [{\n    key: \"promise\",\n    get: function get() {\n      return this._promise;\n    }\n  }, {\n    key: \"update\",\n    value: function update(value) {\n      this._resolve(value);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      this.current = value;\n\n      this._resolve(value);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(e) {\n      this._reject(e);\n    }\n  }]);\n\n  return Deferred;\n}();\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$3(Object(source), true).forEach(function (key) {\n        _defineProperty__default['default'](target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$3(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper$3(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$3() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$4 = Logger.scope('Channels');\n/**\n * Represents channels collection\n * {@see Channel}\n */\n\nvar Channels = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Channels, _EventEmitter);\n\n  var _super = _createSuper$3(Channels);\n\n  function Channels(configuration, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Channels);\n\n    _this = _super.call(this);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"channels\", new Map());\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"tombstones\", new Set());\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"myChannelsFetched\", false);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"myChannelsRead\", new Deferred());\n\n    _this.configuration = configuration;\n    _this.services = services;\n    return _this;\n  }\n\n  _createClass__default['default'](Channels, [{\n    key: \"getMap\",\n    value: function () {\n      var _getMap = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.services.syncClient.map({\n                  id: this.configuration.myConversations,\n                  mode: 'open_existing'\n                });\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getMap() {\n        return _getMap.apply(this, arguments);\n      }\n\n      return getMap;\n    }()\n    /**\n     * Add channel to server\n     * @private\n     * @returns {Promise<Channel>} Channel\n     */\n\n  }, {\n    key: \"addChannel\",\n    value: function () {\n      var _addChannel = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(options) {\n        var attributes, response, channelSid, channelDocument, links, existingChannel, channel;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (typeof options.attributes === 'undefined') {\n                  attributes = {};\n                } else {\n                  attributes = options.attributes;\n                }\n\n                _context2.next = 3;\n                return this.services.commandExecutor.mutateResource('post', this.configuration.links.conversations, {\n                  type: options.isPrivate ? 'private' : 'public',\n                  unique_name: options.uniqueName,\n                  friendly_name: options.friendlyName,\n                  attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n                });\n\n              case 3:\n                response = _context2.sent;\n                channelSid = response.sid || null;\n                channelDocument = response.sync_objects.conversation || null;\n                links = _objectSpread$3({\n                  self: response.url\n                }, response.links);\n                existingChannel = this.channels.get(channelSid);\n\n                if (!existingChannel) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                _context2.next = 11;\n                return existingChannel._subscribe();\n\n              case 11:\n                return _context2.abrupt(\"return\", existingChannel);\n\n              case 12:\n                channel = new Channel({\n                  channel: channelDocument,\n                  entityName: null,\n                  uniqueName: null,\n                  attributes: null,\n                  createdBy: null,\n                  friendlyName: null,\n                  lastConsumedMessageIndex: null,\n                  type: options.isPrivate ? 'private' : 'public',\n                  dateCreated: null,\n                  dateUpdated: null\n                }, channelSid, links, this.configuration, this.services);\n                this.channels.set(channel.sid, channel);\n                this.registerForEvents(channel);\n                _context2.next = 17;\n                return channel._subscribe();\n\n              case 17:\n                this.emit('channelAdded', channel);\n                return _context2.abrupt(\"return\", channel);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function addChannel(_x) {\n        return _addChannel.apply(this, arguments);\n      }\n\n      return addChannel;\n    }()\n    /**\n     * Fetch channels list and instantiate all necessary objects\n     */\n\n  }, {\n    key: \"fetchChannels\",\n    value: function () {\n      var _fetchChannels = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {\n        var _this2 = this;\n\n        var map, myChannels, upserts, _iterator, _step, channel, errorMessage;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this.getMap();\n\n              case 3:\n                map = _context3.sent;\n                map.on('itemAdded', function (args) {\n                  log$4.debug(\"itemAdded: \".concat(args.item.key));\n\n                  _this2.upsertChannel('sync', args.item.key, args.item.data);\n                });\n                map.on('itemRemoved', function (args) {\n                  log$4.debug(\"itemRemoved: \".concat(args.key));\n                  var sid = args.key;\n\n                  if (!_this2.myChannelsFetched) {\n                    _this2.tombstones.add(sid);\n                  }\n\n                  var channel = _this2.channels.get(sid);\n\n                  if (!channel) {\n                    return;\n                  }\n\n                  if (channel.status === 'joined' || channel.status === 'invited') {\n                    channel._setStatus('notParticipating', 'sync');\n\n                    _this2.emit('channelLeft', channel);\n                  }\n\n                  if (channel.isPrivate) {\n                    _this2.channels.delete(sid);\n\n                    _this2.emit('channelRemoved', channel);\n\n                    channel.emit('removed', channel);\n                  }\n                });\n                map.on('itemUpdated', function (args) {\n                  log$4.debug(\"itemUpdated: \".concat(args.item.key));\n\n                  _this2.upsertChannel('sync', args.item.key, args.item.data);\n                });\n                _context3.next = 9;\n                return this._fetchMyChannels();\n\n              case 9:\n                myChannels = _context3.sent;\n                upserts = [];\n                _iterator = _createForOfIteratorHelper(myChannels);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    channel = _step.value;\n                    upserts.push(this.upsertChannel('rest', channel.channel_sid, channel));\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                this.myChannelsRead.set(true);\n                _context3.next = 16;\n                return Promise.all(upserts);\n\n              case 16:\n                this.myChannelsFetched = true;\n                this.tombstones.clear();\n                log$4.debug('The channels list has been successfully fetched');\n                return _context3.abrupt(\"return\", this);\n\n              case 22:\n                _context3.prev = 22;\n                _context3.t0 = _context3[\"catch\"](0);\n                errorMessage = 'Failed to fetch the channels list';\n\n                if (this.services.syncClient.connectionState !== 'disconnected') {\n                  log$4.error(errorMessage, _context3.t0);\n                }\n\n                log$4.debug(\"ERROR: \".concat(errorMessage), _context3.t0);\n                throw _context3.t0;\n\n              case 28:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 22]]);\n      }));\n\n      function fetchChannels() {\n        return _fetchChannels.apply(this, arguments);\n      }\n\n      return fetchChannels;\n    }()\n  }, {\n    key: \"_wrapPaginator\",\n    value: function _wrapPaginator(page, op) {\n      var _this3 = this;\n\n      return op(page.items).then(function (items) {\n        return {\n          items: items,\n          hasNextPage: page.hasNextPage,\n          hasPrevPage: page.hasPrevPage,\n          nextPage: function nextPage() {\n            return page.nextPage().then(function (x) {\n              return _this3._wrapPaginator(x, op);\n            });\n          },\n          prevPage: function prevPage() {\n            return page.prevPage().then(function (x) {\n              return _this3._wrapPaginator(x, op);\n            });\n          }\n        };\n      });\n    }\n  }, {\n    key: \"getChannels\",\n    value: function getChannels(args) {\n      var _this4 = this;\n\n      return this.getMap().then(function (channelsMap) {\n        return channelsMap.getItems(args);\n      }).then(function (page) {\n        return _this4._wrapPaginator(page, function (items) {\n          return Promise.all(items.map(function (item) {\n            return _this4.upsertChannel('sync', item.key, item.data);\n          }));\n        });\n      });\n    }\n  }, {\n    key: \"getChannel\",\n    value: function getChannel(sid) {\n      var _this5 = this;\n\n      return this.getMap().then(function (channelsMap) {\n        return channelsMap.getItems({\n          key: sid\n        });\n      }).then(function (page) {\n        return page.items.map(function (item) {\n          return _this5.upsertChannel('sync', item.key, item.data);\n        });\n      }).then(function (items) {\n        return items.length > 0 ? items[0] : null;\n      });\n    }\n  }, {\n    key: \"pushChannel\",\n    value: function pushChannel(descriptor) {\n      var sid = descriptor.sid;\n      var data = {\n        entityName: null,\n        lastConsumedMessageIndex: descriptor.lastConsumedMessageIndex,\n        type: descriptor.type,\n        status: descriptor.status,\n        friendlyName: descriptor.friendlyName,\n        dateUpdated: descriptor.dateUpdated,\n        dateCreated: descriptor.dateCreated,\n        uniqueName: descriptor.uniqueName,\n        createdBy: descriptor.createdBy,\n        attributes: descriptor.attributes,\n        channel: descriptor.channel,\n        notificationLevel: descriptor.notificationLevel,\n        sid: sid\n      };\n      return this.upsertChannel('chat', sid, data);\n    }\n  }, {\n    key: \"_updateChannel\",\n    value: function _updateChannel(source, channel, data) {\n      var _this6 = this;\n\n      var areSourcesDifferent = channel._statusSource() !== undefined && source !== channel._statusSource();\n\n      var isChannelSourceSync = source !== 'rest' || channel._statusSource() === 'sync';\n\n      if (areSourcesDifferent && isChannelSourceSync && source !== 'sync') {\n        log$4.trace('upsertChannel: the channel is known from sync and it came from chat, ignoring', {\n          sid: channel.sid,\n          data: data.status,\n          channel: channel.status\n        });\n        return;\n      }\n\n      if (['joined', 'invited'].includes(data.status) && channel.status !== data.status) {\n        channel._setStatus(data.status, source);\n\n        var updateData = {};\n\n        if (data.notificationLevel !== undefined) {\n          updateData.notificationLevel = data.notificationLevel;\n        }\n\n        if (data.lastConsumedMessageIndex !== undefined) {\n          updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n        }\n\n        if (!isDeepEqual(updateData, {})) {\n          channel._update(updateData);\n        }\n\n        channel._subscribe().then(function () {\n          _this6.emit(data.status === 'joined' ? 'channelJoined' : 'channelInvited', channel);\n        });\n\n        return;\n      }\n\n      if (['joined', 'invited'].includes(channel.status) && data.status === 'notParticipating') {\n        channel._setStatus('notParticipating', source);\n\n        channel._update(data);\n\n        channel._subscribe().then(function () {\n          _this6.emit('channelLeft', channel);\n        });\n\n        return;\n      }\n\n      if (data.type === 'private' && data.status === 'notParticipating') {\n        channel._subscribe();\n\n        return;\n      }\n\n      channel._update(data);\n    }\n  }, {\n    key: \"upsertChannel\",\n    value: function upsertChannel(source, sid, data) {\n      var _this7 = this;\n\n      log$4.trace(\"upsertChannel called for \".concat(sid), data);\n      var channel = this.channels.get(sid); // If the channel is known, update it\n\n      if (channel) {\n        log$4.trace(\"upsertChannel: the channel \".concat(channel.sid, \" is known;\") + \"its status is known from source \".concat(channel._statusSource(), \" \") + \"and the update came from source \".concat(source), channel);\n\n        this._updateChannel(source, channel, data);\n\n        return channel._subscribe().then(function () {\n          return channel;\n        });\n      } // If the channel is deleted, ignore it\n\n\n      if (['chat', 'rest'].includes(source) && this.tombstones.has(sid)) {\n        log$4.trace('upsertChannel: the channel is deleted but reappeared again from chat, ignoring', sid);\n        return;\n      } // If the channel is unknown, fetch it\n\n\n      log$4.trace(\"upsertChannel: creating a local channel object with sid \".concat(sid), data);\n      var baseLink = \"\".concat(this.configuration.links.conversations, \"/\").concat(sid);\n      var links = {\n        self: baseLink,\n        messages: \"\".concat(baseLink, \"/Messages\"),\n        participants: \"\".concat(baseLink, \"/Participants\"),\n        invites: \"\".concat(baseLink, \"/Invites\")\n      };\n      var newChannel = new Channel(data, sid, links, this.configuration, this.services);\n      this.channels.set(sid, newChannel);\n      return newChannel._subscribe().then(function () {\n        _this7.registerForEvents(newChannel);\n\n        _this7.emit('channelAdded', newChannel);\n\n        if (['joined', 'invited'].includes(data.status)) {\n          newChannel._setStatus(data.status, source);\n\n          _this7.emit(data.status === 'joined' ? 'channelJoined' : 'channelInvited', newChannel);\n        }\n\n        return newChannel;\n      });\n    }\n  }, {\n    key: \"onChannelRemoved\",\n    value: function onChannelRemoved(sid) {\n      var channel = this.channels.get(sid);\n\n      if (channel) {\n        this.channels.delete(sid);\n        this.emit('channelRemoved', channel);\n      }\n    }\n  }, {\n    key: \"registerForEvents\",\n    value: function registerForEvents(channel) {\n      var _this8 = this;\n\n      channel.on('removed', function () {\n        return _this8.onChannelRemoved(channel.sid);\n      });\n      channel.on('updated', function (args) {\n        return _this8.emit('channelUpdated', args);\n      });\n      channel.on('memberJoined', this.emit.bind(this, 'memberJoined'));\n      channel.on('memberLeft', this.emit.bind(this, 'memberLeft'));\n      channel.on('memberUpdated', function (args) {\n        return _this8.emit('memberUpdated', args);\n      });\n      channel.on('messageAdded', this.emit.bind(this, 'messageAdded'));\n      channel.on('messageUpdated', function (args) {\n        return _this8.emit('messageUpdated', args);\n      });\n      channel.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n      channel.on('typingStarted', this.emit.bind(this, 'typingStarted'));\n      channel.on('typingEnded', this.emit.bind(this, 'typingEnded'));\n    }\n  }, {\n    key: \"_fetchMyChannels\",\n    value: function () {\n      var _fetchMyChannels2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {\n        var channels, pageToken, url, response, preProcessedChannels;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                channels = [];\n                pageToken = null;\n\n              case 2:\n                url = new UriBuilder(this.configuration.links.myConversations);\n\n                if (pageToken) {\n                  url.arg('PageToken', pageToken);\n                }\n\n                _context4.next = 6;\n                return this.services.network.get(url.build());\n\n              case 6:\n                response = _context4.sent;\n                preProcessedChannels = response.body.conversations.map(function (channelDescriptor) {\n                  return {\n                    descriptor: channelDescriptor,\n                    channel_sid: channelDescriptor.conversation_sid,\n                    status: channelDescriptor.status,\n                    channel: channelDescriptor.sync_objects.conversation,\n                    messages: channelDescriptor.sync_objects.messages,\n                    roster: \"\".concat(channelDescriptor.conversation_sid, \".roster\"),\n                    lastConsumedMessageIndex: channelDescriptor.last_consumed_message_index,\n                    notificationLevel: channelDescriptor.notification_level\n                  };\n                });\n                pageToken = response.body.meta.next_token;\n                channels = [].concat(_toConsumableArray__default['default'](channels), _toConsumableArray__default['default'](preProcessedChannels));\n\n              case 10:\n                if (pageToken) {\n                  _context4.next = 2;\n                  break;\n                }\n\n              case 11:\n                return _context4.abrupt(\"return\", channels);\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _fetchMyChannels() {\n        return _fetchMyChannels2.apply(this, arguments);\n      }\n\n      return _fetchMyChannels;\n    }()\n  }]);\n\n  return Channels;\n}(EventEmitter);\n\nfunction _createSuper$2(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$2() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log$3 = Logger.scope('User');\n/**\n * @classdesc Extended user information.\n * Note that <code>online</code> and <code>notifiable</code> properties are eligible\n * to use only if reachability function is enabled.\n * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.\n *\n * @property {String} identity - User identity\n * @property {String} friendlyName - User friendly name, null if not set\n * @property {any} attributes - Object with custom attributes for user\n * @property {Boolean} online - User real-time channel connection status\n * @property {Boolean} notifiable - User push notification registration status\n * @property {Boolean} isSubscribed - Check if this user receives real-time status updates\n *\n * @fires User#updated\n * @fires User#userSubscribed\n * @fires User#userUnsubscribed\n *\n * @constructor\n * @param {String} identity - Identity of user\n * @param {String} entityId - id of user's object\n * @param {Object} datasync - datasync service\n */\n\nvar User = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](User, _EventEmitter);\n\n  var _super = _createSuper$2(User);\n\n  function User(identity, entityName, links, configuration, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, User);\n\n    _this = _super.call(this);\n    _this.links = links;\n    _this.configuration = configuration;\n    _this.services = services;\n    _this.subscribed = 'initializing';\n\n    _this.setMaxListeners(0);\n\n    _this.state = {\n      identity: identity,\n      entityName: entityName,\n      friendlyName: null,\n      attributes: {},\n      online: null,\n      notifiable: null\n    };\n    return _this;\n  }\n  /**\n   * The update reason for <code>updated</code> event emitted on User\n   * @typedef {('friendlyName' | 'attributes' | 'online' | 'notifiable')} User#UpdateReason\n   */\n\n\n  _createClass__default['default'](User, [{\n    key: \"identity\",\n    get: function get() {\n      return this.state.identity;\n    },\n    set: function set(identity) {\n      this.state.identity = identity;\n    }\n  }, {\n    key: \"entityName\",\n    set: function set(name) {\n      this.state.entityName = name;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this.state.attributes;\n    }\n  }, {\n    key: \"friendlyName\",\n    get: function get() {\n      return this.state.friendlyName;\n    }\n  }, {\n    key: \"online\",\n    get: function get() {\n      return this.state.online;\n    }\n  }, {\n    key: \"notifiable\",\n    get: function get() {\n      return this.state.notifiable;\n    }\n  }, {\n    key: \"isSubscribed\",\n    get: function get() {\n      return this.subscribed == 'subscribed';\n    } // Handles service updates\n\n  }, {\n    key: \"_update\",\n    value: function _update(key, value) {\n      var updateReasons = [];\n      log$3.debug('User for', this.state.identity, 'updated:', key, value);\n\n      switch (key) {\n        case 'friendlyName':\n          if (this.state.friendlyName !== value.value) {\n            updateReasons.push('friendlyName');\n            this.state.friendlyName = value.value;\n          }\n\n          break;\n\n        case 'attributes':\n          var updateAttributes = parseAttributes(value.value, \"Retrieved malformed attributes from the server for user: \".concat(this.state.identity), log$3);\n\n          if (!isDeepEqual(this.state.attributes, updateAttributes)) {\n            this.state.attributes = updateAttributes;\n            updateReasons.push('attributes');\n          }\n\n          break;\n\n        case 'reachability':\n          if (this.state.online !== value.online) {\n            this.state.online = value.online;\n            updateReasons.push('online');\n          }\n\n          if (this.state.notifiable !== value.notifiable) {\n            this.state.notifiable = value.notifiable;\n            updateReasons.push('notifiable');\n          }\n\n          break;\n\n        default:\n          return;\n      }\n\n      if (updateReasons.length > 0) {\n        this.emit('updated', {\n          user: this,\n          updateReasons: updateReasons\n        });\n      }\n    } // Fetch reachability info\n\n  }, {\n    key: \"_updateReachabilityInfo\",\n    value: function () {\n      var _updateReachabilityInfo2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(map, update) {\n        var _this2 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.configuration.reachabilityEnabled) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 2:\n                return _context.abrupt(\"return\", map.get('reachability').then(update).catch(function (err) {\n                  log$3.warn('Failed to get reachability info for ', _this2.state.identity, err);\n                }));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _updateReachabilityInfo(_x, _x2) {\n        return _updateReachabilityInfo2.apply(this, arguments);\n      }\n\n      return _updateReachabilityInfo;\n    }() // Fetch user\n\n  }, {\n    key: \"_fetch\",\n    value: function () {\n      var _fetch2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        var _this3 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.state.entityName) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this);\n\n              case 2:\n                this.promiseToFetch = this.services.syncClient.map({\n                  id: this.state.entityName,\n                  mode: 'open_existing',\n                  includeItems: true\n                }).then(function (map) {\n                  _this3.entity = map;\n                  map.on('itemUpdated', function (args) {\n                    log$3.debug(_this3.state.entityName + ' (' + _this3.state.identity + ') itemUpdated: ' + args.item.key);\n                    return _this3._update(args.item.key, args.item.data);\n                  });\n                  return Promise.all([map.get('friendlyName').then(function (item) {\n                    return _this3._update(item.key, item.data);\n                  }), map.get('attributes').then(function (item) {\n                    return _this3._update(item.key, item.data);\n                  }), _this3._updateReachabilityInfo(map, function (item) {\n                    return _this3._update(item.key, item.data);\n                  })]);\n                }).then(function () {\n                  log$3.debug('Fetched for', _this3.identity);\n                  _this3.subscribed = 'subscribed';\n\n                  _this3.emit('userSubscribed', _this3);\n\n                  return _this3;\n                }).catch(function (err) {\n                  _this3.promiseToFetch = null;\n                  throw err;\n                });\n                return _context2.abrupt(\"return\", this.promiseToFetch);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _fetch() {\n        return _fetch2.apply(this, arguments);\n      }\n\n      return _fetch;\n    }()\n  }, {\n    key: \"_ensureFetched\",\n    value: function _ensureFetched() {\n      return this.promiseToFetch || this._fetch();\n    }\n    /**\n     * Updates user attributes.\n     * @param {any} attributes new attributes for User.\n     * @returns {Promise<User>}\n     */\n\n  }, {\n    key: \"updateAttributes\",\n    value: function () {\n      var _updateAttributes = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(attributes) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.subscribed == 'unsubscribed')) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error('Can\\'t modify unsubscribed object');\n\n              case 2:\n                _context3.next = 4;\n                return this.services.commandExecutor.mutateResource('post', this.links.self, {\n                  attributes: JSON.stringify(attributes)\n                });\n\n              case 4:\n                return _context3.abrupt(\"return\", this);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateAttributes(_x3) {\n        return _updateAttributes.apply(this, arguments);\n      }\n\n      return updateAttributes;\n    }()\n    /**\n     * Update Users friendlyName.\n     * @param {String} friendlyName - Updated friendlyName\n     * @returns {Promise<User>}\n     */\n\n  }, {\n    key: \"updateFriendlyName\",\n    value: function () {\n      var _updateFriendlyName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(friendlyName) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.subscribed == 'unsubscribed')) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('Can\\'t modify unsubscribed object');\n\n              case 2:\n                _context4.next = 4;\n                return this.services.commandExecutor.mutateResource('post', this.links.self, {\n                  friendly_name: friendlyName\n                });\n\n              case 4:\n                return _context4.abrupt(\"return\", this);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function updateFriendlyName(_x4) {\n        return _updateFriendlyName.apply(this, arguments);\n      }\n\n      return updateFriendlyName;\n    }()\n    /**\n     * Removes User from subscription list.\n     * @returns {Promise<void>} Promise of completion\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!this.promiseToFetch) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                _context5.next = 3;\n                return this.promiseToFetch;\n\n              case 3:\n                this.entity.close();\n                this.promiseToFetch = null;\n                this.subscribed = 'unsubscribed';\n                this.emit('userUnsubscribed', this);\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function unsubscribe() {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n  }]);\n\n  return User;\n}(EventEmitter);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['string', 'number', 'boolean', 'object', twilioSdkTypeValidator.literal(null)]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], User.prototype, \"updateAttributes\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync('string'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], User.prototype, \"updateFriendlyName\", null);\n/**\n * Fired when User's properties or reachability status have been updated.\n * @event User#updated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n\n/**\n * Fired when Client is subscribed to User.\n * @event User#userSubscribed\n * @type {User}\n */\n\n/**\n * Fired when Client is unsubscribed from this User.\n * @event User#userUnsubscribed\n * @type {User}\n */\n\n\nvar log$2 = Logger.scope('UserDescriptor');\n/**\n * @classdesc Extended user information.\n * Note that <code>online</code> and <code>notifiable</code> properties are eligible\n * to use only if reachability function is enabled.\n * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.\n *\n * @property {String} identity - User identity\n * @property {String} friendlyName - User friendly name, null if not set\n * @property {any} attributes - Object with custom attributes for user\n * @property {Boolean} online - User real-time channel connection status\n * @property {Boolean} notifiable - User push notification registration status\n *\n * @constructor\n * @param {Users} users Users instance\n * @param {Object} descriptor User descriptor data object\n */\n\nvar UserDescriptor = /*#__PURE__*/function () {\n  /**\n   * @param {UserDescriptorServices} services - services, needed for UserDescriptor\n   * @param {Object} descriptor User descriptor data object\n   * @private\n   */\n  function UserDescriptor(services, descriptor) {\n    _classCallCheck__default['default'](this, UserDescriptor);\n\n    this.services = services;\n    this.descriptor = descriptor;\n    this.identity = descriptor.identity;\n    this.friendlyName = descriptor.friendly_name;\n    this.attributes = parseAttributes(descriptor.attributes, 'Failed to parse user attributes', log$2);\n    this.online = descriptor.is_online;\n    this.notifiable = descriptor.is_notifiable;\n  }\n  /**\n   * Gets User object from descriptor and subscribes to it.\n   * @returns {Promise<User>}\n   */\n\n\n  _createClass__default['default'](UserDescriptor, [{\n    key: \"subscribe\",\n    value: function subscribe() {\n      return this.services.users.getUser(this.identity, this.descriptor.sync_unique_name);\n    }\n  }, {\n    key: \"_getDescriptor\",\n    value: function _getDescriptor() {\n      return this.descriptor;\n    }\n  }]);\n\n  return UserDescriptor;\n}();\n\nvar UserDescriptors = /*#__PURE__*/function () {\n  function UserDescriptors(configuration, services) {\n    _classCallCheck__default['default'](this, UserDescriptors);\n\n    this.configuration = configuration;\n    this.services = services;\n  }\n\n  _createClass__default['default'](UserDescriptors, [{\n    key: \"getUserDescriptor\",\n    value: function () {\n      var _getUserDescriptor = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(identity) {\n        var url, response;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                url = new UriBuilder(this.configuration.links.users).path(identity).build();\n                _context.next = 3;\n                return this.services.network.get(url);\n\n              case 3:\n                response = _context.sent;\n                return _context.abrupt(\"return\", new UserDescriptor(this.services, response.body));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getUserDescriptor(_x) {\n        return _getUserDescriptor.apply(this, arguments);\n      }\n\n      return getUserDescriptor;\n    }()\n  }, {\n    key: \"getChannelUserDescriptors\",\n    value: function () {\n      var _getChannelUserDescriptors = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(channelSid) {\n        var _this = this;\n\n        var args,\n            url,\n            response,\n            _args2 = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                args = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                url = new UriBuilder(this.configuration.links.users).arg('ConversationSid', channelSid).arg('PageToken', args.pageToken).build();\n                _context2.next = 4;\n                return this.services.network.get(url);\n\n              case 4:\n                response = _context2.sent;\n                return _context2.abrupt(\"return\", new RestPaginator(response.body.users.map(function (x) {\n                  return new UserDescriptor(_this.services, x);\n                }), function (pageToken) {\n                  return _this.getChannelUserDescriptors(channelSid, {\n                    pageToken: pageToken\n                  });\n                }, response.body.meta.prev_token, response.body.meta.next_token));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getChannelUserDescriptors(_x2) {\n        return _getChannelUserDescriptors.apply(this, arguments);\n      }\n\n      return getChannelUserDescriptors;\n    }()\n  }]);\n\n  return UserDescriptors;\n}();\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$2(Object(source), true).forEach(function (key) {\n        _defineProperty__default['default'](target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @classdesc Container for known users\n * @fires Users#userUpdated\n */\n\n\nvar Users = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Users, _EventEmitter);\n\n  var _super = _createSuper$1(Users);\n\n  function Users(configuration, services) {\n    var _this;\n\n    _classCallCheck__default['default'](this, Users);\n\n    _this = _super.call(this);\n    _this.configuration = configuration;\n    _this.services = services;\n    var userLinks = {\n      self: \"\".concat(configuration.links.users, \"/\").concat(configuration.userIdentity)\n    };\n    _this.fifoStack = [];\n    _this.myself = new User(_this.configuration.userIdentity, _this.configuration.userInfo, userLinks, _this.configuration, _this.services);\n\n    _this.myself.on('updated', function (args) {\n      return _this.emit('userUpdated', args);\n    });\n\n    _this.myself.on('userSubscribed', function () {\n      return _this.emit('userSubscribed', _this.myself);\n    });\n\n    _this.myself.on('userUnsubscribed', function () {\n      _this.emit('userUnsubscribed', _this.myself);\n\n      _this.myself._ensureFetched();\n    });\n\n    _this.subscribedUsers = new Map();\n    _this.userDescriptors = new UserDescriptors(_this.configuration, _objectSpread$2(_objectSpread$2({}, _this.services), {}, {\n      users: _assertThisInitialized__default['default'](_this)\n    }));\n    return _this;\n  }\n\n  _createClass__default['default'](Users, [{\n    key: \"handleUnsubscribeUser\",\n    value: function handleUnsubscribeUser(user) {\n      if (this.subscribedUsers.has(user.identity)) {\n        this.subscribedUsers.delete(user.identity);\n      }\n\n      var foundItemIndex = -1;\n      var foundItem = this.fifoStack.find(function (item, index) {\n        if (item == user.identity) {\n          foundItemIndex = index;\n          return true;\n        }\n\n        return false;\n      });\n\n      if (foundItem) {\n        this.fifoStack.splice(foundItemIndex, 1);\n      }\n\n      this.emit('userUnsubscribed', user);\n    }\n  }, {\n    key: \"handleSubscribeUser\",\n    value: function handleSubscribeUser(user) {\n      if (this.subscribedUsers.has(user.identity)) {\n        return;\n      }\n\n      if (this.fifoStack.length >= this.configuration.userInfosToSubscribe) {\n        this.subscribedUsers.get(this.fifoStack.shift()).unsubscribe();\n      }\n\n      this.fifoStack.push(user.identity);\n      this.subscribedUsers.set(user.identity, user);\n      this.emit('userSubscribed', user);\n    }\n    /**\n     * Gets user, if it's in subscribed list - then return the user object from it,\n     * if not - then subscribes and adds user to the FIFO stack\n     * @returns {Promise<User>} Fully initialized user\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function () {\n      var _getUser = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(identity) {\n        var _this2 = this;\n\n        var entityName,\n            user,\n            userDescriptor,\n            userLinks,\n            _args = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                entityName = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;\n                _context.next = 3;\n                return this.myself._ensureFetched();\n\n              case 3:\n                if (!(identity == this.myself.identity)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.myself);\n\n              case 5:\n                user = this.subscribedUsers.get(identity);\n\n                if (user) {\n                  _context.next = 19;\n                  break;\n                }\n\n                if (entityName) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 10;\n                return this.getUserDescriptor(identity);\n\n              case 10:\n                userDescriptor = _context.sent;\n                entityName = userDescriptor._getDescriptor().sync_objects.user_info_map;\n\n              case 12:\n                userLinks = {\n                  self: \"\".concat(this.configuration.links.users, \"/\").concat(identity)\n                };\n                user = new User(identity, entityName, userLinks, this.configuration, this.services);\n                user.on('updated', function (args) {\n                  return _this2.emit('userUpdated', args);\n                });\n                user.on('userSubscribed', function () {\n                  return _this2.handleSubscribeUser(user);\n                });\n                user.on('userUnsubscribed', function () {\n                  return _this2.handleUnsubscribeUser(user);\n                });\n                _context.next = 19;\n                return user._ensureFetched();\n\n              case 19:\n                return _context.abrupt(\"return\", user);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getUser(_x) {\n        return _getUser.apply(this, arguments);\n      }\n\n      return getUser;\n    }()\n    /**\n     * @returns {Promise<UserDescriptor>} User descriptor\n     */\n\n  }, {\n    key: \"getUserDescriptor\",\n    value: function () {\n      var _getUserDescriptor = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.userDescriptors.getUserDescriptor(identity));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getUserDescriptor(_x2) {\n        return _getUserDescriptor.apply(this, arguments);\n      }\n\n      return getUserDescriptor;\n    }()\n    /**\n     * @returns {Promise<Paginator<UserDescriptor>>} Users descriptors page for given channel sid\n     */\n\n  }, {\n    key: \"getChannelUserDescriptors\",\n    value: function () {\n      var _getChannelUserDescriptors = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(channelSid) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.userDescriptors.getChannelUserDescriptors(channelSid));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getChannelUserDescriptors(_x3) {\n        return _getChannelUserDescriptors.apply(this, arguments);\n      }\n\n      return getChannelUserDescriptors;\n    }()\n    /**\n     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}\n     */\n\n  }, {\n    key: \"getSubscribedUsers\",\n    value: function () {\n      var _getSubscribedUsers = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4() {\n        var users;\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.myself._ensureFetched();\n\n              case 2:\n                users = [this.myself];\n                this.subscribedUsers.forEach(function (user) {\n                  return users.push(user);\n                });\n                return _context4.abrupt(\"return\", users);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getSubscribedUsers() {\n        return _getSubscribedUsers.apply(this, arguments);\n      }\n\n      return getSubscribedUsers;\n    }()\n  }]);\n\n  return Users;\n}(EventEmitter);\n\nvar log$1 = Logger.scope('TypingIndicator');\n/**\n * An important note in regards to typing timeout timers. There are two places that the SDK can get the \"typing_timeout\" attribute from. The first\n * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the\n * \"typing_timeout\" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a\n * notification of type \"twilio.ipmsg.typing_indicator\". In this case, the \"typing_timeout\" value will be +1 of that in the console. This\n * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,\n * the timeout returned from the notification should be used as the timeout for the \"typingEnded\" event, +1 is to account for latency.\n *\n * @private\n */\n\n/**\n * @class TypingIndicator\n *\n * @constructor\n * @private\n */\n\nvar TypingIndicator = /*#__PURE__*/function () {\n  function TypingIndicator(getChannel, configuration, services) {\n    _classCallCheck__default['default'](this, TypingIndicator);\n\n    this.getChannel = getChannel;\n    this.configuration = configuration;\n    this.services = services;\n    this.serviceTypingTimeout = null;\n    this.sentUpdates = new Map();\n  }\n\n  _createClass__default['default'](TypingIndicator, [{\n    key: \"typingTimeout\",\n    get: function get() {\n      return this.configuration.typingIndicatorTimeoutOverride || this.serviceTypingTimeout || this.configuration.typingIndicatorTimeoutDefault;\n    }\n    /**\n     * Initialize TypingIndicator controller\n     * Registers for needed message types and sets listeners\n     * @private\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n\n      this.services.notificationClient.subscribe(NotificationTypes.TYPING_INDICATOR, 'twilsock');\n      this.services.notificationClient.on('message', function (type, message) {\n        if (type === NotificationTypes.TYPING_INDICATOR) {\n          _this.handleRemoteTyping(message);\n        }\n      });\n    }\n    /**\n     * Remote members typing events handler\n     * @private\n     */\n\n  }, {\n    key: \"handleRemoteTyping\",\n    value: function handleRemoteTyping(message) {\n      var _this2 = this;\n\n      log$1.trace('Got new typing indicator ', message);\n      this.getChannel(message.channel_sid).then(function (channel) {\n        if (!channel) {\n          return;\n        }\n\n        channel.members.forEach(function (member) {\n          if (member.identity !== message.identity) {\n            return;\n          }\n\n          var timeout = _this2.configuration.typingIndicatorTimeoutOverride + 1000 || message.typing_timeout * 1000;\n\n          member._startTyping(timeout);\n        });\n      }).catch(function (err) {\n        log$1.error(err);\n        throw err;\n      });\n    }\n    /**\n     * Send typing event for the given channel sid\n     * @param {String} channelSid\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(channelSid) {\n      var lastUpdate = this.sentUpdates.get(channelSid);\n\n      if (lastUpdate && lastUpdate > Date.now() - this.typingTimeout) {\n        return Promise.resolve();\n      }\n\n      this.sentUpdates.set(channelSid, Date.now());\n      return this._send(channelSid);\n    }\n  }, {\n    key: \"_send\",\n    value: function _send(channelSid) {\n      var _this3 = this;\n\n      log$1.trace('Sending typing indicator');\n      var url = this.configuration.links.typing;\n      var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n      var body = 'ChannelSid=' + channelSid;\n      return this.services.transport.post(url, headers, body, this.configuration.productId).then(function (response) {\n        if (response.body.hasOwnProperty('typing_timeout')) {\n          _this3.serviceTypingTimeout = response.body.typing_timeout * 1000;\n        }\n      }).catch(function (err) {\n        log$1.error('Failed to send typing indicator:', err);\n        throw err;\n      });\n    }\n  }]);\n\n  return TypingIndicator;\n}();\n/**\n * Users channels collection\n * It's a cassandra-backed pull-based collection\n */\n\n\nvar UserChannels = /*#__PURE__*/function () {\n  function UserChannels(client, services, url) {\n    _classCallCheck__default['default'](this, UserChannels);\n\n    this.client = client;\n    this.services = services;\n    this.url = url;\n  }\n\n  _createClass__default['default'](UserChannels, [{\n    key: \"getChannels\",\n    value: function () {\n      var _getChannels = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var _this = this;\n\n        var args,\n            url,\n            response,\n            _args = arguments;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                args = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                url = new UriBuilder(this.url).arg('PageToken', args.pageToken).build();\n                _context.next = 4;\n                return this.services.network.get(url);\n\n              case 4:\n                response = _context.sent;\n                return _context.abrupt(\"return\", new RestPaginator(response.body.conversations.map(function (x) {\n                  return new ChannelDescriptor(_this.client, x);\n                }), function (pageToken) {\n                  return _this.getChannels({\n                    pageToken: pageToken\n                  });\n                }, response.body.meta.previous_token, response.body.meta.next_token));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChannels() {\n        return _getChannels.apply(this, arguments);\n      }\n\n      return getChannels;\n    }()\n  }]);\n\n  return UserChannels;\n}();\n\nvar PushNotification =\n/**\n * Chat push notification type\n * @typedef {('twilio.channel.new_message' | 'twilio.channel.added_to_channel'\n | 'twilio.channel.invited_to_channel'  | 'twilio.channel.removed_from_channel')} PushNotification#NotificationType\n */\n\n/**\n * Additional Chat data for given Push Notification\n * @typedef {Object} PushNotification#ChatData\n * @property {String} [channelSid] - SID of Channel\n * @property {Number} [messageIndex] - Index of Message in Channel\n * @property {String} [messageSid] - SID of Message\n */\n\n/**\n * @param {PushNotification.Descriptor} data - initial data for PushNotification\n */\nfunction PushNotification(data) {\n  _classCallCheck__default['default'](this, PushNotification);\n\n  this.title = data.title || null;\n  this.body = data.body || null;\n  this.sound = data.sound || null;\n  this.badge = data.badge || null;\n  this.action = data.action || null;\n  this.type = data.type || null;\n  this.data = data.data || {};\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        _defineProperty__default['default'](target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar trimSlashes = function trimSlashes(url) {\n  return url.replace(/(^\\/+|\\/+$)/g, '');\n};\n\nvar isMutationConflictResponse = function isMutationConflictResponse(response) {\n  return response.status.code === 202;\n};\n\nvar CommandExecutor = /*#__PURE__*/function () {\n  function CommandExecutor(_serviceUrl, _services, _productId) {\n    _classCallCheck__default['default'](this, CommandExecutor);\n\n    this._serviceUrl = _serviceUrl;\n    this._services = _services;\n    this._productId = _productId;\n  }\n\n  _createClass__default['default'](CommandExecutor, [{\n    key: \"_preProcessUrl\",\n    value: function _preProcessUrl(url) {\n      var trimmedUrl = trimSlashes(url);\n\n      if (/^https?:\\/\\//.test(url)) {\n        return trimmedUrl;\n      }\n\n      return \"\".concat(trimSlashes(this._serviceUrl), \"/\").concat(trimmedUrl);\n    }\n  }, {\n    key: \"_makeRequest\",\n    value: function () {\n      var _makeRequest2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(method, url, requestBody, headers) {\n        var preProcessedUrl, finalHeaders, response, getUrl;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                preProcessedUrl = this._preProcessUrl(url);\n                finalHeaders = _objectSpread$1({\n                  'Content-Type': 'application/json; charset=utf-8'\n                }, headers || {});\n                _context.t0 = method;\n                _context.next = _context.t0 === 'get' ? 5 : _context.t0 === 'post' ? 11 : _context.t0 === 'delete' ? 15 : 19;\n                break;\n\n              case 5:\n                getUrl = preProcessedUrl;\n\n                if (requestBody) {\n                  getUrl += '?' + Object.entries(requestBody).map(function (entry) {\n                    return entry.map(encodeURIComponent).join('=');\n                  }).join('&');\n                }\n\n                _context.next = 9;\n                return this._services.transport.get(getUrl, finalHeaders, this._productId);\n\n              case 9:\n                response = _context.sent;\n                return _context.abrupt(\"break\", 19);\n\n              case 11:\n                _context.next = 13;\n                return this._services.transport.post(preProcessedUrl, finalHeaders, JSON.stringify(requestBody), this._productId);\n\n              case 13:\n                response = _context.sent;\n                return _context.abrupt(\"break\", 19);\n\n              case 15:\n                _context.next = 17;\n                return this._services.transport.delete(preProcessedUrl, finalHeaders, this._productId);\n\n              case 17:\n                response = _context.sent;\n                return _context.abrupt(\"break\", 19);\n\n              case 19:\n                if (!(response.status.code < 200 || response.status.code >= 300)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                throw new Error(\"Request responded with a non-success code \".concat(response.status.code));\n\n              case 21:\n                return _context.abrupt(\"return\", response);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _makeRequest(_x, _x2, _x3, _x4) {\n        return _makeRequest2.apply(this, arguments);\n      }\n\n      return _makeRequest;\n    }()\n  }, {\n    key: \"fetchResource\",\n    value: function () {\n      var _fetchResource = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(url, requestBody) {\n        var _this = this;\n\n        var maxAttemptsCount, result;\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                maxAttemptsCount = 6;\n                _context2.prev = 1;\n                _context2.next = 4;\n                return new operationRetrier.AsyncRetrier({\n                  min: 50,\n                  max: 1600,\n                  maxAttemptsCount: maxAttemptsCount\n                }).run(function () {\n                  return _this._makeRequest('get', url, requestBody);\n                });\n\n              case 4:\n                result = _context2.sent;\n                _context2.next = 10;\n                break;\n\n              case 7:\n                _context2.prev = 7;\n                _context2.t0 = _context2[\"catch\"](1);\n                throw new Error(\"Fetch resource from \\\"\".concat(url, \"\\\" failed.\"));\n\n              case 10:\n                return _context2.abrupt(\"return\", result.body);\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[1, 7]]);\n      }));\n\n      function fetchResource(_x5, _x6) {\n        return _fetchResource.apply(this, arguments);\n      }\n\n      return fetchResource;\n    }()\n  }, {\n    key: \"mutateResource\",\n    value: function () {\n      var _mutateResource = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(method, url, requestBody) {\n        var result;\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._makeRequest(method, url, requestBody, {\n                  'X-Twilio-Mutation-Id': uuid.v4()\n                });\n\n              case 2:\n                result = _context3.sent;\n\n                if (!isMutationConflictResponse(result)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                _context3.next = 6;\n                return this.fetchResource(result.body.resource_url);\n\n              case 6:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 7:\n                return _context3.abrupt(\"return\", result.body);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function mutateResource(_x7, _x8, _x9) {\n        return _mutateResource.apply(this, arguments);\n      }\n\n      return mutateResource;\n    }()\n  }]);\n\n  return CommandExecutor;\n}();\n\nvar version = \"5.0.2\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty__default['default'](target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf__default['default'](Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf__default['default'](this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn__default['default'](this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar log = Logger.scope('Client');\nvar SDK_VERSION = version;\n\nvar ClientServices = function ClientServices() {\n  _classCallCheck__default['default'](this, ClientServices);\n};\n/**\n * A Client is a starting point to access Twilio Programmable Chat functionality.\n *\n * @property {Client#ConnectionState} connectionState - Client connection state\n * @property {Boolean} reachabilityEnabled - Client reachability state\n * @property {User} user - Information for logged in user\n * @property {String} version - Current version of Chat client\n *\n * @fires Client#connectionError\n * @fires Client#connectionStateChanged\n * @fires Client#channelAdded\n * @fires Client#channelInvited\n * @fires Client#channelJoined\n * @fires Client#channelLeft\n * @fires Client#channelRemoved\n * @fires Client#channelUpdated\n * @fires Client#memberJoined\n * @fires Client#memberLeft\n * @fires Client#memberUpdated\n * @fires Client#messageAdded\n * @fires Client#messageRemoved\n * @fires Client#messageUpdated\n * @fires Client#pushNotification\n * @fires Client#tokenAboutToExpire\n * @fires Client#tokenExpired\n * @fires Client#typingEnded\n * @fires Client#typingStarted\n * @fires Client#userSubscribed\n * @fires Client#userUnsubscribed\n * @fires Client#userUpdated\n */\n\n\nvar Client = /*#__PURE__*/function (_EventEmitter) {\n  _inherits__default['default'](Client, _EventEmitter);\n\n  var _super = _createSuper(Client);\n\n  function Client(token) {\n    var _this$options$Sync;\n\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck__default['default'](this, Client);\n\n    _this = _super.call(this);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"connectionState\", 'connecting');\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"channelsPromise\", null);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"configurationPromise\", null);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"version\", SDK_VERSION);\n\n    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), \"parsePushNotification\", Client.parsePushNotification);\n\n    _this.options = options;\n\n    if (!_this.options.disableDeepClone) {\n      var _options = _objectSpread(_objectSpread({}, _this.options), {}, {\n        transport: undefined,\n        twilsockClient: undefined\n      });\n\n      _options = deepClone(_options);\n      _options.transport = _this.options.transport;\n      _options.twilsockClient = _this.options.twilsockClient;\n      _this.options = _options;\n    }\n\n    _this.options.logLevel = _this.options.logLevel || 'silent';\n    log.setLevel(_this.options.logLevel);\n    var productId = _this.options.productId = 'ip_messaging'; // Filling ClientMetadata\n\n    _this.options.clientMetadata = _this.options.clientMetadata || {};\n\n    if (!_this.options.clientMetadata.hasOwnProperty('type')) {\n      _this.options.clientMetadata.type = 'chat';\n    }\n\n    if (!_this.options.clientMetadata.hasOwnProperty('sdk')) {\n      _this.options.clientMetadata.sdk = 'JS';\n      _this.options.clientMetadata.sdkv = SDK_VERSION;\n    } // Enable session local storage for Sync\n\n\n    _this.options.Sync = _this.options.Sync || {};\n\n    if (!((_this$options$Sync = _this.options.Sync) !== null && _this$options$Sync !== void 0 && _this$options$Sync.enableSessionStorage)) {\n      _this.options.Sync.enableSessionStorage = true;\n    }\n\n    if (_this.options.region) {\n      _this.options.Sync.region = _this.options.region;\n    }\n\n    if (!token) {\n      throw new Error('A valid Twilio token should be provided');\n    }\n\n    _this.services = new ClientServices();\n    _this.options.twilsockClient = _this.options.twilsockClient || new twilsock.Twilsock(token, productId, _this.options);\n    _this.options.transport = _this.options.transport || _this.options.twilsockClient;\n    _this.options.notificationsClient = _this.options.notificationsClient || new twilioNotifications.Notifications(token, _this.options);\n    _this.options.syncClient = _this.options.syncClient || new twilioSync.SyncClient(token, _this.options);\n    _this.services.syncClient = _this.options.syncClient;\n    _this.services.transport = _this.options.transport;\n    _this.services.twilsockClient = _this.options.twilsockClient;\n    _this.services.notificationClient = _this.options.notificationsClient;\n    var configurationOptions = options.Chat || options.IPMessaging || options || {};\n    var region = configurationOptions.region || options.region;\n    var baseUrl = configurationOptions.apiUri || configurationOptions.typingUri || \"https://aim.\".concat(region || 'us1', \".twilio.com\");\n    _this.services.commandExecutor = new CommandExecutor(baseUrl, {\n      transport: _this.options.transport\n    }, productId);\n    _this.configurationPromise = _this.services.commandExecutor.fetchResource('Client/v1/Configuration');\n\n    _this.configurationPromise.then(function (configurationResponse) {\n      _this.configuration = new Configuration(_this.options, configurationResponse, log);\n      _this.services.typingIndicator = new TypingIndicator(_this.getChannelBySid.bind(_assertThisInitialized__default['default'](_this)), _this.configuration, _this.services);\n      _this.services.network = new Network(_this.configuration, _this.services);\n      _this.services.users = new Users(_this.configuration, _this.services);\n\n      _this.services.users.on('userSubscribed', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'userSubscribed'));\n\n      _this.services.users.on('userUpdated', function (args) {\n        return _this.emit('userUpdated', args);\n      });\n\n      _this.services.users.on('userUnsubscribed', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'userUnsubscribed'));\n\n      _this.services.twilsockClient.on('tokenAboutToExpire', function (ttl) {\n        return _this.emit('tokenAboutToExpire', ttl);\n      });\n\n      _this.services.twilsockClient.on('tokenExpired', function () {\n        return _this.emit('tokenExpired');\n      });\n\n      _this.services.twilsockClient.on('connectionError', function (error) {\n        return _this.emit('connectionError', error);\n      });\n\n      _this.channels = new Channels(_this.configuration, _this.services);\n\n      _this.channels.on('channelAdded', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'channelAdded'));\n\n      _this.channels.on('channelInvited', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'channelInvited'));\n\n      _this.channels.on('channelRemoved', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'channelRemoved'));\n\n      _this.channels.on('channelJoined', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'channelJoined'));\n\n      _this.channels.on('channelLeft', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'channelLeft'));\n\n      _this.channels.on('channelUpdated', function (args) {\n        return _this.emit('channelUpdated', args);\n      });\n\n      _this.channels.on('memberJoined', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'memberJoined'));\n\n      _this.channels.on('memberLeft', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'memberLeft'));\n\n      _this.channels.on('memberUpdated', function (args) {\n        return _this.emit('memberUpdated', args);\n      });\n\n      _this.channels.on('messageAdded', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'messageAdded'));\n\n      _this.channels.on('messageUpdated', function (args) {\n        return _this.emit('messageUpdated', args);\n      });\n\n      _this.channels.on('messageRemoved', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'messageRemoved'));\n\n      _this.channels.on('typingStarted', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'typingStarted'));\n\n      _this.channels.on('typingEnded', _this.emit.bind(_assertThisInitialized__default['default'](_this), 'typingEnded'));\n\n      return _this.services.users.myself._ensureFetched();\n    });\n\n    _this.channelsPromise = _this.configurationPromise.then(function () {\n      return _this.channels.fetchChannels();\n    }).then(function () {\n      return _this.channels;\n    });\n\n    _this.services.notificationClient.on('connectionStateChanged', function (state) {\n      var changedConnectionState = null;\n\n      switch (state) {\n        case 'connected':\n          changedConnectionState = 'connected';\n          break;\n\n        case 'denied':\n          changedConnectionState = 'denied';\n          break;\n\n        case 'disconnecting':\n          changedConnectionState = 'disconnecting';\n          break;\n\n        case 'disconnected':\n          changedConnectionState = 'disconnected';\n          break;\n\n        default:\n          changedConnectionState = 'connecting';\n      }\n\n      if (changedConnectionState !== _this.connectionState) {\n        _this.connectionState = changedConnectionState;\n\n        _this.emit('connectionStateChanged', _this.connectionState);\n      }\n    });\n\n    _this.fpaToken = token;\n    return _this;\n  }\n  /**\n   * These options can be passed to {@link Client#getLocalChannels}.\n   * @typedef {Object} Client#ChannelSortingOptions\n   * @property {('lastMessage'|'friendlyName'|'uniqueName')} [criteria] - Sorting criteria for Channels array\n   * @property {('ascending'|'descending')} [order] - Sorting order. If not present, then default is <code>ascending</code>\n   */\n\n  /**\n   * These options can be passed to Client constructor.\n   * @typedef {Object} Client#ClientOptions\n   * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n   *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n   */\n\n  /**\n   * These options can be passed to {@link Client#createChannel}.\n   * @typedef {Object} Client#CreateChannelOptions\n   * @property {any} [attributes] - Any custom attributes to attach to the Channel\n   * @property {String} [friendlyName] - The non-unique display name of the Channel\n   * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients\n   * @property {String} [uniqueName] - The unique identity name of the Channel\n   */\n\n  /**\n   * Connection state of Client.\n   * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState\n   */\n\n  /**\n   * Notifications channel type.\n   * @typedef {('gcm'|'fcm'|'apn')} Client#NotificationsChannelType\n   */\n\n  /**\n   * Factory method to create Chat client instance.\n   *\n   * @param {String} token - Access token\n   * @param {Client#ClientOptions} [options] - Options to customize the Client\n   * @returns {Promise<Client>}\n   */\n\n\n  _createClass__default['default'](Client, [{\n    key: \"user\",\n    get: function get() {\n      return this.services.users.myself;\n    }\n  }, {\n    key: \"reachabilityEnabled\",\n    get: function get() {\n      return this.configuration.reachabilityEnabled;\n    }\n  }, {\n    key: \"token\",\n    get: function get() {\n      return this.fpaToken;\n    }\n  }, {\n    key: \"subscribeToPushNotifications\",\n    value: function subscribeToPushNotifications(channelType) {\n      var _this2 = this;\n\n      var subscriptions = [];\n      [NotificationTypes.NEW_MESSAGE, NotificationTypes.ADDED_TO_CHANNEL, NotificationTypes.INVITED_TO_CHANNEL, NotificationTypes.REMOVED_FROM_CHANNEL, NotificationTypes.TYPING_INDICATOR, NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {\n        subscriptions.push(_this2.services.notificationClient.subscribe(messageType, channelType));\n      });\n      return Promise.all(subscriptions);\n    }\n  }, {\n    key: \"unsubscribeFromPushNotifications\",\n    value: function unsubscribeFromPushNotifications(channelType) {\n      var _this3 = this;\n\n      var subscriptions = [];\n      [NotificationTypes.NEW_MESSAGE, NotificationTypes.ADDED_TO_CHANNEL, NotificationTypes.INVITED_TO_CHANNEL, NotificationTypes.REMOVED_FROM_CHANNEL, NotificationTypes.TYPING_INDICATOR, NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {\n        subscriptions.push(_this3.services.notificationClient.unsubscribe(messageType, channelType));\n      });\n      return Promise.all(subscriptions);\n    }\n  }, {\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {\n        var _this4 = this;\n\n        var options;\n        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.configurationPromise;\n\n              case 2:\n                Client.supportedPushChannels.forEach(function (channelType) {\n                  return _this4.subscribeToPushNotifications(channelType);\n                });\n                this.services.publicChannels = new PublicChannels(this, this.services, this.configuration.links.conversations);\n                this.services.userChannels = new UserChannels(this, this.services, this.configuration.links.myConversations);\n                options = Object.assign(this.options);\n                options.transport = null;\n                this.services.mcsClient = new twilioMcsClient.McsClient(this.fpaToken, this.configuration.links.mediaService, options);\n                _context.next = 10;\n                return this.services.typingIndicator.initialize();\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n\n      return initialize;\n    }()\n    /**\n     * Gracefully shutting down library instance.\n     * @public\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"shutdown\",\n    value: function () {\n      var _shutdown = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.services.twilsockClient.disconnect();\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function shutdown() {\n        return _shutdown.apply(this, arguments);\n      }\n\n      return shutdown;\n    }()\n    /**\n     * Update the token used by the Client and re-register with Programmable Chat services.\n     * @param {String} token - Access token\n     * @public\n     * @returns {Promise<Client>}\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function () {\n      var _updateToken = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(token) {\n        var _this5 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                log.info('updateToken');\n\n                if (!(this.fpaToken === token)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this);\n\n              case 3:\n                _context3.next = 5;\n                return this.services.twilsockClient.updateToken(token).then(function () {\n                  return _this5.fpaToken = token;\n                }).then(function () {\n                  return _this5.services.mcsClient.updateToken(token);\n                }).then(function () {\n                  return _this5.configurationPromise;\n                });\n\n              case 5:\n                return _context3.abrupt(\"return\", this);\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateToken(_x) {\n        return _updateToken.apply(this, arguments);\n      }\n\n      return updateToken;\n    }()\n    /**\n     * Get a known Channel by its SID.\n     * @param {String} channelSid - Channel sid\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"getChannelBySid\",\n    value: function () {\n      var _getChannelBySid = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(channelSid) {\n        var _this6 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.channels.myChannelsRead.promise.then(function () {\n                  return _this6.channels.getChannel(channelSid).then(function (channel) {\n                    return channel || _this6.services.publicChannels.getChannelBySid(channelSid).then(function (x) {\n                      return _this6.channels.pushChannel(x);\n                    });\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getChannelBySid(_x2) {\n        return _getChannelBySid.apply(this, arguments);\n      }\n\n      return getChannelBySid;\n    }()\n    /**\n     * Get a known Channel by its unique identifier name.\n     * @param {String} uniqueName - The unique identifier name of the Channel to get\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"getChannelByUniqueName\",\n    value: function () {\n      var _getChannelByUniqueName = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(uniqueName) {\n        var _this7 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.channels.myChannelsRead.promise.then(function () {\n                  return _this7.services.publicChannels.getChannelByUniqueName(uniqueName).then(function (x) {\n                    return _this7.channels.pushChannel(x);\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getChannelByUniqueName(_x3) {\n        return _getChannelByUniqueName.apply(this, arguments);\n      }\n\n      return getChannelByUniqueName;\n    }()\n    /**\n     * Get the current list of all subscribed Channels.\n     * @returns {Promise<Paginator<Channel>>}\n     */\n\n  }, {\n    key: \"getSubscribedChannels\",\n    value: function getSubscribedChannels(args) {\n      return this.channelsPromise.then(function (channels) {\n        return channels.getChannels(args);\n      });\n    }\n    /**\n     * Get array of Channels locally known to Client in provided sorting order.\n     * Locally known channels are the ones created and/or joined during client runtime and currently logged in User subscribed Channels.\n     * To ensure full list of subscribed Channels fetched - call the {@link Client#getSubscribedChannels} method\n     * and fetch all pages with help of {@link Paginator#nextPage} method.\n     * @param {Client#ChannelSortingOptions} [sortingOptions] - Options for the Channel sorting\n     * @returns {Promise<Array<Channel>>}\n     */\n\n  }, {\n    key: \"getLocalChannels\",\n    value: function getLocalChannels(sortingOptions) {\n      return this.channelsPromise.then(function (channels) {\n        var result = [];\n        channels.channels.forEach(function (value) {\n          result.push(value);\n        });\n        var sortingOrder = (sortingOptions === null || sortingOptions === void 0 ? void 0 : sortingOptions.order) || 'ascending';\n\n        if (sortingOptions && sortingOptions.criteria) {\n          if (sortingOptions.criteria === 'lastMessage') {\n            result.sort(function (a, b) {\n              return Client.compareChannelsByLastMessage(a, b, sortingOrder);\n            });\n          } else if (sortingOptions.criteria === 'uniqueName') {\n            result.sort(function (a, b) {\n              return Client.compareChannelsByStringProperty(a.uniqueName, b.uniqueName, sortingOrder);\n            });\n          } else if (sortingOptions.criteria === 'friendlyName') {\n            result.sort(function (a, b) {\n              return Client.compareChannelsByStringProperty(a.friendlyName, b.friendlyName, sortingOrder);\n            });\n          }\n        }\n\n        return result;\n      });\n    }\n  }, {\n    key: \"getPublicChannelDescriptors\",\n    value:\n    /**\n     * Get the public channels directory content.\n     * @returns {Promise<Paginator<ChannelDescriptor>>}\n     */\n    function getPublicChannelDescriptors() {\n      return this.services.publicChannels.getChannels();\n    }\n    /**\n     * Get the User's (created by, joined or invited to) channels directory content.\n     * @returns {Promise<Paginator<ChannelDescriptor>>}\n     */\n\n  }, {\n    key: \"getUserChannelDescriptors\",\n    value: function getUserChannelDescriptors() {\n      return this.services.userChannels.getChannels();\n    }\n    /**\n     * Create a Channel on the server and subscribe to its events.\n     * Default options are public Channel type with empty uniqueName and friendlyName.\n     * @param {Client#CreateChannelOptions} [options] - Options for the Channel\n     * @returns {Promise<Channel>}\n     */\n\n  }, {\n    key: \"createChannel\",\n    value: function createChannel(options) {\n      options = options || {};\n      return this.channelsPromise.then(function (channelsEntity) {\n        return channelsEntity.addChannel(options);\n      });\n    }\n    /**\n     * Registers for push notifications.\n     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported\n     * @param {string} registrationId - Push notification id provided by platform\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"setPushRegistrationId\",\n    value: function () {\n      var _setPushRegistrationId = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(channelType, registrationId) {\n        var _this8 = this;\n\n        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.subscribeToPushNotifications(channelType).then(function () {\n                  return _this8.services.notificationClient.setPushRegistrationId(registrationId, channelType);\n                });\n\n              case 2:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function setPushRegistrationId(_x4, _x5) {\n        return _setPushRegistrationId.apply(this, arguments);\n      }\n\n      return setPushRegistrationId;\n    }()\n    /**\n     * Unregisters from push notifications.\n     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"unsetPushRegistrationId\",\n    value: function () {\n      var _unsetPushRegistrationId = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(channelType) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(Client.supportedPushChannels.indexOf(channelType) === -1)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('Invalid or unsupported channelType: ' + channelType);\n\n              case 2:\n                _context7.next = 4;\n                return this.unsubscribeFromPushNotifications(channelType);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function unsetPushRegistrationId(_x6) {\n        return _unsetPushRegistrationId.apply(this, arguments);\n      }\n\n      return unsetPushRegistrationId;\n    }()\n  }, {\n    key: \"handlePushNotification\",\n    value:\n    /**\n     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.\n     * @param {Object} notificationPayload - Push notification payload\n     * @returns {Promise<void>}\n     */\n    function () {\n      var _handlePushNotification = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8(notificationPayload) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                log.debug('handlePushNotification, notificationPayload=', notificationPayload);\n                this.emit('pushNotification', Client.parsePushNotification(notificationPayload));\n\n              case 2:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function handlePushNotification(_x7) {\n        return _handlePushNotification.apply(this, arguments);\n      }\n\n      return handlePushNotification;\n    }()\n    /**\n     * Gets user for given identity, if it's in subscribed list - then return the user object from it,\n     * if not - then subscribes and adds user to the subscribed list.\n     * @param {String} identity - Identity of User\n     * @returns {Promise<User>} Fully initialized user\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(identity) {\n      return this.services.users.getUser(identity);\n    }\n    /**\n     * Gets user descriptor for given identity.\n     * @param {String} identity - Identity of User\n     * @returns {Promise<UserDescriptor>} User descriptor\n     */\n\n  }, {\n    key: \"getUserDescriptor\",\n    value: function () {\n      var _getUserDescriptor = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee9(identity) {\n        return _regeneratorRuntime__default['default'].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", this.services.users.getUserDescriptor(identity));\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getUserDescriptor(_x8) {\n        return _getUserDescriptor.apply(this, arguments);\n      }\n\n      return getUserDescriptor;\n    }()\n    /**\n     * @returns {Promise<Array<User>>} List of subscribed User objects\n     */\n\n  }, {\n    key: \"getSubscribedUsers\",\n    value: function () {\n      var _getSubscribedUsers = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee10() {\n        return _regeneratorRuntime__default['default'].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this.services.users.getSubscribedUsers());\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getSubscribedUsers() {\n        return _getSubscribedUsers.apply(this, arguments);\n      }\n\n      return getSubscribedUsers;\n    }()\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee11(token, options) {\n        var client;\n        return _regeneratorRuntime__default['default'].wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                client = new Client(token, options);\n                _context11.next = 3;\n                return client.initialize();\n\n              case 3:\n                return _context11.abrupt(\"return\", client);\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n\n      function create(_x9, _x10) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"compareChannelsByLastMessage\",\n    value: function compareChannelsByLastMessage(a, b, order) {\n      if (a.lastMessage && b.lastMessage) {\n        if (a.lastMessage.dateCreated && b.lastMessage.dateCreated) {\n          if (a.lastMessage.dateCreated.getTime() < b.lastMessage.dateCreated.getTime()) {\n            return order === 'ascending' ? -1 : 1;\n          } else {\n            return order === 'ascending' ? 1 : -1;\n          }\n        } else {\n          if (a.lastMessage.dateCreated) {\n            return -1;\n          } else if (b.lastMessage.dateCreated) {\n            return 1;\n          }\n        }\n      }\n\n      if (a.lastMessage) {\n        return -1;\n      } else if (b.lastMessage) {\n        return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"compareChannelsByStringProperty\",\n    value: function compareChannelsByStringProperty(str1, str2, order) {\n      if (str1 && str2) {\n        return order === 'ascending' ? str1.localeCompare(str2) : -1 * str1.localeCompare(str2);\n      } else if (str1) {\n        return -1;\n      } else if (str2) {\n        return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"parsePushNotificationChatData\",\n    value: function parsePushNotificationChatData(data) {\n      var result = {};\n\n      for (var key in Client.supportedPushDataFields) {\n        if (typeof data[key] !== 'undefined' && data[key] !== null) {\n          if (key === 'message_index') {\n            if (parseToNumber(data[key]) !== null) {\n              result[Client.supportedPushDataFields[key]] = Number(data[key]);\n            }\n          } else {\n            result[Client.supportedPushDataFields[key]] = data[key];\n          }\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object\n     * @param {Object} notificationPayload - Push notification payload\n     * @returns {PushNotification|Error}\n     */\n\n  }, {\n    key: \"parsePushNotification\",\n    value: function parsePushNotification(notificationPayload) {\n      log.debug('parsePushNotification, notificationPayload=', notificationPayload); // APNS specifics\n\n      if (typeof notificationPayload.aps !== 'undefined') {\n        if (!notificationPayload.twi_message_type) {\n          throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n        }\n\n        var data = Client.parsePushNotificationChatData(notificationPayload);\n        var apsPayload = notificationPayload.aps;\n        var body = null;\n        var title = null;\n\n        if (typeof apsPayload.alert === 'string') {\n          body = apsPayload.alert || null;\n        } else {\n          body = apsPayload.alert.body || null;\n          title = apsPayload.alert.title || null;\n        }\n\n        return new PushNotification({\n          title: title,\n          body: body,\n          sound: apsPayload.sound || null,\n          badge: apsPayload.badge || null,\n          action: apsPayload.category || null,\n          type: notificationPayload.twi_message_type,\n          data: data\n        });\n      } // FCM/GCM specifics\n\n\n      if (typeof notificationPayload.data !== 'undefined') {\n        var dataPayload = notificationPayload.data;\n\n        if (!dataPayload.twi_message_type) {\n          throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n        }\n\n        var _data = Client.parsePushNotificationChatData(notificationPayload.data);\n\n        return new PushNotification({\n          title: dataPayload.twi_title || null,\n          body: dataPayload.twi_body || null,\n          sound: dataPayload.twi_sound || null,\n          badge: null,\n          action: dataPayload.twi_action || null,\n          type: dataPayload.twi_message_type,\n          data: _data\n        });\n      }\n\n      throw new Error('Provided push notification payload is not Programmable Chat notification');\n    }\n  }]);\n\n  return Client;\n}(EventEmitter);\n\n_defineProperty__default['default'](Client, \"version\", SDK_VERSION);\n\n_defineProperty__default['default'](Client, \"supportedPushChannels\", ['fcm', 'apn', 'gcm']);\n\n_defineProperty__default['default'](Client, \"supportedPushDataFields\", {\n  'channel_sid': 'channelSid',\n  'message_sid': 'messageSid',\n  'message_index': 'messageIndex'\n});\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"updateToken\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"getChannelBySid\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"getChannelByUniqueName\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['undefined', twilioSdkTypeValidator.objectSchema('sorting options', {\n  criteria: [twilioSdkTypeValidator.literal('lastMessage', 'friendlyName', 'uniqueName'), 'undefined'],\n  order: [twilioSdkTypeValidator.literal('ascending', 'descending'), 'undefined']\n})]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"getLocalChannels\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(['undefined', twilioSdkTypeValidator.objectSchema('channel options', {\n  friendlyName: ['string', 'undefined'],\n  isPrivate: ['boolean', 'undefined'],\n  uniqueName: ['string', 'undefined']\n})]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"createChannel\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.literal('gcm', 'fcm', 'apn'), 'string'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"setPushRegistrationId\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.literal('gcm', 'fcm', 'apn')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"unsetPushRegistrationId\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.pureObject), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"handlePushNotification\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"getUser\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync(twilioSdkTypeValidator.nonEmptyString), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String]), __metadata(\"design:returntype\", Promise)], Client.prototype, \"getUserDescriptor\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypesAsync('string', ['undefined', twilioSdkTypeValidator.pureObject]), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [String, Object]), __metadata(\"design:returntype\", Promise)], Client, \"create\", null);\n\n__decorate([twilioSdkTypeValidator.validateTypes(twilioSdkTypeValidator.pureObject), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", PushNotification)], Client, \"parsePushNotification\", null);\n/**\n * Fired when a Channel becomes visible to the Client.\n * Fired for created and not joined private channels and for all type of channels Client has joined or invited to.\n * @event Client#channelAdded\n * @type {Channel}\n */\n\n/**\n * Fired when the Client is invited to a Channel.\n * @event Client#channelInvited\n * @type {Channel}\n */\n\n/**\n * Fired when the Client joins a Channel.\n * @event Client#channelJoined\n * @type {Channel}\n */\n\n/**\n * Fired when the Client leaves a Channel.\n * @event Client#channelLeft\n * @type {Channel}\n */\n\n/**\n * Fired when a Channel is no longer visible to the Client.\n * @event Client#channelRemoved\n * @type {Channel}\n */\n\n/**\n * Fired when a Channel's attributes or metadata have been updated.\n * During Channel's {@link Client.create| creation and initialization} this event might be fired multiple times\n * for same joined or created Channel as new data is arriving from different sources.\n * @event Client#channelUpdated\n * @type {Object}\n * @property {Channel} channel - Updated Channel\n * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons\n */\n\n/**\n * Fired when Client's connection state has been changed.\n * @event Client#connectionStateChanged\n * @type {Client#ConnectionState}\n */\n\n/**\n * Fired when a Member has joined the Channel.\n * @event Client#memberJoined\n * @type {Member}\n */\n\n/**\n * Fired when a Member has left the Channel.\n * @event Client#memberLeft\n * @type {Member}\n */\n\n/**\n * Fired when a Member's fields has been updated.\n * @event Client#memberUpdated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n\n/**\n * Fired when a new Message has been added to the Channel on the server.\n * @event Client#messageAdded\n * @type {Message}\n */\n\n/**\n * Fired when Message is removed from Channel's message list.\n * @event Client#messageRemoved\n * @type {Message}\n */\n\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Client#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n\n/**\n * Fired when token is about to expire and needs to be updated.\n * @event Client#tokenAboutToExpire\n * @type {void}\n */\n\n/**\n * Fired when token is expired.\n * @event Client#tokenExpired\n * @type {void}\n */\n\n/**\n * Fired when a Member has stopped typing.\n * @event Client#typingEnded\n * @type {Member}\n */\n\n/**\n * Fired when a Member has started typing.\n * @event Client#typingStarted\n * @type {Member}\n */\n\n/**\n * Fired when client received (and parsed) push notification via one of push channels (apn, gcm, fcm).\n * @event Client#pushNotification\n * @type {PushNotification}\n */\n\n/**\n * Fired when the Client is subscribed to a User.\n * @event Client#userSubscribed\n * @type {User}\n */\n\n/**\n * Fired when the Client is unsubscribed from a User.\n * @event Client#userUnsubscribed\n * @type {User}\n */\n\n/**\n * Fired when the User's properties or reachability status have been updated.\n * @event Client#userUpdated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @event Client#connectionError\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n */\n\n\nexports.Client = Client;\nexports.PushNotification = PushNotification;\nexports.User = User;\nexports.default = Client;","map":{"version":3,"sources":["../node_modules/tslib/tslib.es6.js","../src/logger.ts","../src/configuration.ts","../src/util/index.ts","../src/restpaginator.ts","../src/channeldescriptor.ts","../src/data/publicchannels.ts","../src/services/network.ts","../src/interfaces/notificationtypes.ts","../src/member.ts","../src/data/members.ts","../src/media.ts","../src/message.ts","../src/data/messages.ts","../src/channel.ts","../src/util/deferred.ts","../src/data/channels.ts","../src/user.ts","../src/userdescriptor.ts","../src/data/userdescriptors.ts","../src/data/users.ts","../src/services/typingindicator.ts","../src/data/userchannels.ts","../src/pushnotification.ts","../src/commandexecutor.ts","../src/client.ts"],"names":["c","arguments","r","desc","Object","Reflect","i","decorators","d","log","loglevelLog","toSeconds","parseDuration","JsonDiff","parseTime","Retrier","validateTypesAsync","literal","nonEmptyString","nonNegativeInteger","custom","objectSchema","AsyncRetrier","uuidv4","TwilsockClient","NotificationClient","SyncClient","pureObject","McsClient","validateTypes"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import * as loglevelLog from 'loglevel';\n\nfunction prepareLine(prefix, args) {\n  return [`${new Date().toISOString()} Chat ${prefix}:`].concat(Array.from(args));\n}\n\nconst log: loglevelLog.Logger = loglevelLog.getLogger('twilio-chat'); // twilio-chat is used by Flex SDK. Please DO NOT change\n\nclass Logger {\n  private prefix: string = '';\n\n  private constructor(prefix: string) {\n    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0\n      ? prefix + ' '\n      : '';\n  }\n\n  static scope(prefix: string): Logger {\n    return new Logger(prefix);\n  }\n\n  setLevel(level: any) {\n    log.setLevel(level);\n  }\n\n  static setLevel(level: any) {\n    log.setLevel(level);\n  }\n\n  trace(...args) { log.trace.apply(null, prepareLine(this.prefix + 'T', args)); }\n\n  debug(...args) { log.debug.apply(null, prepareLine(this.prefix + 'D', args)); }\n\n  info(...args) { log.info.apply(null, prepareLine(this.prefix + 'I', args)); }\n\n  warn(...args) { log.warn.apply(null, prepareLine(this.prefix + 'W', args)); }\n\n  error(...args) { log.error.apply(null, prepareLine(this.prefix + 'E', args)); }\n\n  static trace(...args) { log.trace.apply(null, prepareLine('T', args)); }\n\n  static debug(...args) { log.debug.apply(null, prepareLine('D', args)); }\n\n  static info(...args) { log.info.apply(null, prepareLine('I', args)); }\n\n  static warn(...args) { log.warn.apply(null, prepareLine('W', args)); }\n\n  static error(...args) { log.error.apply(null, prepareLine('E', args)); }\n\n}\n\nexport { Logger };\n","import { CommandExecutor } from './commandexecutor';\nimport { ConfigurationResponse } from './interfaces/commands/configuration';\nimport { parse as parseDuration, toSeconds } from 'iso8601-duration';\nimport { Logger } from './logger';\n\nconst TYPING_TIMEOUT = 5;\nconst HTTP_CACHE_LIFETIME = 'PT5S';\nconst CONSUMPTION_HORIZON_SENDING_INTERVAL = 'PT5S';\nconst USER_INFOS_TO_SUBSCRIBE = 100;\n\nconst MINIMUM_RETRY_DELAY = 1000;\nconst MAXIMUM_RETRY_DELAY = 4000;\nconst MAXIMUM_ATTEMPTS_COUNT = 3;\nconst RETRY_WHEN_THROTTLED = true;\n\ninterface BackoffConfiguration {\n  min: number;\n  max: number;\n  maxAttemptsCount: number;\n}\n\ninterface ConfigurationServices {\n  commandExecutor: CommandExecutor;\n}\n\nclass Configuration {\n  public readonly links: {\n    myConversations: string;\n    conversations: string;\n    users: string;\n    currentUser: string;\n    typing: string;\n    mediaService: string;\n    messagesReceipts: string;\n  };\n\n  public readonly productId?: string;\n\n  public readonly typingIndicatorTimeoutOverride?: number;\n  public readonly typingIndicatorTimeoutDefault: number = TYPING_TIMEOUT * 1000;\n  public readonly backoffConfiguration: BackoffConfiguration;\n  public readonly retryWhenThrottled: boolean;\n\n  public readonly consumptionReportInterval: number;\n  public readonly userInfosToSubscribe: number;\n  public readonly httpCacheInterval: number;\n  public readonly reachabilityEnabled: boolean;\n\n  public readonly userIdentity: string;\n  public readonly userInfo: string;\n  public readonly myConversations: string;\n\n  constructor(\n    options: Record<string, any> = {},\n    configurationResponse: ConfigurationResponse,\n    logger: Logger\n  ) {\n    const constructorOptions = options.Chat || options.IPMessaging || options || {};\n\n    this.productId = constructorOptions.productId;\n\n    this.links = {\n      myConversations: configurationResponse.links.my_conversations,\n      conversations: configurationResponse.links.conversations,\n      users: configurationResponse.links.users,\n      currentUser: configurationResponse.links.current_user,\n      typing: configurationResponse.links.typing,\n      mediaService: configurationResponse.links.media_service,\n      messagesReceipts: configurationResponse.links.messages_receipts\n    };\n\n    this.typingIndicatorTimeoutOverride = constructorOptions.typingIndicatorTimeoutOverride;\n    this.backoffConfiguration = {\n      min: MINIMUM_RETRY_DELAY,\n      max: MAXIMUM_RETRY_DELAY,\n      maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT,\n      ...constructorOptions.backoffConfigOverride\n    };\n    this.retryWhenThrottled = constructorOptions.retryWhenThrottledOverride !== undefined\n      ? constructorOptions.retryWhenThrottledOverride\n      : RETRY_WHEN_THROTTLED;\n    this.userInfosToSubscribe = constructorOptions.userInfosToSubscribeOverride\n      || configurationResponse.options.user_infos_to_subscribe\n      || USER_INFOS_TO_SUBSCRIBE;\n    this.reachabilityEnabled = configurationResponse.options.reachability_enabled;\n    this.userIdentity = configurationResponse.identity;\n    this.userInfo = configurationResponse.sync_objects.my_user_info;\n    this.myConversations = configurationResponse.sync_objects.my_conversations;\n\n    const httpCacheInterval = constructorOptions.httpCacheIntervalOverride\n      || configurationResponse.options.http_cache_interval\n      || HTTP_CACHE_LIFETIME;\n\n    try {\n      this.httpCacheInterval = toSeconds(parseDuration(httpCacheInterval));\n    } catch {\n      logger.error(`Failed to parse http cache interval ${httpCacheInterval}, using default value ${HTTP_CACHE_LIFETIME}`);\n      this.httpCacheInterval = toSeconds(parseDuration(HTTP_CACHE_LIFETIME));\n    }\n\n    const consumptionReportInterval = constructorOptions.consumptionReportIntervalOverride\n      || configurationResponse.options.consumption_report_interval\n      || CONSUMPTION_HORIZON_SENDING_INTERVAL;\n\n    try {\n      this.consumptionReportInterval = toSeconds(parseDuration(consumptionReportInterval));\n    } catch {\n      logger.error(\n        `Failed to parse consumption report interval ${consumptionReportInterval}, using default value ${CONSUMPTION_HORIZON_SENDING_INTERVAL}`\n      );\n      this.consumptionReportInterval = toSeconds(parseDuration(CONSUMPTION_HORIZON_SENDING_INTERVAL));\n    }\n  }\n}\n\nexport { Configuration };","import * as JsonDiff from 'rfc6902';\nimport { Logger } from '../logger';\n\n/**\n * Checks if objects are equal\n */\nfunction isDeepEqual(o1: Object, o2: Object): boolean {\n  return JsonDiff.createPatch(o1, o2).length === 0;\n}\n\n/**\n * Deep-clone an object. Note that this does not work on object containing\n * functions.\n * @param {object} obj - the object to deep-clone\n * @returns {object}\n */\nfunction deepClone<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj)) as T;\n}\n\nfunction parseToNumber(value) {\n  if (typeof value !== 'undefined' && !isNaN(Number(value))) {\n    return Number(value);\n  }\n  return null;\n}\n\n// timeString cannot be typed `string` because in member.ts\n// call to parseTime(data.lastConsumptionTimestamp) uses number not a string for timestamp.\nfunction parseTime(timeString): Date {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction parseAttributes(rawAttributes, warningMessage: string, log: Logger): Object {\n  let attributes = {};\n  if (rawAttributes) {\n    try {\n      attributes = JSON.parse(rawAttributes);\n    } catch (e) {\n      log.warn(warningMessage, e);\n    }\n  }\n\n  return attributes;\n}\n\n/**\n * Construct URI with query parameters\n */\nclass UriBuilder {\n  private base: string;\n  private args: string[];\n  private paths: string[];\n\n  constructor(base: string) {\n    this.base = base.replace(/\\/$/, '');\n    this.args = [];\n    this.paths = [];\n  }\n\n  public arg(name: string, value: any): UriBuilder {\n    if (typeof value !== 'undefined') {\n      this.args.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));\n    }\n    return this;\n  }\n\n  public path(name: string): UriBuilder {\n    this.paths.push(encodeURIComponent(name));\n    return this;\n  }\n\n  public build(): string {\n    let result = this.base;\n    if (this.paths.length) {\n      result += '/' + this.paths.join('/');\n    }\n\n    if (this.args.length) {\n      result += '?' + this.args.join('&');\n    }\n    return result;\n  }\n}\n\nexport { isDeepEqual, deepClone, UriBuilder, parseToNumber, parseTime, parseAttributes };\n","'use strict';\nimport { Paginator } from './interfaces/paginator';\n\ninterface PaginatorState {\n  source: any;\n  nextToken: any;\n  prevToken: any;\n  items: any;\n}\n\n/**\n * @class Paginator\n * @classdesc Pagination helper class\n *\n * @property {Array} items Array of elements on current page\n * @property {boolean} hasNextPage Indicates the existence of next page\n * @property {boolean} hasPrevPage Indicates the existence of previous page\n */\nclass RestPaginator<T> implements Paginator<T> {\n  private state: PaginatorState;\n\n  public get hasNextPage(): boolean { return !!this.state.nextToken; }\n\n  public get hasPrevPage(): boolean { return !!this.state.prevToken; }\n\n  public get items(): Array<T> { return this.state.items; }\n\n  /*\n  * @constructor\n  * @param {Array} items Array of element for current page\n  * @param {Object} params\n  * @private\n  */\n  constructor(items, source, prevToken, nextToken) {\n\n    this.state = {\n      prevToken,\n      nextToken,\n      source,\n      items\n    };\n  }\n\n  nextPage(): Promise<RestPaginator<T>> {\n    return this.hasNextPage ? this.state.source(this.state.nextToken) : Promise.reject(new Error('No next page'));\n  }\n\n  prevPage(): Promise<RestPaginator<T>> {\n    return this.hasPrevPage ? this.state.source(this.state.prevToken) : Promise.reject(new Error('No previous page'));\n  }\n}\n\nexport { RestPaginator };\n","import { Logger } from './logger';\nimport { Channel } from './channel';\nimport { Client } from './client';\nimport { parseAttributes, parseTime } from './util';\n\nconst log = Logger.scope('ChannelDescriptor');\n\n/**\n * Contains channel information.\n * Unlike {@link Channel}, this information won't be updated in realtime.\n * To have a fresh data, user should query channel descriptors again.\n *\n * @property {any} attributes - The Channel's custom attributes\n * @property {String} createdBy - The identity of the User that created Channel\n * @property {Date} dateCreated - The Date Channel was created\n * @property {Date} dateUpdated - The Date Channel was last updated\n * @property {String} friendlyName - The Channel's name\n * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)\n * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in Channel\n * @property {Number} membersCount Number of members in a channel\n * @property {Number} messagesCount Number of messages in a channel\n * @property {String} sid - The Channel's unique system identifier\n * @property {Channel#Status} status - The Channel's status\n * @property {Channel#Type} type - The Channel's type\n * @property {String} uniqueName - The Channel's unique name\n */\nclass ChannelDescriptor {\n  public client: Client;\n  public descriptor: any;\n\n  public readonly sid: string;\n  public readonly channel: string;\n  public readonly uniqueName: string;\n  public readonly friendlyName: string;\n  public readonly attributes: any;\n  public readonly createdBy: string;\n  public readonly dateCreated: Date;\n  public readonly dateUpdated: Date;\n  public readonly messagesCount: number;\n  public readonly membersCount: number;\n  public readonly lastConsumedMessageIndex: number;\n  public readonly status: Channel.Status;\n  public readonly type: Channel.Type;\n  public readonly isPrivate: boolean;\n  public readonly notificationLevel: Channel.NotificationLevel;\n\n  /**\n   * @param {Client} client Chat client instance\n   * @param {Object} descriptor Channel descriptor data object\n   * @private\n   */\n  constructor(client: Client, descriptor: any) {\n    this.client = client;\n    this.descriptor = descriptor;\n\n    this.sid = descriptor.sid || descriptor.conversation_sid;\n    this.channel = `${this.sid}.channel`;\n    this.uniqueName = descriptor.unique_name;\n    this.friendlyName = descriptor.friendly_name;\n    this.attributes = parseAttributes(descriptor.attributes, 'Failed to parse channel attributes', log);\n    this.createdBy = descriptor.created_by;\n    this.dateCreated = parseTime(descriptor.date_created);\n    this.dateUpdated = parseTime(descriptor.date_updated);\n    this.messagesCount = descriptor.messages_count;\n    this.membersCount = descriptor.participants_count;\n    this.type = descriptor.type;\n    this.isPrivate = descriptor.type === 'private';\n    this.lastConsumedMessageIndex = descriptor.last_consumed_message_index;\n    this.notificationLevel = descriptor.notification_level || undefined;\n    this.status = descriptor.status || 'unknown';\n  }\n\n  /**\n   * Get channel object from descriptor.\n   * @returns {Promise<Channel>}\n   */\n  getChannel(): Promise<Channel> {\n    return this.client.getChannelBySid(this.sid);\n  }\n}\n\nexport { ChannelDescriptor };\n","import { UriBuilder } from '../util/index';\nimport { RestPaginator } from '../restpaginator';\nimport { ChannelDescriptor } from '../channeldescriptor';\nimport { Network } from '../services/network';\nimport { Client } from '../client';\n\nexport interface PublicChannelServices {\n  network: Network;\n}\n\n/**\n * Public channels collection\n * It's a cassandra-backed pull-based collection\n */\nclass PublicChannels {\n  private client: Client;\n  private services: PublicChannelServices;\n  private url: string;\n\n  constructor(client: Client, services: PublicChannelServices, url: string) {\n    this.client = client;\n    this.services = services;\n    this.url = url;\n  }\n\n  public async getChannels(args: any = {}): Promise<RestPaginator<ChannelDescriptor>> {\n    const url = new UriBuilder(this.url).arg('PageToken', args.pageToken).build();\n    let response = await this.services.network.get(url);\n    return new RestPaginator<ChannelDescriptor>(response.body.conversations.map(x => new ChannelDescriptor(this.client, x))\n      , pageToken => this.getChannels({ pageToken })\n      , response.body.meta.previous_token\n      , response.body.meta.next_token);\n  }\n\n  public async getChannelBySid(sid: string): Promise<ChannelDescriptor> {\n    const url = new UriBuilder(this.url).path(sid).build();\n    let response = await this.services.network.get(url);\n    return new ChannelDescriptor(this.client, response.body);\n  }\n\n  public async getChannelByUniqueName(uniqueName: string): Promise<ChannelDescriptor> {\n    const url = new UriBuilder(this.url).path(uniqueName).build();\n    let response = await this.services.network.get(url);\n    return new ChannelDescriptor(this.client, response.body);\n  }\n}\n\nexport { PublicChannels };\n","import { Retrier } from 'operation-retrier';\nimport { Transport } from '../interfaces/transport';\nimport { Configuration } from '../configuration';\n\ninterface CacheEntry {\n  response: Object;\n  timestamp: number;\n}\n\nexport interface NetworkServices {\n  transport: Transport;\n}\n\nclass Network {\n  private readonly cacheLifetime: number;\n  private readonly cache: Map<string, CacheEntry>;\n  private timer: any;\n\n  constructor(\n    private readonly configuration: Configuration,\n    private readonly services: NetworkServices\n  ) {\n    this.cache = new Map<string, CacheEntry>();\n    this.cacheLifetime = this.configuration.httpCacheInterval * 100;\n    this.cleanupCache();\n  }\n\n  private isExpired(timestamp: number): boolean {\n    return !this.cacheLifetime || (Date.now() - timestamp) > this.cacheLifetime;\n  }\n\n  private cleanupCache() {\n    for (let [k, v] of this.cache) {\n      if (this.isExpired(v.timestamp)) {\n        this.cache.delete(k);\n      }\n    }\n\n    if (this.cache.size === 0) {\n      clearInterval(this.timer);\n    }\n  }\n\n  pokeTimer() {\n    this.timer = this.timer || setInterval(() => this.cleanupCache(), this.cacheLifetime * 2);\n  }\n\n  private executeWithRetry(request, retryWhenThrottled = false): Promise<any> {\n    return new Promise((resolve, reject) => {\n      let codesToRetryOn = [502, 503, 504];\n      if (retryWhenThrottled) {\n        codesToRetryOn.push(429);\n      }\n\n      let retrier = new Retrier(this.configuration.backoffConfiguration);\n      retrier.on('attempt', () => {\n        request()\n          .then(result => retrier.succeeded(result))\n          .catch(err => {\n            if (codesToRetryOn.indexOf(err.status) > -1) {\n              retrier.failed(err);\n            } else if (err.message === 'Twilsock disconnected') {\n              // Ugly hack. We must make a proper exceptions for twilsock\n              retrier.failed(err);\n            } else {\n              // Fatal error\n              retrier.removeAllListeners();\n              retrier.cancel();\n              reject(err);\n            }\n          });\n      });\n\n      retrier.on('succeeded', result => { resolve(result); });\n      retrier.on('cancelled', err => reject(err));\n      retrier.on('failed', err => reject(err));\n\n      retrier.start();\n    });\n  }\n\n  async get(url: string) {\n    let cacheEntry = this.cache.get(url);\n    if (cacheEntry && !this.isExpired(cacheEntry.timestamp)) {\n      return cacheEntry.response;\n    }\n\n    const headers = {};\n    let response = await this.executeWithRetry(\n      () => this.services.transport.get(url, headers, this.configuration.productId), this.configuration.retryWhenThrottled);\n    this.cache.set(url, { response, timestamp: Date.now() });\n    this.pokeTimer();\n    return response;\n  }\n}\n\nexport { Network };\n","class NotificationTypes {\n  static readonly TYPING_INDICATOR = 'twilio.ipmsg.typing_indicator';\n  static readonly NEW_MESSAGE = 'twilio.channel.new_message';\n  static readonly ADDED_TO_CHANNEL = 'twilio.channel.added_to_channel';\n  static readonly INVITED_TO_CHANNEL = 'twilio.channel.invited_to_channel';\n  static readonly REMOVED_FROM_CHANNEL = 'twilio.channel.removed_from_channel';\n  static readonly CONSUMPTION_UPDATE = 'twilio.channel.consumption_update';\n}\n\nexport { NotificationTypes };","import { EventEmitter } from 'events';\nimport { UserDescriptor } from './userdescriptor';\nimport { Users } from './data/users';\nimport { User } from './user';\nimport { isDeepEqual, parseTime, parseAttributes } from './util';\nimport { Logger } from './logger';\nimport { validateTypesAsync, literal } from 'twilio-sdk-type-validator';\nimport { Channel } from './channel';\nimport { CommandExecutor } from './commandexecutor';\nimport { EditMemberRequest, EditMemberResponse } from './interfaces/commands/editmember';\n\nconst log = Logger.scope('Member');\n\ninterface MemberDescriptor {\n  attributes?: Object;\n  dateCreated: any;\n  dateUpdated: any;\n  identity: string;\n  roleSid?: string;\n  lastConsumedMessageIndex: number;\n  lastConsumptionTimestamp: number;\n  type?: Member.Type;\n  userInfo: string;\n}\n\ninterface MemberState {\n  attributes: any;\n  dateCreated: Date;\n  dateUpdated: Date;\n  identity: string;\n  isTyping: boolean;\n  lastConsumedMessageIndex: number | null;\n  lastConsumptionTimestamp: Date;\n  roleSid: string;\n  sid: string;\n  type: Member.Type;\n  typingTimeout: any;\n  userInfo: string;\n}\n\nexport interface MemberServices {\n  users: Users;\n  commandExecutor: CommandExecutor;\n}\n\ninterface MemberLinks {\n  self: string;\n}\n\nnamespace Member {\n  export type UpdateReason = 'attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' | 'lastConsumedMessageIndex' | 'lastConsumptionTimestamp';\n\n  export type Type = 'chat' | 'sms' | 'whatsapp';\n\n  export interface UpdatedEventArgs {\n    member: Member;\n    updateReasons: Member.UpdateReason[];\n  }\n}\n\n/**\n * @classdesc A Member represents a remote Client in a Channel.\n * @property {any} attributes - Object with custom attributes for Member\n * @property {Channel} channel - The Channel the remote Client is a Member of\n * @property {Date} dateCreated - The Date this Member was created\n * @property {Date} dateUpdated - The Date this Member was last updated\n * @property {String} identity - The identity of the remote Client\n * @property {Boolean} isTyping - Whether or not this Member is currently typing\n * @property {Number} lastConsumedMessageIndex - Latest consumed Message index by this Member.\n * Note that just retrieving messages on a client endpoint does not mean that messages are consumed/read,\n * please consider reading about [Consumption Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}\n * to find out how to mark messages as consumed.\n * @property {Date} lastConsumptionTimestamp - Date when Member has updated their consumption horizon\n * @property {String} sid - The server-assigned unique identifier for the Member\n * @property {Member#Type} type - The type of Member\n * @fires Member#typingEnded\n * @fires Member#typingStarted\n * @fires Member#updated\n */\nclass Member extends EventEmitter {\n\n  private state: MemberState;\n\n  constructor(\n    data: MemberDescriptor,\n    sid: string,\n    public readonly channel: Channel,\n    private readonly links: MemberLinks,\n    private readonly services: MemberServices\n  ) {\n    super();\n\n    this.services = services;\n    this.state = {\n      attributes: parseAttributes(data.attributes,\n        'Retrieved malformed attributes from the server for member: ' + sid,\n        log),\n      dateCreated: data.dateCreated ? parseTime(data.dateCreated) : null,\n      dateUpdated: data.dateCreated ? parseTime(data.dateUpdated) : null,\n      sid: sid,\n      typingTimeout: null,\n      isTyping: false,\n      identity: data.identity || null,\n      roleSid: data.roleSid || null,\n      lastConsumedMessageIndex: Number.isInteger(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,\n      lastConsumptionTimestamp: data.lastConsumptionTimestamp ? parseTime(data.lastConsumptionTimestamp) : null,\n      type: data.type || 'chat',\n      userInfo: data.userInfo\n    };\n\n    if (!data.identity && !data.type) {\n      throw new Error('Received invalid Member object from server: Missing identity or type of Member.');\n    }\n  }\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Member\n   * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |\n    'lastConsumedMessageIndex' | 'lastConsumptionTimestamp')} Member#UpdateReason\n   */\n\n  /**\n   * The type of Member\n   * @typedef {('chat' | 'sms' | 'whatsapp')} Member#Type\n   */\n\n  public get sid(): string { return this.state.sid; }\n\n  public get attributes(): Object { return this.state.attributes; }\n\n  public get dateCreated(): Date { return this.state.dateCreated; }\n\n  public get dateUpdated(): Date { return this.state.dateUpdated; }\n\n  public get identity(): string { return this.state.identity; }\n\n  public get isTyping(): boolean { return this.state.isTyping; }\n\n  public get lastConsumedMessageIndex(): number | null { return this.state.lastConsumedMessageIndex; }\n\n  public get lastConsumptionTimestamp(): Date { return this.state.lastConsumptionTimestamp; }\n\n  public get roleSid(): string { return this.state.roleSid; }\n\n  public get type(): Member.Type { return this.state.type; }\n\n  /**\n   * Private method used to start or reset the typing indicator timeout (with event emitting)\n   * @private\n   */\n  _startTyping(timeout) {\n    clearTimeout(this.state.typingTimeout);\n\n    this.state.isTyping = true;\n    this.emit('typingStarted', this);\n    this.channel.emit('typingStarted', this);\n\n    this.state.typingTimeout = setTimeout(() => this._endTyping(), timeout);\n    return this;\n  }\n\n  /**\n   * Private method function used to stop typing indicator (with event emitting)\n   * @private\n   */\n  _endTyping() {\n    if (!this.state.typingTimeout) { return; }\n\n    this.state.isTyping = false;\n    this.emit('typingEnded', this);\n    this.channel.emit('typingEnded', this);\n\n    clearInterval(this.state.typingTimeout);\n    this.state.typingTimeout = null;\n  }\n\n  /**\n   * Private method function used update local object's property roleSid with new value\n   * @private\n   */\n  _update(data) {\n    let updateReasons: Member.UpdateReason[] = [];\n\n    let updateAttributes =\n      parseAttributes(\n        data.attributes,\n        'Retrieved malformed attributes from the server for member: ' + this.state.sid,\n        log);\n\n    if (data.attributes && !isDeepEqual(this.state.attributes, updateAttributes)) {\n      this.state.attributes = updateAttributes;\n      updateReasons.push('attributes');\n    }\n\n    let updatedDateUpdated = parseTime(data.dateUpdated);\n    if (data.dateUpdated &&\n      updatedDateUpdated.getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n      this.state.dateUpdated = updatedDateUpdated;\n      updateReasons.push('dateUpdated');\n    }\n\n    let updatedDateCreated = parseTime(data.dateCreated);\n    if (data.dateCreated &&\n      updatedDateCreated.getTime() !== (this.state.dateCreated && this.state.dateCreated.getTime())) {\n      this.state.dateCreated = updatedDateCreated;\n      updateReasons.push('dateCreated');\n    }\n\n    if (data.roleSid && this.state.roleSid !== data.roleSid) {\n      this.state.roleSid = data.roleSid;\n      updateReasons.push('roleSid');\n    }\n\n    if ((Number.isInteger(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null)\n      && this.state.lastConsumedMessageIndex !== data.lastConsumedMessageIndex) {\n      this.state.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n      updateReasons.push('lastConsumedMessageIndex');\n    }\n\n    if (data.lastConsumptionTimestamp) {\n      let lastConsumptionTimestamp = new Date(data.lastConsumptionTimestamp);\n      if (!this.state.lastConsumptionTimestamp ||\n        this.state.lastConsumptionTimestamp.getTime() !== lastConsumptionTimestamp.getTime()) {\n        this.state.lastConsumptionTimestamp = lastConsumptionTimestamp;\n        updateReasons.push('lastConsumptionTimestamp');\n      }\n    }\n\n    if (updateReasons.length > 0) {\n      this.emit('updated', { member: this, updateReasons: updateReasons });\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets User Descriptor for this member. Supported only for <code>chat</code> type of Members\n   * @returns {Promise<UserDescriptor>}\n   */\n  async getUserDescriptor(): Promise<UserDescriptor> {\n    if (this.type != 'chat') {\n      throw new Error('Getting User Descriptor is not supported for this Member type: ' + this.type);\n    }\n\n    return this.services.users.getUserDescriptor(this.state.identity);\n  }\n\n  /**\n   * Gets User for this member and subscribes to it. Supported only for <code>chat</code> type of Members\n   * @returns {Promise<User>}\n   */\n  async getUser(): Promise<User> {\n    if (this.type != 'chat') {\n      throw new Error('Getting User is not supported for this Member type: ' + this.type);\n    }\n\n    return this.services.users.getUser(this.state.identity, this.state.userInfo);\n  }\n\n  /**\n   * Remove Member from the Channel.\n   * @returns {Promise<void>}\n   */\n  async remove(): Promise<void> {\n    return this.channel.removeMember(this);\n  }\n\n  /**\n   * Edit member attributes.\n   * @param {any} attributes new attributes for Member.\n   * @returns {Promise<Member>}\n   */\n  @validateTypesAsync(['string', 'number', 'boolean', 'object', literal(null)])\n  async updateAttributes(attributes: any): Promise<Member> {\n    await this.services.commandExecutor.mutateResource<EditMemberRequest, EditMemberResponse>(\n      'post',\n      this.links.self,\n      {\n        attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n      }\n    );\n\n    return this;\n  }\n}\n\nexport { MemberDescriptor, Member };\n\n/**\n * Fired when Member started to type.\n * @event Member#typingStarted\n * @type {Member}\n */\n\n/**\n * Fired when Member ended to type.\n * @event Member#typingEnded\n * @type {Member}\n */\n\n/**\n * Fired when Member's fields has been updated.\n * @event Member#updated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n","import { EventEmitter } from 'events';\nimport { MemberDescriptor, Member } from '../member';\nimport { Logger } from '../logger';\n\nimport { Channel } from '../channel';\n\nimport { SyncMap, SyncClient } from 'twilio-sync';\nimport { Users } from './users';\nimport { CommandExecutor } from '../commandexecutor';\nimport { JoinChannelRequest, JoinChannelResponse } from '../interfaces/commands/joinchannel';\nimport { Configuration } from '../configuration';\n\nconst log = Logger.scope('Members');\n\nexport interface MembersServices {\n  syncClient: SyncClient;\n  users: Users;\n  commandExecutor: CommandExecutor;\n}\n\ninterface MembersLinks {\n  participants: string;\n}\n\n/**\n * @classdesc Represents the collection of members for the channel\n * @fires Members#memberJoined\n * @fires Members#memberLeft\n * @fires Members#memberUpdated\n */\nclass Members extends EventEmitter {\n\n  rosterEntityPromise: Promise<SyncMap>;\n\n  constructor(\n    public readonly channel: Channel,\n    public readonly members: Map<string, Member>,\n    private readonly links: MembersLinks,\n    private readonly configuration: Configuration,\n    private readonly services: MembersServices\n  ) {\n    super();\n  }\n\n  async unsubscribe(): Promise<void> {\n    if (this.rosterEntityPromise) {\n      let entity = await this.rosterEntityPromise;\n      entity.close();\n      this.rosterEntityPromise = null;\n    }\n  }\n\n  subscribe(rosterObjectName: string) {\n    return this.rosterEntityPromise = this.rosterEntityPromise\n      || this.services.syncClient.map({ id: rosterObjectName, mode: 'open_existing' })\n             .then(rosterMap => {\n               rosterMap.on('itemAdded', args => {\n                 log.debug(this.channel.sid + ' itemAdded: ' + args.item.key);\n                 this.upsertMember(args.item.key, args.item.data)\n                     .then(member => {\n                       this.emit('memberJoined', member);\n                     });\n               });\n\n               rosterMap.on('itemRemoved', args => {\n                 log.debug(this.channel.sid + ' itemRemoved: ' + args.key);\n                 let memberSid = args.key;\n                 if (!this.members.has(memberSid)) {\n                   return;\n                 }\n                 let leftMember = this.members.get(memberSid);\n                 this.members.delete(memberSid);\n                 this.emit('memberLeft', leftMember);\n               });\n\n               rosterMap.on('itemUpdated', args => {\n                 log.debug(this.channel.sid + ' itemUpdated: ' + args.item.key);\n                 this.upsertMember(args.item.key, args.item.data);\n               });\n\n               let membersPromises = [];\n               let that = this;\n               const rosterMapHandler = function(paginator) {\n                 paginator.items.forEach(item => { membersPromises.push(that.upsertMember(item.key, item.data)); });\n                 return paginator.hasNextPage ? paginator.nextPage().then(rosterMapHandler) : null;\n               };\n\n               return rosterMap\n                 .getItems()\n                 .then(rosterMapHandler)\n                 .then(() => Promise.all(membersPromises))\n                 .then(() => rosterMap);\n             })\n             .catch(err => {\n               this.rosterEntityPromise = null;\n               if (this.services.syncClient.connectionState != 'disconnected') {\n                 log.error('Failed to get roster object for channel', this.channel.sid, err);\n               }\n               log.debug('ERROR: Failed to get roster object for channel', this.channel.sid, err);\n               throw err;\n             });\n  }\n\n  async upsertMember(memberSid: string, data: MemberDescriptor): Promise<Member> {\n    let member = this.members.get(memberSid);\n    if (member) {\n      return member._update(data);\n    }\n\n    const links = {\n      self: `${this.links.participants}/${memberSid}`\n    };\n\n    member = new Member(data, memberSid, this.channel, links, this.services);\n    this.members.set(memberSid, member);\n    member.on('updated', (args: Member.UpdatedEventArgs) => this.emit('memberUpdated', args));\n    return member;\n  }\n\n  /**\n   * @returns {Promise<Array<Member>>} returns list of members {@see Member}\n   */\n  getMembers(): Promise<Array<Member>> {\n    return this.rosterEntityPromise.then(() => {\n      let members = [];\n      this.members.forEach((member) => members.push(member));\n      return members;\n    });\n  }\n\n  /**\n   * Get member by SID from channel\n   * @returns {Promise<Member>}\n   */\n  async getMemberBySid(memberSid: string): Promise<Member> {\n    return this.rosterEntityPromise.then(() => {\n      let member = this.members.get(memberSid);\n      if (!member) {\n        throw new Error('Member with SID ' + memberSid + ' was not found');\n      }\n      return member;\n    });\n  }\n\n  /**\n   * Get member by identity from channel\n   * @returns {Promise<Member>}\n   */\n  async getMemberByIdentity(identity: string): Promise<Member> {\n    let foundMember = null;\n    return this.rosterEntityPromise.then(() => {\n      this.members.forEach((member) => {\n        if (member.identity === identity) {\n          foundMember = member;\n        }\n      });\n      if (!foundMember) {\n        throw new Error('Member with identity ' + identity + ' was not found');\n      }\n      return foundMember;\n    });\n  }\n\n  /**\n   * Add user to the channel\n   * @returns {Promise<any>}\n   */\n  async add(identity: string): Promise<JoinChannelResponse> {\n    return await this.services.commandExecutor.mutateResource<JoinChannelRequest, JoinChannelResponse>(\n      'post',\n      this.links.participants,\n      {\n        identity\n      }\n    );\n  }\n\n  /**\n   * Invites user to the channel\n   * User can choose either to join or not\n   * @returns {Promise<any>}\n   */\n  async invite(identity: string): Promise<any> {\n    return await this.services.commandExecutor.mutateResource(\n      'post',\n      this.channel.links.invites,\n      {\n        identity\n      }\n    );\n  }\n\n  /**\n   * Remove member from channel\n   * @returns {Promise<any>}\n   */\n  async remove(identity: string): Promise<void> {\n    return await this.services.commandExecutor.mutateResource(\n      'delete',\n      `${this.links.participants}/${identity}`,\n    );\n  }\n}\n\nexport { Members };\n\n/**\n * Fired when member joined channel\n * @event Members#memberJoined\n * @type {Member}\n */\n\n/**\n * Fired when member left channel\n * @event Members#memberLeft\n * @type {Member}\n */\n\n/**\n * Fired when member updated\n * @event Members#memberUpdated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n","import { McsClient, McsMedia } from 'twilio-mcs-client';\n\nexport interface MediaState {\n  sid: string;\n  filename?: string;\n  contentType: string;\n  size: number;\n}\n\nexport interface MediaServices {\n  mcsClient: McsClient;\n}\n\n/**\n * @classdesc A Media represents a media information for Message in a Channel.\n * @property {String} contentType - content type of media\n * @property {String} sid - The server-assigned unique identifier for Media\n * @property {Number} size - Size of media, bytes\n * @property {String} [filename] - file name if present, null otherwise\n */\nclass Media {\n\n  private state: MediaState;\n  private services: MediaServices;\n  private mcsMedia: McsMedia = null;\n\n  constructor(data: MediaState, services: MediaServices) {\n\n    this.services = services;\n\n    this.state = {\n      sid: data.sid,\n      filename: data.filename,\n      contentType: data.contentType,\n      size: data.size\n    };\n  }\n\n  public get sid(): string { return this.state.sid; }\n\n  public get filename(): string {return this.state.filename; }\n\n  public get contentType(): string { return this.state.contentType; }\n\n  public get size(): number {return this.state.size; }\n\n  /**\n   * Returns direct content URL for the media.\n   *\n   * This URL is impermanent, it will expire in several minutes and cannot be cached.\n   * If the URL becomes expired, you need to request a new one.\n   * Each call to this function produces a new temporary URL.\n   *\n   * @returns {Promise<String>}\n   */\n  public async getContentTemporaryUrl() {\n    if (!this.mcsMedia) {\n      if (this.services.mcsClient) {\n        this.mcsMedia = await this.services.mcsClient.get(this.state.sid);\n      } else {\n        throw new Error('Media Content Service is unavailable');\n      }\n    }\n    return this.mcsMedia.getContentUrl();\n  }\n}\n\nexport { Media };\n","import { EventEmitter } from 'events';\nimport { isDeepEqual, parseAttributes } from './util';\nimport { Logger } from './logger';\n\nimport { Channel } from './channel';\nimport { McsClient } from 'twilio-mcs-client';\nimport { Media } from './media';\nimport { Member } from './member';\nimport { validateTypesAsync, literal } from 'twilio-sdk-type-validator';\nimport { Configuration } from './configuration';\nimport { CommandExecutor } from './commandexecutor';\nimport { EditMessageRequest } from './interfaces/commands/editmessage';\nimport { MessageResponse } from './interfaces/commands/messageresponse';\n\nconst log = Logger.scope('Message');\n\nnamespace Message {\n  export type Type = 'text' | 'media';\n}\n\ninterface MessageState {\n  sid: string;\n  index: number;\n  author?: string;\n  body: string;\n  dateUpdated: Date;\n  lastUpdatedBy: string;\n  attributes: Object;\n  timestamp: Date;\n  type: Message.Type;\n  media?: Media;\n  memberSid?: string;\n}\n\nexport interface MessageServices {\n  mcsClient: McsClient;\n  commandExecutor: CommandExecutor;\n}\n\ninterface MessageLinks {\n  self: string;\n  conversation: string;\n  messages_receipts: string;\n}\n\nnamespace Message {\n  export type UpdateReason = 'body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated'  | 'attributes' | 'author';\n\n  export interface UpdatedEventArgs {\n    message: Message;\n    updateReasons: Message.UpdateReason[];\n  }\n}\n\n/**\n * @classdesc A Message represents a Message in a Channel.\n * @property {String} author - The name of the user that sent Message\n * @property {String} body - The body of the Message. Is null if Message is Media Message\n * @property {any} attributes - Message custom attributes\n * @property {Channel} channel - Channel Message belongs to\n * @property {Date} dateCreated - When Message was created\n * @property {Date} dateUpdated - When Message was updated\n * @property {Number} index - Index of Message in the Channel's messages list\n * @property {String} lastUpdatedBy - Identity of the last user that updated Message\n * @property {Media} media - Contains Media information (if present)\n * @property {String} memberSid - Authoring Member's server-assigned unique identifier\n * @property {String} sid - The server-assigned unique identifier for Message\n * @property {'text' | 'media' } type - Type of message: 'text' or 'media'\n * @fires Message#updated\n */\nclass Message extends EventEmitter {\n  private state: MessageState;\n\n  constructor(\n    index: number,\n    data: any,\n    public readonly channel: Channel,\n    private readonly links: MessageLinks,\n    private readonly configuration: Configuration,\n    private readonly services: MessageServices\n  ) {\n    super();\n\n    this.state = {\n      sid: data.sid,\n      index: index,\n      author: data.author == null ? null : data.author,\n      body: data.text,\n      timestamp: data.timestamp ? new Date(data.timestamp) : null,\n      dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,\n      lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,\n      attributes: parseAttributes(data.attributes, `Got malformed attributes for the message ${data.sid}`, log),\n      type: data.type ? data.type : 'text',\n      media: (data.type && data.type === 'media' && data.media)\n        ? new Media(data.media, this.services) : null,\n      memberSid: data.memberSid == null ? null : data.memberSid\n    };\n  }\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Message\n   * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author')} Message#UpdateReason\n   */\n\n  public get sid(): string { return this.state.sid; }\n\n  public get author(): string { return this.state.author; }\n\n  public get body(): string {\n    if (this.type === 'media') { return null; }\n    return this.state.body;\n  }\n\n  public get dateUpdated(): Date { return this.state.dateUpdated; }\n\n  public get index(): number { return this.state.index; }\n\n  public get lastUpdatedBy(): string { return this.state.lastUpdatedBy; }\n\n  public get dateCreated(): Date { return this.state.timestamp; }\n\n  public get attributes(): Object { return this.state.attributes; }\n\n  public get type(): Message.Type { return this.state.type; }\n\n  public get media(): Media { return this.state.media; }\n\n  public get memberSid(): string { return this.state.memberSid; }\n\n  _update(data) {\n    let updateReasons: Message.UpdateReason[] = [];\n\n    if ((data.text || ((typeof data.text) === 'string')) && data.text !== this.state.body) {\n      this.state.body = data.text;\n      updateReasons.push('body');\n    }\n\n    if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {\n      this.state.lastUpdatedBy = data.lastUpdatedBy;\n      updateReasons.push('lastUpdatedBy');\n    }\n\n    if (data.author && data.author !== this.state.author) {\n      this.state.author = data.author;\n      updateReasons.push('author');\n    }\n\n    if (data.dateUpdated &&\n      new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {\n      this.state.dateUpdated = new Date(data.dateUpdated);\n      updateReasons.push('dateUpdated');\n    }\n\n    if (data.timestamp &&\n      new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {\n      this.state.timestamp = new Date(data.timestamp);\n      updateReasons.push('dateCreated');\n    }\n\n    let updatedAttributes = parseAttributes(data.attributes, `Got malformed attributes for the message ${this.sid}`, log);\n    if (!isDeepEqual(this.state.attributes, updatedAttributes)) {\n      this.state.attributes = updatedAttributes;\n      updateReasons.push('attributes');\n    }\n\n    if (updateReasons.length > 0) {\n      this.emit('updated', { message: this, updateReasons: updateReasons });\n    }\n  }\n\n  /**\n   * Get Member who is author of the Message\n   * @returns {Promise<Member>}\n   */\n  async getMember(): Promise<Member> {\n    let member: Member = null;\n    if (this.state.memberSid) {\n      member = await this.channel.getMemberBySid(this.memberSid)\n                         .catch(() => {\n                           log.debug('Member with sid \"' + this.memberSid + '\" not found for message ' + this.sid);\n                           return null;\n                         });\n    }\n    if (!member && this.state.author) {\n      member = await this.channel.getMemberByIdentity(this.state.author)\n                         .catch(() => {\n                           log.debug('Member with identity \"' + this.author + '\" not found for message ' + this.sid);\n                           return null;\n                         });\n    }\n    if (member) {\n      return member;\n    }\n    let errorMesage = 'Member with ';\n    if (this.state.memberSid) {\n      errorMesage += 'SID \\'' + this.state.memberSid + '\\' ';\n    }\n    if (this.state.author) {\n      if (this.state.memberSid) {\n        errorMesage += 'or ';\n      }\n      errorMesage += 'identity \\'' + this.state.author + '\\' ';\n    }\n    if (errorMesage === 'Member with ') {\n      errorMesage = 'Member ';\n    }\n    errorMesage += 'was not found';\n    throw new Error(errorMesage);\n  }\n\n  /**\n   * Remove the Message.\n   * @returns {Promise<Message>}\n   */\n  async remove(): Promise<Message> {\n    await this.services.commandExecutor.mutateResource(\n      'delete',\n      this.links.self,\n    );\n\n    return this;\n  }\n\n  /**\n   * Edit message body.\n   * @param {String} body - new body of Message.\n   * @returns {Promise<Message>}\n   */\n  @validateTypesAsync('string')\n  async updateBody(body: string): Promise<Message> {\n    await this.services.commandExecutor.mutateResource<EditMessageRequest, MessageResponse>(\n      'post',\n      this.links.self,\n      {\n        body\n      }\n    );\n\n    return this;\n  }\n\n  /**\n   * Edit message attributes.\n   * @param {any} attributes new attributes for Message.\n   * @returns {Promise<Message>}\n   */\n  @validateTypesAsync(['string', 'number', 'boolean', 'object', literal(null)])\n  async updateAttributes(attributes: any): Promise<Message> {\n    await this.services.commandExecutor.mutateResource<EditMessageRequest, MessageResponse>(\n      'post',\n      this.links.self,\n      {\n        attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n      }\n    );\n\n    return this;\n  }\n}\n\nexport { Message };\n\n/**\n * Fired when the Message's properties or body has been updated.\n * @event Message#updated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n","import { EventEmitter } from 'events';\nimport { Logger } from '../logger';\n\nimport { Message } from '../message';\nimport { Channel } from '../channel';\n\nimport { SyncList, SyncClient } from 'twilio-sync';\nimport { SyncPaginator } from '../syncpaginator';\n\nimport { McsClient, McsMedia } from 'twilio-mcs-client';\nimport { Configuration } from '../configuration';\nimport { CommandExecutor } from '../commandexecutor';\nimport { SendMessageRequest } from '../interfaces/commands/sendmessage';\nimport { MessageResponse } from '../interfaces/commands/messageresponse';\nimport { SendMediaMessageRequest } from '../interfaces/commands/sendmediamessage';\n\nconst log = Logger.scope('Messages');\n\nexport interface MessagesServices {\n  mcsClient: McsClient;\n  syncClient: SyncClient;\n  commandExecutor: CommandExecutor;\n}\n\n/**\n * Represents the collection of messages in a channel\n */\nclass Messages extends EventEmitter {\n  private readonly messagesByIndex: Map<number, Message>;\n  private messagesListPromise: Promise<SyncList>;\n\n  constructor(\n    public readonly channel: Channel,\n    private readonly configuration: Configuration,\n    private readonly services: MessagesServices\n  ) {\n    super();\n\n    this.messagesByIndex = new Map();\n    this.messagesListPromise = null;\n  }\n\n  /**\n   * Subscribe to the Messages Event Stream\n   * @param {String} name - The name of Sync object for the Messages resource.\n   * @returns {Promise}\n   */\n  subscribe(name: string) {\n    return this.messagesListPromise =\n      this.messagesListPromise ||\n      this.services.syncClient.list({ id: name, mode: 'open_existing' })\n          .then(list => {\n\n            list.on('itemAdded', args => {\n              log.debug(this.channel.sid + ' itemAdded: ' + args.item.index);\n              const links = {\n                self: `${this.channel.links.messages}/${args.item.data.sid}`,\n                conversation: this.channel.links.self,\n                messages_receipts: `${this.channel.links.messages}/${args.item.data.sid}/Receipts`,\n              };\n              const message = new Message(args.item.index, args.item.data, this.channel, links, this.configuration, this.services);\n              if (this.messagesByIndex.has(message.index)) {\n                log.debug('Message arrived, but already known and ignored', this.channel.sid, message.index);\n                return;\n              }\n\n              this.messagesByIndex.set(message.index, message);\n              message.on('updated',\n                (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n              this.emit('messageAdded', message);\n            });\n\n            list.on('itemRemoved', args => {\n              log.debug(this.channel.sid + ' itemRemoved: ' + args.index);\n              let index = args.index;\n              if (this.messagesByIndex.has(index)) {\n                let message = this.messagesByIndex.get(index);\n                this.messagesByIndex.delete(message.index);\n                message.removeAllListeners('updated');\n                this.emit('messageRemoved', message);\n              }\n            });\n\n            list.on('itemUpdated', args => {\n              log.debug(this.channel.sid + ' itemUpdated: ' + args.item.index);\n              let message = this.messagesByIndex.get(args.item.index);\n              if (message) {\n                message._update(args.item.data);\n              }\n            });\n\n            return list;\n          })\n          .catch(err => {\n            this.messagesListPromise = null;\n            if (this.services.syncClient.connectionState != 'disconnected') {\n              log.error('Failed to get messages object for channel', this.channel.sid, err);\n            }\n            log.debug('ERROR: Failed to get messages object for channel', this.channel.sid, err);\n            throw err;\n          });\n  }\n\n  async unsubscribe() {\n    if (this.messagesListPromise) {\n      let entity = await this.messagesListPromise;\n      entity.close();\n      this.messagesListPromise = null;\n    }\n  }\n\n  /**\n   * Send Message to the channel\n   * @param {String} message - Message to post\n   * @param {any} attributes Message attributes\n   * @returns Returns promise which can fail\n   */\n  async send(message: string | null, attributes: any = {}): Promise<MessageResponse> {\n    log.debug('Sending text message', message, attributes);\n\n    return await this.services.commandExecutor.mutateResource<SendMessageRequest, MessageResponse>(\n      'post',\n      this.channel.links.messages,\n      {\n        body: message || '',\n        attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined,\n      }\n    );\n  }\n\n  /**\n   * Send Media Message to the channel\n   * @param {FormData | Channel#SendMediaOptions} mediaContent - Media content to post\n   * @param {any} attributes Message attributes\n   * @returns Returns promise which can fail\n   */\n  async sendMedia(mediaContent: FormData | Channel.SendMediaOptions, attributes: any = {}) {\n    log.debug('Sending media message', mediaContent, attributes);\n\n    let media: McsMedia;\n    if (typeof FormData !== 'undefined'  && (mediaContent instanceof FormData)) {\n      log.debug('Sending media message as FormData', mediaContent, attributes);\n      media = await this.services.mcsClient.postFormData(mediaContent);\n    } else {\n      log.debug('Sending media message as SendMediaOptions', mediaContent, attributes);\n      let mediaOptions = mediaContent as Channel.SendMediaOptions;\n      if (!mediaOptions.contentType || !mediaOptions.media) {\n        throw new Error('Media content <Channel#SendMediaOptions> must contain non-empty contentType and media');\n      }\n      media = await this.services.mcsClient.post(mediaOptions.contentType, mediaOptions.media);\n    }\n\n    return await this.services.commandExecutor.mutateResource<SendMediaMessageRequest, MessageResponse>(\n      'post',\n      this.channel.links.messages,\n      {\n        media_sid: media.sid,\n        attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined\n      }\n    );\n  }\n\n  /**\n   * Returns messages from channel using paginator interface\n   * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.\n   * @param {String} [anchor] Most early message id which is already known, or 'end' by default\n   * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default\n   * @returns {Promise<Paginator<Message>>} last page of messages by default\n   */\n  getMessages(pageSize, anchor, direction) {\n    anchor = (typeof anchor !== 'undefined') ? anchor : 'end';\n    direction = direction || 'backwards';\n    return this._getMessages(pageSize, anchor, direction);\n  }\n\n  private wrapPaginator(order, page, op) {\n    // We should swap next and prev page here, because of misfit of Sync and Chat paging conceptions\n    let shouldReverse = order === 'desc';\n\n    let np = () => page.nextPage().then(x => this.wrapPaginator(order, x, op));\n    let pp = () => page.prevPage().then(x => this.wrapPaginator(order, x, op));\n\n    return op(page.items).then(items => ({\n      items: items.sort((x, y) => { return x.index - y.index; }),\n      hasPrevPage: shouldReverse ? page.hasNextPage : page.hasPrevPage,\n      hasNextPage: shouldReverse ? page.hasPrevPage : page.hasNextPage,\n      prevPage: shouldReverse ? np : pp,\n      nextPage: shouldReverse ? pp : np\n    }));\n  }\n\n  private _upsertMessage(index: number, value: any) {\n    const cachedMessage = this.messagesByIndex.get(index);\n    if (cachedMessage) {\n      return cachedMessage;\n    }\n\n    const links = {\n      self: `${this.channel.links.messages}/${value.sid}`,\n      conversation: this.channel.links.self,\n      messages_receipts: `${this.channel.links.messages}/${value.sid}/Receipts`,\n    };\n    const message = new Message(index, value, this.channel, links, this.configuration, this.services);\n    this.messagesByIndex.set(message.index, message);\n    message.on('updated',\n      (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n    return message;\n  }\n\n  /**\n   * Returns last messages from channel\n   * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.\n   * @param {String} [anchor] Most early message id which is already known, or 'end' by default\n   * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default\n   * @returns {Promise<SyncPaginator<Message>>} last page of messages by default\n   * @private\n   */\n  private _getMessages(pageSize, anchor, direction): Promise<SyncPaginator<Message>> {\n    anchor = (typeof anchor !== 'undefined') ? anchor : 'end';\n    pageSize = pageSize || 30;\n    let order = direction === 'backwards' ? 'desc' : 'asc';\n\n    return this.messagesListPromise\n               .then(messagesList => messagesList.getItems({\n                 from: anchor !== 'end' ? anchor : void (0),\n                 pageSize,\n                 order\n               }))\n               .then(page => this.wrapPaginator(order, page\n                 , items => Promise.all(items.map(item => this._upsertMessage(item.index, item.data))))\n               );\n  }\n}\n\nexport { Messages };\n","import { EventEmitter } from 'events';\nimport { Logger } from './logger';\n\nimport { Members } from './data/members';\nimport { Member } from './member';\nimport { Messages } from './data/messages';\nimport { Message } from './message';\n\nimport { UriBuilder, isDeepEqual, parseToNumber } from './util';\nimport { UserDescriptor } from './userdescriptor';\nimport { Users } from './data/users';\nimport { Paginator } from './interfaces/paginator';\nimport { Channels } from './data/channels';\nimport { McsClient } from 'twilio-mcs-client';\n\nimport { SyncClient } from 'twilio-sync';\nimport { TypingIndicator } from './services/typingindicator';\nimport { Network } from './services/network';\nimport { validateTypesAsync, custom, literal, nonEmptyString, nonNegativeInteger, objectSchema } from 'twilio-sdk-type-validator';\nimport { Configuration } from './configuration';\nimport { CommandExecutor } from './commandexecutor';\nimport { JoinChannelRequest, JoinChannelResponse } from './interfaces/commands/joinchannel';\nimport { EditChannelRequest } from './interfaces/commands/editchannel';\nimport { ChannelResponse } from './interfaces/commands/channel';\nimport { EditNotificationLevelRequest } from './interfaces/commands/editnotificationlevel';\nimport { EditLastConsumedMessageIndexRequest, EditLastConsumedMessageIndexResponse } from './interfaces/commands/editlastconsumedmessageindex';\n\nconst log = Logger.scope('Channel');\n\nconst fieldMappings = {\n  lastMessage: 'lastMessage',\n  attributes: 'attributes',\n  createdBy: 'createdBy',\n  dateCreated: 'dateCreated',\n  dateUpdated: 'dateUpdated',\n  friendlyName: 'friendlyName',\n  lastConsumedMessageIndex: 'lastConsumedMessageIndex',\n  notificationLevel: 'notificationLevel',\n  sid: 'sid',\n  status: 'status',\n  type: 'type',\n  uniqueName: 'uniqueName',\n  state: 'state'\n};\n\nfunction parseTime(timeString) {\n  try {\n    return new Date(timeString);\n  } catch (e) {\n    return null;\n  }\n}\n\nexport interface ChannelServices {\n  users: Users;\n  typingIndicator: TypingIndicator;\n  network: Network;\n  mcsClient: McsClient;\n  syncClient: SyncClient;\n  commandExecutor: CommandExecutor;\n}\n\ninterface ChannelState {\n  uniqueName: string;\n  status: Channel.Status;\n  type: Channel.Type;\n  attributes: any;\n  createdBy?: string;\n  dateCreated: Date;\n  dateUpdated: Date;\n  friendlyName: string;\n  lastConsumedMessageIndex: number | null;\n  lastMessage?: Channel.LastMessage;\n  notificationLevel?: Channel.NotificationLevel;\n  state?: Channel.State;\n}\n\ninterface ChannelDescriptor {\n  channel: string;\n  entityName: string;\n  uniqueName: string;\n  attributes: any;\n  createdBy?: string;\n  friendlyName: string;\n  lastConsumedMessageIndex: number;\n  dateCreated: any;\n  dateUpdated: any;\n  type: Channel.Type;\n  notificationLevel?: Channel.NotificationLevel;\n}\n\ninterface ChannelLinks {\n  self: string;\n  messages: string;\n  participants: string;\n  invites: string;\n}\n\nnamespace Channel {\n  export type UpdateReason = 'attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |\n    'friendlyName' | 'lastConsumedMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' | 'notificationLevel';\n\n  export type Status = 'unknown' | 'notParticipating' | 'invited' | 'joined';\n\n  export type Type = 'public' | 'private';\n\n  export type NotificationLevel = 'default' | 'muted';\n\n  export type State = {\n    current: 'active' | 'inactive' | 'closed',\n    dateUpdated: Date\n  } | undefined;\n\n  export interface UpdatedEventArgs {\n    channel: Channel;\n    updateReasons: Channel.UpdateReason[];\n  }\n\n  export interface SendMediaOptions {\n    contentType: string;\n    media: string | Buffer;\n  }\n\n  export interface LastMessage {\n    index?: number;\n    dateCreated?: Date;\n  }\n}\n\n/**\n * @classdesc A Channel represents a remote channel of communication between multiple Programmable Chat Clients\n * @property {any} attributes - The Channel's custom attributes\n * @property {String} createdBy - The identity of the User that created this Channel\n * @property {Date} dateCreated - The Date this Channel was created\n * @property {Date} dateUpdated - The Date this Channel was last updated\n * @property {String} friendlyName - The Channel's name\n * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)\n * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel\n * @property {Channel#LastMessage} lastMessage - Last Message sent to this Channel\n * @property {Channel#NotificationLevel} notificationLevel - User Notification level for this Channel\n * @property {String} sid - The Channel's unique system identifier\n * @property {Channel#State} state - The Channel's state\n * @property {Channel#Status} status - The Channel's status\n * @property {Channel#Type} type - The Channel's type\n * @property {String} uniqueName - The Channel's unique name (tag)\n * @fires Channel#memberJoined\n * @fires Channel#memberLeft\n * @fires Channel#memberUpdated\n * @fires Channel#messageAdded\n * @fires Channel#messageRemoved\n * @fires Channel#messageUpdated\n * @fires Channel#typingEnded\n * @fires Channel#typingStarted\n * @fires Channel#updated\n * @fires Channel#removed\n */\n\nclass Channel extends EventEmitter {\n  private channelState: ChannelState;\n  private statusSource: Channels.DataSource;\n\n  private entityPromise: Promise<any>;\n  private entityName: string;\n  private entity: any;\n  private messagesEntity: any;\n  private membersEntity: Members;\n  private members: any;\n\n  constructor(\n    descriptor: ChannelDescriptor,\n    public readonly sid: string,\n    public readonly links: ChannelLinks,\n    private readonly configuration: Configuration,\n    private readonly services: ChannelServices\n  ) {\n    super();\n\n    let attributes = descriptor.attributes || {};\n    let createdBy = descriptor.createdBy;\n    let dateCreated = parseTime(descriptor.dateCreated);\n    let dateUpdated = parseTime(descriptor.dateUpdated);\n    let friendlyName = descriptor.friendlyName || null;\n    let lastConsumedMessageIndex =\n      Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;\n    let uniqueName = descriptor.uniqueName || null;\n\n    try {\n      JSON.stringify(attributes);\n    } catch (e) {\n      throw new Error('Attributes must be a valid JSON object.');\n    }\n\n    this.entityName = descriptor.channel;\n    this.channelState = {\n      uniqueName,\n      status: 'notParticipating',\n      type: descriptor.type,\n      attributes,\n      createdBy,\n      dateCreated,\n      dateUpdated,\n      friendlyName,\n      lastConsumedMessageIndex\n    };\n\n    if (descriptor.notificationLevel) {\n      this.channelState.notificationLevel = descriptor.notificationLevel;\n    }\n\n    const membersLinks = {\n      participants: this.links.participants\n    };\n\n    this.members = new Map();\n    this.membersEntity = new Members(this, this.members, membersLinks, this.configuration, this.services);\n    this.membersEntity.on('memberJoined', this.emit.bind(this, 'memberJoined'));\n    this.membersEntity.on('memberLeft', this.emit.bind(this, 'memberLeft'));\n    this.membersEntity.on('memberUpdated',\n      (args: Member.UpdatedEventArgs) => this.emit('memberUpdated', args));\n\n    this.messagesEntity = new Messages(this, this.configuration, services);\n    this.messagesEntity.on('messageAdded', message => this._onMessageAdded(message));\n    this.messagesEntity.on('messageUpdated',\n      (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n    this.messagesEntity.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n  }\n\n  /**\n   * The Channel's state. Set to undefined if the channel is not a conversation.\n   * @typedef {Object | undefined} Channel#State\n   * @property {('active' | 'inactive' | 'closed')} current - the current state\n   * @property {Date} dateUpdated - date at which the latest channel state update happened\n   */\n\n  /**\n   * These options can be passed to {@link Channel#sendMessage}.\n   * @typedef {Object} Channel#SendMediaOptions\n   * @property {String} contentType - content type of media\n   * @property {String | Buffer} media - content to post\n   */\n\n  /**\n   * The update reason for <code>updated</code> event emitted on Channel\n   * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |\n    'friendlyName' | 'lastConsumedMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |\n    'notificationLevel' )} Channel#UpdateReason\n   */\n\n  /**\n   * The status of the Channel, relative to the Client: whether the Channel\n   * is <code>notParticipating</code> to local Client, Client is <code>invited</code> to or\n   * is <code>joined</code> to this Channel\n   * @typedef {('unknown' | 'notParticipating' | 'invited' | 'joined')} Channel#Status\n   */\n\n  /**\n   * The type of Channel (<code>public</code> or <code>private</code>).\n   * @typedef {('public' | 'private')} Channel#Type\n   */\n\n  /**\n   * The User's Notification level for Channel, determines whether the currently logged-in User will receive\n   * pushes for events in this Channel. Can be either <code>muted</code> or <code>default</code>,\n   * where <code>default</code> defers to global Service push configuration.\n   * @typedef {('default' | 'muted')} Channel#NotificationLevel\n   */\n\n  public get status(): Channel.Status { return this.channelState.status; }\n\n  public get type(): Channel.Type { return this.channelState.type; }\n\n  public get uniqueName(): string { return this.channelState.uniqueName; }\n\n  public get isPrivate(): boolean { return this.channelState.type === 'private'; }\n\n  public get friendlyName(): string { return this.channelState.friendlyName; }\n\n  public get dateUpdated(): any { return this.channelState.dateUpdated; }\n\n  public get dateCreated(): any { return this.channelState.dateCreated; }\n\n  public get createdBy(): string { return this.channelState.createdBy; }\n\n  public get attributes(): Object { return this.channelState.attributes; }\n\n  public get lastConsumedMessageIndex(): number | null { return this.channelState.lastConsumedMessageIndex; }\n\n  public get lastMessage(): Channel.LastMessage { return this.channelState.lastMessage; }\n\n  public get notificationLevel(): Channel.NotificationLevel { return this.channelState.notificationLevel; }\n\n  public get state(): Channel.State { return this.channelState.state; }\n\n  /**\n   * The Channel's last message's information.\n   * @typedef {Object} Channel#LastMessage\n   * @property {Number} index - Message's index\n   * @property {Date} dateCreated - Message's creation date\n   */\n\n  /**\n   * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.\n   * This or _subscribeStreams will need to be called before any events on Channel will fire.\n   * @returns {Promise}\n   * @private\n   */\n  _subscribe() {\n    if (this.entityPromise) { return this.entityPromise; }\n\n    return this.entityPromise = this.entityPromise ||\n      this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' })\n        .then(entity => {\n          this.entity = entity;\n          this.entity.on('updated', args => { this._update(args.data); });\n          this.entity.on('removed', () => this.emit('removed', this));\n          this._update(this.entity.data);\n          return entity;\n        })\n        .catch(err => {\n          this.entity = null;\n          this.entityPromise = null;\n          if (this.services.syncClient.connectionState != 'disconnected') {\n            log.error('Failed to get channel object', err);\n          }\n          log.debug('ERROR: Failed to get channel object', err);\n          throw err;\n        });\n  }\n\n  /**\n   * Load the attributes of this Channel and instantiate its Members and Messages.\n   * This or _subscribe will need to be called before any events on Channel will fire.\n   * This will need to be called before any events on Members or Messages will fire\n   * @returns {Promise}\n   * @private\n   */\n  async _subscribeStreams() {\n    try {\n      await this._subscribe();\n      log.trace('_subscribeStreams, this.entity.data=', this.entity.data);\n      const messagesObjectName = this.entity.data.messages;\n      const rosterObjectName = this.entity.data.roster;\n      await Promise.all([\n        this.messagesEntity.subscribe(messagesObjectName),\n        this.membersEntity.subscribe(rosterObjectName)\n      ]);\n    } catch (err) {\n      if (this.services.syncClient.connectionState !== 'disconnected') {\n        log.error('Failed to subscribe on channel objects', this.sid, err);\n      }\n      log.debug('ERROR: Failed to subscribe on channel objects', this.sid, err);\n      throw err;\n    }\n  }\n\n  /**\n   * Stop listening for and firing events on this Channel.\n   * @returns {Promise}\n   * @private\n   */\n  async _unsubscribe() {\n    // Keep our subscription to public channels objects\n    if (this.isPrivate && this.entity) {\n      await this.entity.close();\n      this.entity = null;\n      this.entityPromise = null;\n    }\n\n    return Promise.all([\n      this.membersEntity.unsubscribe(),\n      this.messagesEntity.unsubscribe()\n    ]);\n  }\n\n  /**\n   * Set channel status\n   * @private\n   */\n  _setStatus(status: Channel.Status, source: Channels.DataSource) {\n    this.statusSource = source;\n\n    if (this.channelState.status === status) { return; }\n\n    this.channelState.status = status;\n\n    if (status === 'joined') {\n      this._subscribeStreams()\n          .catch(err => {\n            log.debug('ERROR while setting channel status ' + status, err);\n            if (this.services.syncClient.connectionState !== 'disconnected') {\n              throw err;\n            }\n          });\n    } else if (status === 'invited') {\n      this._subscribe()\n          .catch(err => {\n            log.debug('ERROR while setting channel status ' + status, err);\n            if (this.services.syncClient.connectionState !== 'disconnected') {\n              throw err;\n            }\n          });\n    } else if (this.entityPromise) {\n      this._unsubscribe().catch(err => {\n        log.debug('ERROR while setting channel status ' + status, err);\n        if (this.services.syncClient.connectionState !== 'disconnected') {\n          throw err;\n        }\n      });\n    }\n  }\n\n  /**\n   * If channel's status update source\n   * @private\n   * @return {Channels.DataSource}\n   */\n  _statusSource(): Channels.DataSource {\n    return this.statusSource;\n  }\n\n  private static preprocessUpdate(update, channelSid) {\n    try {\n      if (typeof update.attributes === 'string') {\n        update.attributes = JSON.parse(update.attributes);\n      } else if (update.attributes) {\n        JSON.stringify(update.attributes);\n      }\n    } catch (e) {\n      log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);\n      update.attributes = {};\n    }\n\n    try {\n      if (update.dateCreated) {\n        update.dateCreated = new Date(update.dateCreated);\n      }\n    } catch (e) {\n      log.warn('Retrieved malformed dateCreated from the server for channel: ' + channelSid);\n      delete update.dateCreated;\n    }\n\n    try {\n      if (update.dateUpdated) {\n        update.dateUpdated = new Date(update.dateUpdated);\n      }\n    } catch (e) {\n      log.warn('Retrieved malformed dateUpdated from the server for channel: ' + channelSid);\n      delete update.dateUpdated;\n    }\n\n    try {\n      if (update.lastMessage && update.lastMessage.timestamp) {\n        update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);\n      }\n    } catch (e) {\n      log.warn('Retrieved malformed lastMessage.timestamp from the server for channel: ' + channelSid);\n      delete update.lastMessage.timestamp;\n    }\n  }\n\n  /**\n   * Updates local channel object with new values\n   * @private\n   */\n  _update(update) {\n    log.trace('_update', update);\n\n    Channel.preprocessUpdate(update, this.sid);\n    const updateReasons = new Set<Channel.UpdateReason>();\n\n    for (const key of Object.keys(update)) {\n      const localKey = fieldMappings[key];\n\n      if (!localKey) {\n        continue;\n      }\n\n      switch (localKey) {\n        case fieldMappings.status:\n          if (!update.status || update.status === 'unknown'\n            || this.channelState.status === update.status) {\n            break;\n          }\n\n          this.channelState.status = update.status;\n          updateReasons.add(localKey);\n\n          break;\n        case fieldMappings.attributes:\n          if (isDeepEqual(this.channelState.attributes, update.attributes)) {\n            break;\n          }\n\n          this.channelState.attributes = update.attributes;\n          updateReasons.add(localKey);\n\n          break;\n        case fieldMappings.lastConsumedMessageIndex:\n          if (update.lastConsumedMessageIndex === undefined\n            || update.lastConsumedMessageIndex === this.channelState.lastConsumedMessageIndex) {\n            break;\n          }\n\n          this.channelState.lastConsumedMessageIndex = update.lastConsumedMessageIndex;\n          updateReasons.add(localKey);\n\n          break;\n        case fieldMappings.lastMessage:\n          if (this.channelState.lastMessage && !update.lastMessage) {\n            delete this.channelState.lastMessage;\n            updateReasons.add(localKey);\n\n            break;\n          }\n\n          this.channelState.lastMessage = this.channelState.lastMessage || {};\n\n          if (update.lastMessage?.index !== undefined\n            && update.lastMessage.index !== this.channelState.lastMessage.index) {\n            this.channelState.lastMessage.index = update.lastMessage.index;\n            updateReasons.add(localKey);\n          }\n\n          if (update.lastMessage?.timestamp !== undefined\n            && this.channelState.lastMessage?.dateCreated?.getTime() !== update.lastMessage.timestamp.getTime()) {\n            this.channelState.lastMessage.dateCreated = update.lastMessage.timestamp;\n            updateReasons.add(localKey);\n          }\n\n          if (isDeepEqual(this.channelState.lastMessage, {})) {\n            delete this.channelState.lastMessage;\n          }\n\n          break;\n        case fieldMappings.state:\n          const state = update.state || undefined;\n\n          if (state !== undefined) {\n            state.dateUpdated = new Date(state.dateUpdated);\n          }\n\n          if (isDeepEqual(this.channelState.state, state)) {\n            break;\n          }\n\n          this.channelState.state = state;\n          updateReasons.add(localKey);\n\n          break;\n        default:\n          const isDate = update[key] instanceof Date;\n          const keysMatchAsDates = isDate && this.channelState[localKey]?.getTime() === update[key].getTime();\n          const keysMatchAsNonDates = !isDate && this[localKey] === update[key];\n\n          if (keysMatchAsDates || keysMatchAsNonDates) {\n            break;\n          }\n\n          this.channelState[localKey] = update[key];\n          updateReasons.add(localKey);\n      }\n    }\n\n    if (updateReasons.size > 0) {\n      this.emit('updated', { channel: this, updateReasons: [...updateReasons] });\n    }\n  }\n\n  /**\n   * @private\n   */\n  private _onMessageAdded(message) {\n    for (let member of this.members.values()) {\n      if (member.identity === message.author) {\n        member._endTyping();\n        break;\n      }\n    }\n    this.emit('messageAdded', message);\n  }\n\n  private async _setLastConsumedMessageIndex(index: number | null): Promise<number> {\n    const result = await this.services.commandExecutor.mutateResource<\n      EditLastConsumedMessageIndexRequest,\n      EditLastConsumedMessageIndexResponse\n    >(\n      'post',\n      `${this.configuration.links.myConversations}/${this.sid}`,\n      {\n        last_consumed_message_index: index\n      }\n    );\n\n    return result.unread_messages_count;\n  }\n\n  /**\n   * Add a participant to the Channel by its Identity.\n   * @param {String} identity - Identity of the Client to add\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async add(identity: string): Promise<void> {\n    await this.membersEntity.add(identity);\n  }\n\n  /**\n   * Advance last consumed Channel's Message index to current consumption horizon.\n   * Rejects if User is not Member of Channel.\n   * Last consumed Message index is updated only if new index value is higher than previous.\n   * @param {Number} index - Message index to advance to as last read\n   * @returns {Promise<number>} resulting unread messages count in the channel\n   */\n  @validateTypesAsync(nonNegativeInteger)\n  async advanceLastConsumedMessageIndex(index: number): Promise<number> {\n    await this._subscribeStreams();\n\n    if (index < this.lastConsumedMessageIndex) {\n      return await this._setLastConsumedMessageIndex(this.lastConsumedMessageIndex);\n    }\n\n    return await this._setLastConsumedMessageIndex(index);\n  }\n\n  /**\n   * Decline an invitation to the Channel and unsubscribe from its events.\n   * @returns {Promise<Channel>}\n   */\n  async decline(): Promise<Channel> {\n    await this.services.commandExecutor.mutateResource(\n      'delete',\n      `${this.links.invites}/${this.configuration.userIdentity}`\n    );\n\n    return this;\n  }\n\n  /**\n   * Delete the Channel and unsubscribe from its events.\n   * @returns {Promise<Channel>}\n   */\n  async delete(): Promise<Channel> {\n    await this.services.commandExecutor.mutateResource(\n      'delete',\n      this.links.self,\n    );\n\n    return this;\n  }\n\n  /**\n   * Get the custom attributes of this Channel.<br/>\n   *\n   * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>\n   * @returns {Promise<any>} attributes of this Channel\n   */\n  async getAttributes(): Promise<any> {\n    await this._subscribe();\n    return this.attributes;\n  }\n\n  /**\n   * Returns messages from channel using paginator interface.\n   * @param {Number} [pageSize=30] Number of messages to return in single chunk\n   * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default\n   * @param {('backwards'|'forward')} [direction=backwards] - Query direction. By default it query backwards\n   *                                                          from newer to older. 'forward' will query in opposite direction\n   * @returns {Promise<Paginator<Message>>} page of messages\n   */\n  @validateTypesAsync(\n    ['undefined', nonNegativeInteger],\n    ['undefined', nonNegativeInteger],\n    ['undefined', literal('backwards', 'forward')]\n  )\n  async getMessages(pageSize?: number, anchor?: number, direction?: 'backwards' | 'forward'): Promise<Paginator<Message>> {\n    await this._subscribeStreams();\n    return this.messagesEntity.getMessages(pageSize, anchor, direction);\n  }\n\n  /**\n   * Get a list of all Members joined to this Channel.\n   * @returns {Promise<Member[]>}\n   */\n  async getMembers(): Promise<Member[]> {\n    await this._subscribeStreams();\n    return this.membersEntity.getMembers();\n  }\n\n  /**\n   * Get channel members count.\n   * <br/>\n   * This method is semi-realtime. This means that this data will be eventually correct,\n   * but will also possibly be incorrect for a few seconds. The Chat system does not\n   * provide real time events for counter values changes.\n   * <br/>\n   * So this is quite useful for any UI badges, but is not recommended\n   * to build any core application logic based on these counters being accurate in real time.\n   * @returns {Promise<number>}\n   */\n  async getMembersCount(): Promise<number> {\n    const url = new UriBuilder(this.configuration.links.conversations).path(this.sid).build();\n    const response = await this.services.network.get(url);\n\n    return response.body.participants_count;\n  }\n\n  /**\n   * Get a Member by its SID.\n   * @param {String} memberSid - Member sid\n   * @returns {Promise<Member>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getMemberBySid(memberSid: string): Promise<Member> {\n    return this.membersEntity.getMemberBySid(memberSid);\n  }\n\n  /**\n   * Get a Member by its identity.\n   * @param {String} identity - Member identity\n   * @returns {Promise<Member>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getMemberByIdentity(identity: string): Promise<Member> {\n    return this.membersEntity.getMemberByIdentity(identity);\n  }\n\n  /**\n   * Get total message count in a channel.\n   * <br/>\n   * This method is semi-realtime. This means that this data will be eventually correct,\n   * but will also possibly be incorrect for a few seconds. The Chat system does not\n   * provide real time events for counter values changes.\n   * <br/>\n   * So this is quite useful for any UI badges, but is not recommended\n   * to build any core application logic based on these counters being accurate in real time.\n   * @returns {Promise<number>}\n   */\n  async getMessagesCount(): Promise<number> {\n    const url = new UriBuilder(this.configuration.links.conversations).path(this.sid).build();\n    const response = await this.services.network.get(url);\n\n    return response.body.messages_count;\n  }\n\n  /**\n   * Get unconsumed messages count for a User if they are a Member of this Channel.\n   * Rejects if the User is not a Member of the Channel.\n   * <br/>\n   * This method is semi-realtime. This means that this data will be eventually correct,\n   * but will also possibly be incorrect for a few seconds. The Chat system does not\n   * provide real time events for counter values changes.\n   * <br/>\n   * So this is quite useful for any “unread messages count” badges, but is not recommended\n   * to build any core application logic based on these counters being accurate in real time.\n   * @returns {Promise<number|null>}\n   */\n  async getUnconsumedMessagesCount(): Promise<number | null> {\n    const url = new UriBuilder(this.configuration.links.myConversations).path(this.sid).build();\n    const response = await this.services.network.get(url);\n\n    if (response.body.conversation_sid !== this.sid) {\n      throw new Error('Channel was not found in the user channels list');\n    }\n\n    const unreadMessageCount = response.body.unread_messages_count;\n\n    if (typeof unreadMessageCount === 'number') {\n      return unreadMessageCount;\n    }\n\n    return null;\n  }\n\n  /**\n   * Invite a user to the Channel by their Identity.\n   * @param {String} identity - Identity of the user to invite\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async invite(identity: string): Promise<void> {\n    await this.membersEntity.invite(identity);\n  }\n\n  /**\n   * Join the Channel and subscribe to its events.\n   * @returns {Promise<Channel>}\n   */\n  async join(): Promise<Channel> {\n    await this.services.commandExecutor.mutateResource<JoinChannelRequest, JoinChannelResponse>(\n      'post',\n      this.links.participants,\n      {\n        identity: this.configuration.userIdentity\n      }\n    );\n\n    return this;\n  }\n\n  /**\n   * Leave the Channel.\n   * @returns {Promise<Channel>}\n   */\n  async leave(): Promise<Channel> {\n    if (this.channelState.status === 'joined') {\n      await this.services.commandExecutor.mutateResource(\n        'delete',\n        `${this.links.participants}/${this.configuration.userIdentity}`,\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Remove a Member from the Channel.\n   * @param {String|Member} member - Member to remove. Could either be an identity string or a Member instance.\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync([nonEmptyString, Member])\n  async removeMember(member: string | Member): Promise<void> {\n    await this.membersEntity.remove(typeof member === 'string' ? member : member.sid);\n  }\n\n  /**\n   * Send a Message in the Channel.\n   * @param {String|FormData|Channel#SendMediaOptions|null} message - The message body for text message,\n   * FormData or MediaOptions for media content. Sending FormData supported only with browser engine\n   * @param {any} [messageAttributes] - attributes for the message\n   * @returns {Promise<number>} new Message's index in the Channel's messages list\n   */\n  @validateTypesAsync(\n    [\n      'string',\n      literal(null),\n      // Wrapping it into a custom rule is necessary because the FormData class is not available on initialization.\n      custom((value) => [value instanceof FormData, 'an instance of FormData']),\n      objectSchema('media options', {\n        contentType: [nonEmptyString, 'undefined'],\n        media: custom((value) => {\n          let isValid = (typeof value === 'string' && value.length > 0) || value instanceof Uint8Array || value instanceof ArrayBuffer;\n\n          if (typeof Blob === 'function') {\n            isValid = isValid || value instanceof Blob;\n          }\n\n          return [\n            isValid,\n            'a non-empty string, an instance of Buffer or an instance of Blob'\n          ];\n        })\n      })\n    ],\n    ['undefined', 'string', 'number', 'boolean', 'object', literal(null)]\n  )\n  async sendMessage(message: string | FormData | Channel.SendMediaOptions | null, messageAttributes?: any): Promise<number> {\n    if (typeof message === 'string' || message === null) {\n      const response = await this.messagesEntity.send(message, messageAttributes);\n      return parseToNumber(response.index);\n    }\n\n    const response = await this.messagesEntity.sendMedia(message, messageAttributes);\n    return parseToNumber(response.index);\n  }\n\n  /**\n   * Set last consumed Channel's Message index to last known Message's index in this Channel.\n   * @returns {Promise<number>} resulting unread messages count in the channel\n   */\n  async setAllMessagesConsumed(): Promise<number> {\n    await this._subscribeStreams();\n    let messagesPage = await this.getMessages(1);\n    if (messagesPage.items.length > 0) {\n      return this.advanceLastConsumedMessageIndex(messagesPage.items[0].index);\n    }\n    return Promise.resolve(0);\n  }\n\n  /**\n   * Set all messages in the channel unread.\n   * @returns {Promise<number>} resulting unread messages count in the channel\n   */\n  async setNoMessagesConsumed(): Promise<number> {\n    await this._subscribeStreams();\n    return await this._setLastConsumedMessageIndex(null);\n  }\n\n  /**\n   * Set User Notification level for this channel.\n   * @param {Channel#NotificationLevel} notificationLevel - The new user notification level\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(literal('default', 'muted'))\n  async setUserNotificationLevel(notificationLevel: Channel.NotificationLevel): Promise<void> {\n    await this.services.commandExecutor.mutateResource<EditNotificationLevelRequest>(\n      'post',\n      `${this.configuration.links.myConversations}/${this.sid}`,\n      {\n        notification_level: notificationLevel\n      }\n    );\n  }\n\n  /**\n   * Send a notification to the server indicating that this Client is currently typing in this Channel.\n   * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.\n   * @returns {Promise<void>}\n   */\n  typing(): Promise<void> {\n    return this.services.typingIndicator.send(this.sid);\n  }\n\n  /**\n   * Update the Channel's attributes.\n   * @param {any} attributes new attributes for Channel.\n   * @returns {Promise<Channel>}\n   */\n  @validateTypesAsync(['string', 'number', 'boolean', 'object', literal(null)])\n  async updateAttributes(attributes: any): Promise<Channel> {\n    await this.services.commandExecutor.mutateResource<EditChannelRequest, ChannelResponse>(\n      'post',\n      this.links.self,\n      { attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined }\n    );\n\n    return this;\n  }\n\n  /**\n   * Update the Channel's friendlyName.\n   * @param {String} friendlyName - The new Channel friendlyName\n   * @returns {Promise<Channel>}\n   */\n  @validateTypesAsync('string')\n  async updateFriendlyName(friendlyName: string): Promise<Channel> {\n    if (this.channelState.friendlyName !== friendlyName) {\n      await this.services.commandExecutor.mutateResource<EditChannelRequest, ChannelResponse>(\n        'post',\n        this.links.self,\n        { friendly_name: friendlyName }\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Set last consumed Channel's Message index to current consumption horizon.\n   * @param {Number|null} index - Message index to set as last read.\n   * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}\n   * @returns {Promise<number>} resulting unread messages count in the channel\n   */\n  @validateTypesAsync([literal(null), nonNegativeInteger])\n  async updateLastConsumedMessageIndex(index: number | null): Promise<number> {\n    await this._subscribeStreams();\n    return this._setLastConsumedMessageIndex(index);\n  }\n\n  /**\n   * Update the Channel's unique name.\n   * @param {String|null} uniqueName - New unique name for the Channel. Setting unique name to null removes it.\n   * @returns {Promise<Channel>}\n   */\n  @validateTypesAsync(['string', literal(null)])\n  async updateUniqueName(uniqueName: string | null): Promise<Channel> {\n    if (this.channelState.uniqueName !== uniqueName) {\n      if (!uniqueName) {\n        uniqueName = '';\n      }\n\n      await this.services.commandExecutor.mutateResource<EditChannelRequest, ChannelResponse>(\n        'post',\n        this.links.self,\n        { unique_name: uniqueName }\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Gets User Descriptors for this channel.\n   * @returns {Promise<Paginator<UserDescriptor>>}\n   */\n  async getUserDescriptors(): Promise<Paginator<UserDescriptor>> {\n    return this.services.users.getChannelUserDescriptors(this.sid);\n  }\n}\n\nexport { ChannelDescriptor, Channel };\n\n/**\n * Fired when a Member has joined the Channel.\n * @event Channel#memberJoined\n * @type {Member}\n */\n/**\n * Fired when a Member has left the Channel.\n * @event Channel#memberLeft\n * @type {Member}\n */\n/**\n * Fired when a Member's fields has been updated.\n * @event Channel#memberUpdated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n/**\n * Fired when a new Message has been added to the Channel.\n * @event Channel#messageAdded\n * @type {Message}\n */\n/**\n * Fired when Message is removed from Channel's message list.\n * @event Channel#messageRemoved\n * @type {Message}\n */\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Channel#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n/**\n * Fired when a Member has stopped typing.\n * @event Channel#typingEnded\n * @type {Member}\n */\n/**\n * Fired when a Member has started typing.\n * @event Channel#typingStarted\n * @type {Member}\n */\n/**\n * Fired when a Channel's attributes or metadata have been updated.\n * During Channel's {@link Client.create | creation and initialization} this event might be fired multiple times\n * for same joined or created Channel as new data is arriving from different sources.\n * @event Channel#updated\n * @type {Object}\n * @property {Channel} channel - Updated Channel\n * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons\n */\n/**\n * Fired when the Channel was destroyed or currently logged in User has left private Channel\n * @event Channel#removed\n * @type {Channel}\n */\n","class Deferred<T> {\n  private _promise: Promise<T>;\n  private _resolve;\n  private _reject;\n\n  public current: T;\n\n  constructor() {\n    this._promise = new Promise<T>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  public get promise(): Promise<T> { return this._promise; }\n\n  update(value: T) {\n    this._resolve(value);\n  }\n\n  set(value: T) {\n    this.current = value;\n    this._resolve(value);\n  }\n\n  fail(e) {\n    this._reject(e);\n  }\n}\n\nexport { Deferred };\n","import { EventEmitter } from 'events';\nimport { Logger } from '../logger';\nimport { Channel } from '../channel';\n\nimport { SyncMap, SyncClient } from 'twilio-sync';\nimport { ChannelDescriptor } from '../channeldescriptor';\nimport { Users } from './users';\nimport { Network } from '../services/network';\nimport { TypingIndicator } from '../services/typingindicator';\nimport { McsClient } from 'twilio-mcs-client';\nimport { Deferred } from '../util/deferred';\nimport { Member } from '../member';\nimport { Message } from '../message';\nimport { isDeepEqual, UriBuilder } from '../util';\nimport { Configuration } from '../configuration';\nimport { CommandExecutor } from '../commandexecutor';\nimport { CreateChannelRequest } from '../interfaces/commands/createchannel';\nimport { ChannelResponse } from '../interfaces/commands/channel';\n\nconst log = Logger.scope('Channels');\n\nexport interface ChannelsServices {\n  syncClient: SyncClient;\n  users: Users;\n  typingIndicator: TypingIndicator;\n  network: Network;\n  mcsClient: McsClient;\n  commandExecutor: CommandExecutor;\n}\n\n/**\n * Represents channels collection\n * {@see Channel}\n */\nclass Channels extends EventEmitter {\n\n  public readonly channels: Map<string, Channel> = new Map<string, Channel>();\n  private readonly tombstones: Set<string> = new Set<string>();\n  private myChannelsFetched = false;\n  private myChannelsRead: Deferred<boolean> = new Deferred<boolean>();\n\n  constructor(\n    private readonly configuration: Configuration,\n    private readonly services: ChannelsServices\n  ) {\n    super();\n  }\n\n  private async getMap(): Promise<SyncMap> {\n    return await this.services.syncClient.map({\n      id: this.configuration.myConversations,\n      mode: 'open_existing'\n    });\n  }\n\n  /**\n   * Add channel to server\n   * @private\n   * @returns {Promise<Channel>} Channel\n   */\n  async addChannel(options): Promise<Channel> {\n    let attributes;\n    if (typeof options.attributes === 'undefined') {\n      attributes = {};\n    } else {\n      attributes = options.attributes;\n    }\n\n    const response = await this.services.commandExecutor.mutateResource<CreateChannelRequest, ChannelResponse>(\n      'post',\n      this.configuration.links.conversations,\n      {\n        type: options.isPrivate ? 'private' : 'public',\n        unique_name: options.uniqueName,\n        friendly_name: options.friendlyName,\n        attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined,\n      }\n    );\n\n    const channelSid = response.sid || null;\n    const channelDocument = response.sync_objects.conversation || null;\n    const links = {\n      self: response.url,\n      ...response.links\n    };\n\n    let existingChannel = this.channels.get(channelSid);\n    if (existingChannel) {\n      await existingChannel._subscribe();\n      return existingChannel;\n    }\n\n    let channel = new Channel(\n      {\n        channel: channelDocument,\n\n        entityName: null,\n        uniqueName: null,\n        attributes: null,\n        createdBy: null,\n        friendlyName: null,\n        lastConsumedMessageIndex: null,\n        type: options.isPrivate ? 'private' : 'public',\n        dateCreated: null,\n        dateUpdated: null\n      },\n      channelSid,\n      links,\n      this.configuration,\n      this.services\n    );\n\n    this.channels.set(channel.sid, channel);\n    this.registerForEvents(channel);\n\n    await channel._subscribe();\n    this.emit('channelAdded', channel);\n    return channel;\n  }\n\n  /**\n   * Fetch channels list and instantiate all necessary objects\n   */\n  async fetchChannels() {\n    try {\n      const map = await this.getMap();\n\n      map.on('itemAdded', args => {\n        log.debug(`itemAdded: ${args.item.key}`);\n        this.upsertChannel('sync', args.item.key, args.item.data);\n      });\n\n      map.on('itemRemoved', args => {\n        log.debug(`itemRemoved: ${args.key}`);\n        const sid = args.key;\n\n        if (!this.myChannelsFetched) {\n          this.tombstones.add(sid);\n        }\n\n        const channel = this.channels.get(sid);\n\n        if (!channel) {\n          return;\n        }\n\n        if (channel.status === 'joined' || channel.status === 'invited') {\n          channel._setStatus('notParticipating', 'sync');\n          this.emit('channelLeft', channel);\n        }\n\n        if (channel.isPrivate) {\n          this.channels.delete(sid);\n          this.emit('channelRemoved', channel);\n          channel.emit('removed', channel);\n        }\n      });\n\n      map.on('itemUpdated', args => {\n        log.debug(`itemUpdated: ${args.item.key}`);\n        this.upsertChannel('sync', args.item.key, args.item.data);\n      });\n\n      const myChannels = await this._fetchMyChannels();\n      const upserts = [];\n\n      for (const channel of myChannels) {\n        upserts.push(this.upsertChannel('rest', channel.channel_sid, channel));\n      }\n\n      this.myChannelsRead.set(true);\n\n      await Promise.all(upserts);\n\n      this.myChannelsFetched = true;\n      this.tombstones.clear();\n\n      log.debug('The channels list has been successfully fetched');\n\n      return this;\n    } catch (error) {\n      const errorMessage = 'Failed to fetch the channels list';\n\n      if (this.services.syncClient.connectionState !== 'disconnected') {\n        log.error(errorMessage, error);\n      }\n\n      log.debug(`ERROR: ${errorMessage}`, error);\n\n      throw error;\n    }\n  }\n\n  private _wrapPaginator(page, op) {\n    return op(page.items)\n      .then(items => ({\n        items: items,\n        hasNextPage: page.hasNextPage,\n        hasPrevPage: page.hasPrevPage,\n        nextPage: () => page.nextPage().then(x => this._wrapPaginator(x, op)),\n        prevPage: () => page.prevPage().then(x => this._wrapPaginator(x, op))\n      }));\n  }\n\n  getChannels(args) {\n    return this.getMap()\n               .then(channelsMap => channelsMap.getItems(args))\n               .then(page => this._wrapPaginator(page\n                 , items => Promise.all(items.map(item => this.upsertChannel('sync', item.key, item.data))))\n               );\n  }\n\n  getChannel(sid: string): Promise<Channel> {\n    return this.getMap()\n               .then(channelsMap => channelsMap.getItems({ key: sid }))\n               .then(page => page.items.map(item => this.upsertChannel('sync', item.key, item.data)))\n               .then(items => items.length > 0 ? items[0] : null);\n  }\n\n  pushChannel(descriptor: ChannelDescriptor): Promise<Channel> {\n    const sid = descriptor.sid;\n    const data = {\n      entityName: null,\n      lastConsumedMessageIndex: descriptor.lastConsumedMessageIndex,\n      type: descriptor.type,\n      status: descriptor.status,\n      friendlyName: descriptor.friendlyName,\n      dateUpdated: descriptor.dateUpdated,\n      dateCreated: descriptor.dateCreated,\n      uniqueName: descriptor.uniqueName,\n      createdBy: descriptor.createdBy,\n      attributes: descriptor.attributes,\n      channel: descriptor.channel,\n      notificationLevel: descriptor.notificationLevel,\n      sid: sid\n    };\n\n    return this.upsertChannel('chat', sid, data);\n  }\n\n  private _updateChannel(source: Channels.DataSource, channel: Channel, data): void {\n    const areSourcesDifferent = channel._statusSource() !== undefined && source !== channel._statusSource();\n    const isChannelSourceSync = source !== 'rest' || channel._statusSource() === 'sync';\n\n    if (areSourcesDifferent && isChannelSourceSync && source !== 'sync') {\n      log.trace('upsertChannel: the channel is known from sync and it came from chat, ignoring', {\n        sid: channel.sid,\n        data: data.status,\n        channel: channel.status\n      });\n\n      return;\n    }\n\n    if (['joined', 'invited'].includes(data.status) && channel.status !== data.status) {\n      channel._setStatus(data.status, source);\n\n      let updateData: any = {};\n\n      if (data.notificationLevel !== undefined) {\n        updateData.notificationLevel = data.notificationLevel;\n      }\n\n      if (data.lastConsumedMessageIndex !== undefined) {\n        updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;\n      }\n\n      if (!isDeepEqual(updateData, {})) {\n        channel._update(updateData);\n      }\n\n      channel._subscribe().then(() => {\n        this.emit(data.status === 'joined' ? 'channelJoined' : 'channelInvited', channel);\n      });\n\n      return;\n    }\n\n    if (['joined', 'invited'].includes(channel.status) && data.status === 'notParticipating') {\n      channel._setStatus('notParticipating', source);\n      channel._update(data);\n      channel._subscribe().then(() => {\n        this.emit('channelLeft', channel);\n      });\n\n      return;\n    }\n\n    if (data.type === 'private' && data.status === 'notParticipating') {\n      channel._subscribe();\n\n      return;\n    }\n\n    channel._update(data);\n  }\n\n  private upsertChannel(source: Channels.DataSource, sid: string, data): Promise<Channel> {\n    log.trace(`upsertChannel called for ${sid}`, data);\n    const channel = this.channels.get(sid);\n\n    // If the channel is known, update it\n    if (channel) {\n      log.trace(\n        `upsertChannel: the channel ${channel.sid} is known;` +\n        `its status is known from source ${channel._statusSource()} ` +\n        `and the update came from source ${source}`,\n        channel\n      );\n      this._updateChannel(source, channel, data);\n\n      return channel._subscribe().then(() => channel);\n    }\n\n    // If the channel is deleted, ignore it\n    if (['chat', 'rest'].includes(source) && this.tombstones.has(sid)) {\n      log.trace('upsertChannel: the channel is deleted but reappeared again from chat, ignoring', sid);\n\n      return;\n    }\n\n    // If the channel is unknown, fetch it\n    log.trace(`upsertChannel: creating a local channel object with sid ${sid}`, data);\n    const baseLink = `${this.configuration.links.conversations}/${sid}`;\n    const links = {\n      self: baseLink,\n      messages: `${baseLink}/Messages`,\n      participants: `${baseLink}/Participants`,\n      invites: `${baseLink}/Invites`\n    };\n    const newChannel = new Channel(data, sid, links, this.configuration, this.services);\n    this.channels.set(sid, newChannel);\n\n    return newChannel._subscribe().then(() => {\n      this.registerForEvents(newChannel);\n      this.emit('channelAdded', newChannel);\n\n      if (['joined', 'invited'].includes(data.status)) {\n        newChannel._setStatus(data.status, source);\n        this.emit(data.status === 'joined' ? 'channelJoined' : 'channelInvited', newChannel);\n      }\n\n      return newChannel;\n    });\n  }\n\n  private onChannelRemoved(sid: string) {\n    let channel = this.channels.get(sid);\n    if (channel) {\n      this.channels.delete(sid);\n      this.emit('channelRemoved', channel);\n    }\n  }\n\n  private registerForEvents(channel) {\n    channel.on('removed', () => this.onChannelRemoved(channel.sid));\n    channel.on('updated', (args: Channel.UpdatedEventArgs) => this.emit('channelUpdated', args));\n    channel.on('memberJoined', this.emit.bind(this, 'memberJoined'));\n    channel.on('memberLeft', this.emit.bind(this, 'memberLeft'));\n    channel.on('memberUpdated', (args: Member.UpdatedEventArgs) => this.emit('memberUpdated', args));\n    channel.on('messageAdded', this.emit.bind(this, 'messageAdded'));\n    channel.on('messageUpdated', (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n    channel.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n    channel.on('typingStarted', this.emit.bind(this, 'typingStarted'));\n    channel.on('typingEnded', this.emit.bind(this, 'typingEnded'));\n  }\n\n  private async _fetchMyChannels() {\n    let channels = [];\n    let pageToken: null | string = null;\n\n    do {\n      const url = new UriBuilder(this.configuration.links.myConversations);\n\n      if (pageToken) {\n        url.arg('PageToken', pageToken);\n      }\n\n      const response = await this.services.network.get(url.build());\n      const preProcessedChannels = response.body.conversations.map(\n        (channelDescriptor) => ({\n          descriptor: channelDescriptor,\n          channel_sid: channelDescriptor.conversation_sid,\n          status: channelDescriptor.status,\n          channel: channelDescriptor.sync_objects.conversation,\n          messages: channelDescriptor.sync_objects.messages,\n          roster: `${channelDescriptor.conversation_sid}.roster`,\n          lastConsumedMessageIndex: channelDescriptor.last_consumed_message_index,\n          notificationLevel: channelDescriptor.notification_level\n        })\n      );\n\n      pageToken = response.body.meta.next_token;\n      channels = [...channels, ...preProcessedChannels];\n    } while (pageToken);\n\n    return channels;\n  }\n}\n\nnamespace Channels {\n  export type DataSource = 'sync' | 'chat' | 'rest';\n}\n\nexport { Channel, Channels };\n","import { EventEmitter } from 'events';\n\nimport { Logger } from './logger';\nimport { SyncClient } from 'twilio-sync';\nimport { isDeepEqual, parseAttributes } from './util';\nimport { validateTypesAsync, literal } from 'twilio-sdk-type-validator';\nimport { Configuration } from './configuration';\nimport { CommandExecutor } from './commandexecutor';\nimport { EditUserRequest, EditUserResponse } from './interfaces/commands/edituser';\n\nconst log = Logger.scope('User');\n\ninterface UserState {\n  identity: string;\n  entityName: string;\n  friendlyName: string;\n  attributes: any;\n  online: boolean;\n  notifiable: boolean;\n}\n\nexport interface UserServices {\n  syncClient: SyncClient;\n  commandExecutor: CommandExecutor;\n}\n\ninterface UserLinks {\n  self: string;\n}\n\nnamespace User {\n  export type SubscriptionState = 'initializing' | 'subscribed' | 'unsubscribed';\n\n  export type UpdateReason = 'friendlyName' | 'attributes' | 'online' | 'notifiable';\n\n  export interface UpdatedEventArgs {\n    user: User;\n    updateReasons: User.UpdateReason[];\n  }\n}\n\n/**\n * @classdesc Extended user information.\n * Note that <code>online</code> and <code>notifiable</code> properties are eligible\n * to use only if reachability function is enabled.\n * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.\n *\n * @property {String} identity - User identity\n * @property {String} friendlyName - User friendly name, null if not set\n * @property {any} attributes - Object with custom attributes for user\n * @property {Boolean} online - User real-time channel connection status\n * @property {Boolean} notifiable - User push notification registration status\n * @property {Boolean} isSubscribed - Check if this user receives real-time status updates\n *\n * @fires User#updated\n * @fires User#userSubscribed\n * @fires User#userUnsubscribed\n *\n * @constructor\n * @param {String} identity - Identity of user\n * @param {String} entityId - id of user's object\n * @param {Object} datasync - datasync service\n */\nclass User extends EventEmitter {\n\n  private entity: any;\n  private state: UserState;\n  private promiseToFetch: Promise<User>;\n  private subscribed: User.SubscriptionState;\n\n  constructor(\n    identity: string,\n    entityName: string,\n    private readonly links: UserLinks,\n    private readonly configuration: Configuration,\n    private readonly services: UserServices\n  ) {\n    super();\n\n    this.subscribed = 'initializing';\n    this.setMaxListeners(0);\n\n    this.state = {\n      identity,\n      entityName,\n      friendlyName: null,\n      attributes: {},\n      online: null,\n      notifiable: null\n    };\n  }\n\n  /**\n   * The update reason for <code>updated</code> event emitted on User\n   * @typedef {('friendlyName' | 'attributes' | 'online' | 'notifiable')} User#UpdateReason\n   */\n\n  public get identity(): string { return this.state.identity; }\n\n  public set identity(identity: string) { this.state.identity = identity; }\n\n  public set entityName(name: string) { this.state.entityName = name; }\n\n  public get attributes() { return this.state.attributes; }\n\n  public get friendlyName(): string { return this.state.friendlyName; }\n\n  public get online(): boolean { return this.state.online; }\n\n  public get notifiable(): boolean { return this.state.notifiable; }\n\n  public get isSubscribed(): boolean { return this.subscribed == 'subscribed'; }\n\n  // Handles service updates\n  _update(key: string, value: any) {\n    let updateReasons: User.UpdateReason[] = [];\n    log.debug('User for', this.state.identity, 'updated:', key, value);\n    switch (key) {\n      case 'friendlyName':\n        if (this.state.friendlyName !== value.value) {\n          updateReasons.push('friendlyName');\n          this.state.friendlyName = value.value;\n        }\n        break;\n      case 'attributes':\n        const updateAttributes = parseAttributes(value.value, `Retrieved malformed attributes from the server for user: ${this.state.identity}`, log);\n        if (!isDeepEqual(this.state.attributes, updateAttributes)) {\n          this.state.attributes = updateAttributes;\n          updateReasons.push('attributes');\n        }\n        break;\n      case 'reachability':\n        if (this.state.online !== value.online) {\n          this.state.online = value.online;\n          updateReasons.push('online');\n        }\n        if (this.state.notifiable !== value.notifiable) {\n          this.state.notifiable = value.notifiable;\n          updateReasons.push('notifiable');\n        }\n        break;\n      default:\n        return;\n    }\n    if (updateReasons.length > 0) {\n      this.emit('updated', { user: this, updateReasons: updateReasons });\n    }\n  }\n\n  // Fetch reachability info\n  private async _updateReachabilityInfo(map, update) {\n    if (!this.configuration.reachabilityEnabled) {\n      return Promise.resolve();\n    }\n\n    return map.get('reachability')\n      .then(update)\n      .catch(err => { log.warn('Failed to get reachability info for ', this.state.identity, err); });\n  }\n\n  // Fetch user\n  async _fetch() {\n    if (!this.state.entityName) {\n      return this;\n    }\n\n    this.promiseToFetch = this.services.syncClient.map({ id: this.state.entityName, mode: 'open_existing', includeItems: true })\n                              .then(map => {\n                                this.entity = map;\n                                map.on('itemUpdated', args => {\n                                  log.debug(this.state.entityName + ' (' + this.state.identity + ') itemUpdated: ' + args.item.key);\n                                  return this._update(args.item.key, args.item.data);\n                                });\n                                return Promise.all([\n                                  map.get('friendlyName')\n                                     .then(item => this._update(item.key, item.data)),\n                                  map.get('attributes')\n                                     .then(item => this._update(item.key, item.data)),\n                                  this._updateReachabilityInfo(map,\n                                    item => this._update(item.key, item.data))\n                                ]);\n                              })\n                              .then(() => {\n                                log.debug('Fetched for', this.identity);\n                                this.subscribed = 'subscribed';\n                                this.emit('userSubscribed', this);\n                                return this;\n                              })\n                              .catch(err => {\n                                this.promiseToFetch = null;\n                                throw err;\n                              });\n    return this.promiseToFetch;\n  }\n\n  _ensureFetched() {\n    return this.promiseToFetch || this._fetch();\n  }\n\n  /**\n   * Updates user attributes.\n   * @param {any} attributes new attributes for User.\n   * @returns {Promise<User>}\n   */\n  @validateTypesAsync(['string', 'number', 'boolean', 'object', literal(null)])\n  public async updateAttributes(attributes: any): Promise<User> {\n    if (this.subscribed == 'unsubscribed') {\n      throw new Error('Can\\'t modify unsubscribed object');\n    }\n\n    await this.services.commandExecutor.mutateResource<EditUserRequest, EditUserResponse>(\n      'post',\n      this.links.self,\n      {\n        attributes: JSON.stringify(attributes)\n      }\n    );\n\n    return this;\n  }\n\n  /**\n   * Update Users friendlyName.\n   * @param {String} friendlyName - Updated friendlyName\n   * @returns {Promise<User>}\n   */\n  @validateTypesAsync('string')\n  public async updateFriendlyName(friendlyName): Promise<User> {\n    if (this.subscribed == 'unsubscribed') {\n      throw new Error('Can\\'t modify unsubscribed object');\n    }\n\n    await this.services.commandExecutor.mutateResource<EditUserRequest, EditUserResponse>(\n      'post',\n      this.links.self,\n      {\n        friendly_name: friendlyName\n      }\n    );\n\n    return this;\n  }\n\n  /**\n   * Removes User from subscription list.\n   * @returns {Promise<void>} Promise of completion\n   */\n  async unsubscribe(): Promise<void> {\n    if (this.promiseToFetch) {\n      await this.promiseToFetch;\n      this.entity.close();\n      this.promiseToFetch = null;\n      this.subscribed = 'unsubscribed';\n      this.emit('userUnsubscribed', this);\n    }\n  }\n}\n\nexport { User };\n\n/**\n * Fired when User's properties or reachability status have been updated.\n * @event User#updated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n/**\n * Fired when Client is subscribed to User.\n * @event User#userSubscribed\n * @type {User}\n */\n/**\n * Fired when Client is unsubscribed from this User.\n * @event User#userUnsubscribed\n * @type {User}\n */\n","import { Logger } from './logger';\nimport { User } from './user';\nimport { Users } from './data/users';\nimport { parseAttributes } from './util';\n\nconst log = Logger.scope('UserDescriptor');\n\nexport interface UserDescriptorServices {\n  users: Users;\n}\n\n/**\n * @classdesc Extended user information.\n * Note that <code>online</code> and <code>notifiable</code> properties are eligible\n * to use only if reachability function is enabled.\n * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.\n *\n * @property {String} identity - User identity\n * @property {String} friendlyName - User friendly name, null if not set\n * @property {any} attributes - Object with custom attributes for user\n * @property {Boolean} online - User real-time channel connection status\n * @property {Boolean} notifiable - User push notification registration status\n *\n * @constructor\n * @param {Users} users Users instance\n * @param {Object} descriptor User descriptor data object\n */\nclass UserDescriptor {\n\n  private services: UserDescriptorServices;\n  private descriptor: any;\n\n  public readonly identity: string;\n  public readonly friendlyName: string;\n  public readonly attributes: any;\n  public readonly online: boolean;\n  public readonly notifiable: boolean;\n\n  /**\n   * @param {UserDescriptorServices} services - services, needed for UserDescriptor\n   * @param {Object} descriptor User descriptor data object\n   * @private\n   */\n  constructor(services: UserDescriptorServices, descriptor: any) {\n    this.services = services;\n    this.descriptor = descriptor;\n\n    this.identity = descriptor.identity;\n    this.friendlyName = descriptor.friendly_name;\n    this.attributes = parseAttributes(descriptor.attributes, 'Failed to parse user attributes', log);\n    this.online = descriptor.is_online;\n    this.notifiable = descriptor.is_notifiable;\n  }\n\n  /**\n   * Gets User object from descriptor and subscribes to it.\n   * @returns {Promise<User>}\n   */\n  subscribe(): Promise<User> {\n    return this.services.users.getUser(this.identity, this.descriptor.sync_unique_name);\n  }\n\n  _getDescriptor() {\n    return this.descriptor;\n  }\n}\n\nexport { UserDescriptor };\n","import { UriBuilder } from '../util/index';\nimport { RestPaginator } from '../restpaginator';\nimport { UserDescriptor } from '../userdescriptor';\nimport { Users } from './users';\nimport { Network } from '../services/network';\nimport { Configuration } from '../configuration';\n\nexport interface UserDescriptorsServices {\n  users: Users;\n  network: Network;\n}\n\nclass UserDescriptors {\n  constructor(\n    private readonly configuration: Configuration,\n    private readonly services: UserDescriptorsServices,\n  ) {\n  }\n\n  public async getUserDescriptor(identity: string): Promise<UserDescriptor> {\n    const url = new UriBuilder(this.configuration.links.users).path(identity).build();\n    let response = await this.services.network.get(url);\n    return new UserDescriptor(this.services, response.body);\n\n  }\n\n  public async getChannelUserDescriptors(channelSid: string, args: any = {}): Promise<RestPaginator<UserDescriptor>> {\n    const url = new UriBuilder(this.configuration.links.users)\n      .arg('ConversationSid', channelSid).arg('PageToken', args.pageToken)\n      .build();\n    let response = await this.services.network.get(url);\n    return new RestPaginator<UserDescriptor>(response.body.users.map(x => new UserDescriptor(this.services, x))\n      , pageToken => this.getChannelUserDescriptors(channelSid, { pageToken })\n      , response.body.meta.prev_token\n      , response.body.meta.next_token);\n  }\n}\n\nexport { UserDescriptors };\n","import { EventEmitter } from 'events';\nimport { User } from '../user';\nimport { UserDescriptor } from '../userdescriptor';\nimport { UserDescriptors } from './userdescriptors';\nimport { Paginator } from '../interfaces/paginator';\nimport { Network } from '../services/network';\nimport { SyncClient } from 'twilio-sync';\nimport { Configuration } from '../configuration';\nimport { CommandExecutor } from '../commandexecutor';\n\nexport interface UsersServices {\n  network: Network;\n  syncClient: SyncClient;\n  commandExecutor: CommandExecutor;\n}\n\n/**\n * @classdesc Container for known users\n * @fires Users#userUpdated\n */\nclass Users extends EventEmitter {\n\n  private userDescriptors: UserDescriptors;\n  private subscribedUsers: Map<string, User>;\n  private fifoStack: any;\n  public readonly myself: User;\n\n  constructor(\n    private readonly configuration: Configuration,\n    private readonly services: UsersServices\n  ) {\n    super();\n\n    const userLinks = {\n      self: `${configuration.links.users}/${configuration.userIdentity}`\n    };\n\n    this.fifoStack = [];\n    this.myself = new User(this.configuration.userIdentity, this.configuration.userInfo, userLinks, this.configuration, this.services);\n    this.myself.on('updated', (args: User.UpdatedEventArgs) => this.emit('userUpdated', args));\n    this.myself.on('userSubscribed', () => this.emit('userSubscribed', this.myself));\n    this.myself.on('userUnsubscribed', () => {\n      this.emit('userUnsubscribed', this.myself);\n      this.myself._ensureFetched();\n    });\n    this.subscribedUsers = new Map<string, User>();\n    this.userDescriptors = new UserDescriptors(this.configuration, {...this.services, users: this });\n  }\n\n  private handleUnsubscribeUser(user: User): void {\n    if (this.subscribedUsers.has(user.identity)) {\n      this.subscribedUsers.delete(user.identity);\n    }\n    let foundItemIndex = -1;\n    let foundItem = this.fifoStack.find((item, index) => {\n      if (item == user.identity) {\n        foundItemIndex = index;\n        return true;\n      }\n      return false;\n    });\n    if (foundItem) {\n      this.fifoStack.splice(foundItemIndex, 1);\n    }\n    this.emit('userUnsubscribed', user);\n  }\n\n  private handleSubscribeUser(user: User): void {\n    if (this.subscribedUsers.has(user.identity)) {\n      return;\n    }\n    if (this.fifoStack.length >= this.configuration.userInfosToSubscribe) {\n      this.subscribedUsers.get(this.fifoStack.shift()).unsubscribe();\n    }\n    this.fifoStack.push(user.identity);\n    this.subscribedUsers.set(user.identity, user);\n    this.emit('userSubscribed', user);\n  }\n\n  /**\n   * Gets user, if it's in subscribed list - then return the user object from it,\n   * if not - then subscribes and adds user to the FIFO stack\n   * @returns {Promise<User>} Fully initialized user\n   */\n  async getUser(identity: string, entityName: string = null): Promise<User> {\n    await this.myself._ensureFetched();\n\n    if (identity == this.myself.identity) {\n      return this.myself;\n    }\n\n    let user = this.subscribedUsers.get(identity);\n    if (!user) {\n      if (!entityName) {\n        let userDescriptor = await this.getUserDescriptor(identity);\n        entityName = userDescriptor._getDescriptor().sync_objects.user_info_map;\n      }\n\n      const userLinks = {\n        self: `${this.configuration.links.users}/${identity}`\n      };\n\n      user = new User(identity, entityName, userLinks, this.configuration, this.services);\n      user.on('updated', (args: User.UpdatedEventArgs) => this.emit('userUpdated', args));\n      user.on('userSubscribed', () => this.handleSubscribeUser(user));\n      user.on('userUnsubscribed', () => this.handleUnsubscribeUser(user));\n      await user._ensureFetched();\n    }\n\n    return user;\n  }\n\n  /**\n   * @returns {Promise<UserDescriptor>} User descriptor\n   */\n  async getUserDescriptor(identity: string): Promise<UserDescriptor> {\n    return this.userDescriptors.getUserDescriptor(identity);\n  }\n\n  /**\n   * @returns {Promise<Paginator<UserDescriptor>>} Users descriptors page for given channel sid\n   */\n  async getChannelUserDescriptors(channelSid: string): Promise<Paginator<UserDescriptor>> {\n    return this.userDescriptors.getChannelUserDescriptors(channelSid);\n  }\n\n  /**\n   * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}\n   */\n  async getSubscribedUsers(): Promise<Array<User>> {\n    await this.myself._ensureFetched();\n\n    const users = [this.myself];\n    this.subscribedUsers.forEach((user) => users.push(user));\n\n    return users;\n  }\n}\n\nexport { Users };\n","import { Logger } from '../logger';\n\nimport { Notifications } from 'twilio-notifications';\n\nimport { NotificationTypes } from '../interfaces/notificationtypes';\nimport { Transport } from '../interfaces/transport';\nimport { Configuration } from '../configuration';\n\nconst log = Logger.scope('TypingIndicator');\n\nexport interface TypingIndicatorServices {\n  transport: Transport;\n  notificationClient: Notifications;\n}\n\n/**\n * An important note in regards to typing timeout timers. There are two places that the SDK can get the \"typing_timeout\" attribute from. The first\n * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the\n * \"typing_timeout\" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a\n * notification of type \"twilio.ipmsg.typing_indicator\". In this case, the \"typing_timeout\" value will be +1 of that in the console. This\n * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,\n * the timeout returned from the notification should be used as the timeout for the \"typingEnded\" event, +1 is to account for latency.\n *\n * @private\n */\n\n/**\n * @class TypingIndicator\n *\n * @constructor\n * @private\n */\nclass TypingIndicator {\n  private sentUpdates: Map<string, number>;\n  private serviceTypingTimeout;\n\n  constructor(\n    private readonly getChannel,\n    private readonly configuration: Configuration,\n    private readonly services: TypingIndicatorServices\n  ) {\n    this.serviceTypingTimeout = null;\n    this.sentUpdates = new Map();\n  }\n\n  public get typingTimeout(): number {\n    return this.configuration.typingIndicatorTimeoutOverride\n      || this.serviceTypingTimeout\n      || this.configuration.typingIndicatorTimeoutDefault;\n  }\n\n  /**\n   * Initialize TypingIndicator controller\n   * Registers for needed message types and sets listeners\n   * @private\n   */\n  initialize() {\n    this.services.notificationClient.subscribe(NotificationTypes.TYPING_INDICATOR, 'twilsock');\n    this.services.notificationClient.on('message', (type, message) => {\n      if (type === NotificationTypes.TYPING_INDICATOR) {\n        this.handleRemoteTyping(message);\n      }\n    });\n  }\n\n  /**\n   * Remote members typing events handler\n   * @private\n   */\n  handleRemoteTyping(message) {\n    log.trace('Got new typing indicator ', message);\n\n    this.getChannel(message.channel_sid)\n      .then(channel => {\n        if (!channel) {\n          return;\n        }\n\n        channel.members.forEach(member => {\n          if (member.identity !== message.identity) {\n            return;\n          }\n\n          const timeout = this.configuration.typingIndicatorTimeoutOverride + 1000 || message.typing_timeout * 1000;\n          member._startTyping(timeout);\n        });\n      })\n      .catch(err => {\n        log.error(err);\n        throw err;\n      });\n  }\n\n  /**\n   * Send typing event for the given channel sid\n   * @param {String} channelSid\n   */\n  send(channelSid: string) {\n    const lastUpdate = this.sentUpdates.get(channelSid);\n    if (lastUpdate && lastUpdate > (Date.now() - this.typingTimeout)) {\n      return Promise.resolve();\n    }\n\n    this.sentUpdates.set(channelSid, Date.now());\n    return this._send(channelSid);\n  }\n\n  private _send(channelSid: string) {\n    log.trace('Sending typing indicator');\n\n    const url = this.configuration.links.typing;\n    const headers = {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    };\n    const body = 'ChannelSid=' + channelSid;\n\n    return this.services.transport.post<{ typing_timeout: number }>(url, headers, body, this.configuration.productId)\n      .then(response => {\n        if (response.body.hasOwnProperty('typing_timeout')) {\n          this.serviceTypingTimeout = response.body.typing_timeout * 1000;\n        }\n      }).catch(err => {\n        log.error('Failed to send typing indicator:', err);\n        throw err;\n      });\n  }\n}\n\nexport { TypingIndicator };\n","import { UriBuilder } from '../util/index';\nimport { RestPaginator } from '../restpaginator';\nimport { ChannelDescriptor } from '../channeldescriptor';\nimport { Network } from '../services/network';\nimport { Client } from '../client';\n\nexport interface UserChannelServices {\n  network: Network;\n}\n\n/**\n * Users channels collection\n * It's a cassandra-backed pull-based collection\n */\nclass UserChannels {\n  private client: Client;\n  private services: UserChannelServices;\n  private url: string;\n\n  constructor(client: Client, services: UserChannelServices, url: string) {\n    this.client = client;\n    this.services = services;\n    this.url = url;\n  }\n\n  public async getChannels(args: any = {}): Promise<RestPaginator<ChannelDescriptor>> {\n    const url = new UriBuilder(this.url).arg('PageToken', args.pageToken).build();\n    let response = await this.services.network.get(url);\n    return new RestPaginator<ChannelDescriptor>(response.body.conversations.map(x => new ChannelDescriptor(this.client, x))\n      , pageToken => this.getChannels({ pageToken })\n      , response.body.meta.previous_token\n      , response.body.meta.next_token);\n  }\n}\n\nexport { UserChannels };\n","'use strict';\n\nnamespace PushNotification {\n  export type Type = 'twilio.channel.new_message' | 'twilio.channel.added_to_channel'\n    | 'twilio.channel.invited_to_channel' | 'twilio.channel.removed_from_channel';\n\n  export interface Descriptor {\n    title: string;\n    body: string;\n    sound: string;\n    badge: number;\n    action: string;\n    type: PushNotification.Type;\n    data: Object;\n  }\n}\n\n/**\n * @classdesc Push notification representation within Chat Client\n * @property {String} [action] - Notification action (`click_action` in FCM/GCM terms and `category` in APN terms)\n * @property {Number} [badge] - Number for the badge\n * @property {String} body - Notification text\n * @property {PushNotification#ChatData} data - Additional Chat data\n * @property {String} [sound] - Notification sound\n * @property {String} [title] - Notification title\n * @property {PushNotification#NotificationType} type - Notification type\n */\nclass PushNotification {\n  public readonly title: string;\n  public readonly body: string;\n  public readonly sound: string;\n  public readonly badge: number;\n  public readonly action: string;\n  public readonly type: PushNotification.Type;\n  public readonly data: Object;\n\n  /**\n   * Chat push notification type\n   * @typedef {('twilio.channel.new_message' | 'twilio.channel.added_to_channel'\n   | 'twilio.channel.invited_to_channel'  | 'twilio.channel.removed_from_channel')} PushNotification#NotificationType\n   */\n\n  /**\n   * Additional Chat data for given Push Notification\n   * @typedef {Object} PushNotification#ChatData\n   * @property {String} [channelSid] - SID of Channel\n   * @property {Number} [messageIndex] - Index of Message in Channel\n   * @property {String} [messageSid] - SID of Message\n   */\n\n  /**\n   * @param {PushNotification.Descriptor} data - initial data for PushNotification\n   */\n  constructor(data: PushNotification.Descriptor) {\n    this.title = data.title || null;\n    this.body = data.body || null;\n    this.sound = data.sound || null;\n    this.badge = data.badge || null;\n    this.action = data.action || null;\n    this.type = data.type || null;\n    this.data = data.data || {};\n  }\n\n}\n\nexport { PushNotification };\n","import { Result, Transport } from './interfaces/transport';\nimport { MutationConflictResponse } from './interfaces/commands/mutationconflict';\nimport { v4 as uuidv4 } from 'uuid';\nimport { AsyncRetrier } from 'operation-retrier';\n\nexport interface CommandExecutorServices {\n  transport: Transport;\n}\n\nconst trimSlashes = (url: string): string =>\n  url.replace(/(^\\/+|\\/+$)/g, '');\n\nconst isMutationConflictResponse = (response: Result<unknown>): response is Result<MutationConflictResponse> =>\n  response.status.code === 202;\n\nclass CommandExecutor {\n  constructor(\n    private _serviceUrl: string,\n    private _services: CommandExecutorServices,\n    private _productId?: string\n  ) {}\n\n  private _preProcessUrl(url: string): string {\n    const trimmedUrl = trimSlashes(url);\n\n    if (/^https?:\\/\\//.test(url)) {\n      return trimmedUrl;\n    }\n\n    return `${trimSlashes(this._serviceUrl)}/${trimmedUrl}`;\n  }\n\n  private async _makeRequest<REQ = void, RESP = void>(\n    method: 'get' | 'post' | 'delete',\n    url: string,\n    requestBody?: REQ,\n    headers?: Record<string, string>\n  ): Promise<Result<RESP>> {\n    const preProcessedUrl = this._preProcessUrl(url);\n    const finalHeaders = {\n      'Content-Type': 'application/json; charset=utf-8',\n      ...(headers || {})\n    };\n    let response: Result<RESP>;\n\n    switch (method) {\n      case 'get':\n        let getUrl = preProcessedUrl;\n\n        if (requestBody) {\n          getUrl +=\n            '?' +\n            Object.entries(requestBody)\n              .map((entry) => entry.map(encodeURIComponent).join('='))\n              .join('&');\n        }\n\n        response = await this._services.transport.get(getUrl, finalHeaders, this._productId);\n        break;\n      case 'post':\n        response = await this._services.transport.post(preProcessedUrl, finalHeaders, JSON.stringify(requestBody), this._productId);\n        break;\n      case 'delete':\n        response = await this._services.transport.delete(preProcessedUrl, finalHeaders, this._productId);\n        break;\n    }\n\n    if (response.status.code < 200 || response.status.code >= 300) {\n      throw new Error(`Request responded with a non-success code ${response.status.code}`);\n    }\n\n    return response;\n  }\n\n  public async fetchResource<REQ = void, RESP = void>(\n    url: string,\n    requestBody?: REQ\n  ): Promise<RESP> {\n    const maxAttemptsCount = 6;\n    let result: Result<RESP>;\n\n    try {\n      result = await new AsyncRetrier({ min: 50, max: 1600, maxAttemptsCount })\n        .run(() => this._makeRequest<REQ, RESP>('get', url, requestBody));\n    } catch {\n      throw new Error(`Fetch resource from \"${url}\" failed.`);\n    }\n\n    return result.body;\n  }\n\n  public async mutateResource<REQ = void, RESP = void>(\n    method: 'post' | 'delete',\n    url: string,\n    requestBody?: REQ\n  ): Promise<RESP> {\n    const result = await this._makeRequest<REQ, RESP>(method, url, requestBody, {\n      'X-Twilio-Mutation-Id': uuidv4()\n    });\n\n    if (isMutationConflictResponse(result)) {\n      return await this.fetchResource<undefined, RESP>(result.body.resource_url);\n    }\n\n    return result.body;\n  }\n}\n\nexport { CommandExecutor };","import { EventEmitter } from 'events';\nimport { Logger } from './logger';\nimport { Configuration } from './configuration';\n\nimport { User } from './user';\nimport { PublicChannels } from './data/publicchannels';\nimport { Network } from './services/network';\n\nimport { Transport } from './interfaces/transport';\nimport { NotificationTypes } from './interfaces/notificationtypes';\n\nimport { Twilsock as TwilsockClient } from 'twilsock';\nimport { Notifications as NotificationClient, ChannelType, ConnectionState as NotificationConnectionState } from 'twilio-notifications';\nimport { SyncClient } from 'twilio-sync';\nimport { McsClient } from 'twilio-mcs-client';\n\nimport { Channels as ChannelsEntity, Channel } from './data/channels';\n\nimport { Users } from './data/users';\nimport { TypingIndicator } from './services/typingindicator';\nimport { UserDescriptor } from './userdescriptor';\nimport { UserChannels } from './data/userchannels';\nimport { ChannelDescriptor } from './channeldescriptor';\nimport { Paginator } from './interfaces/paginator';\nimport { PushNotification } from './pushnotification';\nimport { parseToNumber, deepClone } from './util';\nimport { Member } from './member';\nimport { Message } from './message';\nimport { validateTypesAsync, validateTypes, literal, nonEmptyString, pureObject, objectSchema } from 'twilio-sdk-type-validator';\nimport { CommandExecutor } from './commandexecutor';\nimport { ConfigurationResponse } from './interfaces/commands/configuration';\nimport { version } from '../package.json';\n\nconst log = Logger.scope('Client');\nconst SDK_VERSION = version;\n\nclass ClientServices {\n  commandExecutor: CommandExecutor;\n  twilsockClient: TwilsockClient;\n  users: Users;\n  notificationClient: NotificationClient;\n  publicChannels: PublicChannels;\n  userChannels: UserChannels;\n  network: Network;\n  typingIndicator: TypingIndicator;\n  syncClient: SyncClient;\n  mcsClient: McsClient;\n  transport: Transport;\n}\n\nnamespace Client {\n  export type ConnectionState = NotificationConnectionState;\n\n  export type NotificationsChannelType = ChannelType;\n\n  export type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent' | null;\n\n  export interface Options {\n    region?: string;\n    logLevel?: Client.LogLevel;\n    productId?: string;\n    twilsockClient?: TwilsockClient;\n    transport?: Transport;\n    notificationsClient?: NotificationClient;\n    syncClient?: SyncClient;\n    typingIndicatorTimeoutOverride?: number;\n    consumptionReportIntervalOverride?: string;\n    httpCacheIntervalOverride?: string;\n    userInfosToSubscribeOverride?: number;\n    retryWhenThrottledOverride?: boolean;\n    backoffConfigOverride?: any;\n    Chat?: any;\n    IPMessaging?: any;\n    Sync?: any;\n    Notification?: any;\n    Twilsock?: any;\n    clientMetadata?: any;\n    disableDeepClone?: boolean;\n  }\n\n  export interface CreateChannelOptions {\n    attributes?: any;\n    friendlyName?: string;\n    isPrivate?: boolean;\n    uniqueName?: string;\n  }\n\n  export type ChannelSortingCriteria = 'lastMessage' | 'friendlyName' | 'uniqueName';\n\n  export type ChannelSortingOrder = 'ascending' | 'descending';\n\n  export interface ChannelSortingOptions {\n    criteria?: ChannelSortingCriteria;\n    order?: ChannelSortingOrder;\n  }\n}\n\n/**\n * A Client is a starting point to access Twilio Programmable Chat functionality.\n *\n * @property {Client#ConnectionState} connectionState - Client connection state\n * @property {Boolean} reachabilityEnabled - Client reachability state\n * @property {User} user - Information for logged in user\n * @property {String} version - Current version of Chat client\n *\n * @fires Client#connectionError\n * @fires Client#connectionStateChanged\n * @fires Client#channelAdded\n * @fires Client#channelInvited\n * @fires Client#channelJoined\n * @fires Client#channelLeft\n * @fires Client#channelRemoved\n * @fires Client#channelUpdated\n * @fires Client#memberJoined\n * @fires Client#memberLeft\n * @fires Client#memberUpdated\n * @fires Client#messageAdded\n * @fires Client#messageRemoved\n * @fires Client#messageUpdated\n * @fires Client#pushNotification\n * @fires Client#tokenAboutToExpire\n * @fires Client#tokenExpired\n * @fires Client#typingEnded\n * @fires Client#typingStarted\n * @fires Client#userSubscribed\n * @fires Client#userUnsubscribed\n * @fires Client#userUpdated\n */\nclass Client extends EventEmitter {\n  public connectionState: Client.ConnectionState = 'connecting';\n  private channelsPromise: Promise<any> = null;\n  private configurationPromise: Promise<ConfigurationResponse> | null = null;\n  private fpaToken: string;\n  private configuration: Configuration;\n  private channels: any;\n  private services: ClientServices;\n  public static readonly version: string = SDK_VERSION;\n  public readonly version: string = SDK_VERSION;\n  private static readonly supportedPushChannels: Client.NotificationsChannelType[] = ['fcm', 'apn', 'gcm'];\n  private static readonly supportedPushDataFields = {\n    'channel_sid': 'channelSid',\n    'message_sid': 'messageSid',\n    'message_index': 'messageIndex'\n  };\n\n  private constructor(\n    token: string,\n    private readonly options: Client.Options = {}\n  ) {\n    super();\n\n    if (!this.options.disableDeepClone) {\n      let options = {\n        ...this.options,\n        transport: undefined,\n        twilsockClient: undefined\n      };\n\n      options = deepClone(options);\n      options.transport = this.options.transport;\n      options.twilsockClient = this.options.twilsockClient;\n\n      this.options = options;\n    }\n\n    this.options.logLevel = this.options.logLevel || 'silent';\n    log.setLevel(this.options.logLevel);\n\n    const productId = this.options.productId = 'ip_messaging';\n\n    // Filling ClientMetadata\n    this.options.clientMetadata = this.options.clientMetadata || {};\n\n    if (!this.options.clientMetadata.hasOwnProperty('type')) {\n      this.options.clientMetadata.type = 'chat';\n    }\n\n    if (!this.options.clientMetadata.hasOwnProperty('sdk')) {\n      this.options.clientMetadata.sdk = 'JS';\n      this.options.clientMetadata.sdkv = SDK_VERSION;\n    }\n\n    // Enable session local storage for Sync\n    this.options.Sync = this.options.Sync || {};\n\n    if (!this.options.Sync?.enableSessionStorage) {\n      this.options.Sync.enableSessionStorage = true;\n    }\n\n    if (this.options.region) {\n      this.options.Sync.region = this.options.region;\n    }\n\n    if (!token) {\n      throw new Error('A valid Twilio token should be provided');\n    }\n\n    this.services = new ClientServices();\n\n    this.options.twilsockClient = this.options.twilsockClient || new TwilsockClient(token, productId, this.options);\n    this.options.transport = this.options.transport || this.options.twilsockClient;\n    this.options.notificationsClient = this.options.notificationsClient || new NotificationClient(token, this.options);\n    this.options.syncClient = this.options.syncClient || new SyncClient(token, this.options);\n\n    this.services.syncClient = this.options.syncClient;\n    this.services.transport = this.options.transport;\n    this.services.twilsockClient = this.options.twilsockClient;\n    this.services.notificationClient = this.options.notificationsClient;\n\n    const configurationOptions = options.Chat || options.IPMessaging || options || {};\n    const region = configurationOptions.region || options.region;\n    const baseUrl = configurationOptions.apiUri\n      || configurationOptions.typingUri\n      || `https://aim.${region || 'us1'}.twilio.com`;\n\n    this.services.commandExecutor = new CommandExecutor(baseUrl, { transport: this.options.transport }, productId);\n    this.configurationPromise = this.services.commandExecutor.fetchResource<void, ConfigurationResponse>(\n      'Client/v1/Configuration'\n    );\n\n    this.configurationPromise\n      .then((configurationResponse) => {\n        this.configuration = new Configuration(this.options, configurationResponse, log);\n\n        this.services.typingIndicator = new TypingIndicator(this.getChannelBySid.bind(this), this.configuration, this.services);\n        this.services.network = new Network(this.configuration, this.services);\n        this.services.users = new Users(this.configuration, this.services);\n\n        this.services.users.on('userSubscribed', this.emit.bind(this, 'userSubscribed'));\n        this.services.users.on('userUpdated', (args: User.UpdatedEventArgs) => this.emit('userUpdated', args));\n        this.services.users.on('userUnsubscribed', this.emit.bind(this, 'userUnsubscribed'));\n\n        this.services.twilsockClient.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));\n        this.services.twilsockClient.on('tokenExpired', () => this.emit('tokenExpired'));\n        this.services.twilsockClient.on('connectionError', (error) => this.emit('connectionError', error));\n\n        this.channels = new ChannelsEntity(this.configuration, this.services);\n\n        this.channels.on('channelAdded', this.emit.bind(this, 'channelAdded'));\n        this.channels.on('channelInvited', this.emit.bind(this, 'channelInvited'));\n        this.channels.on('channelRemoved', this.emit.bind(this, 'channelRemoved'));\n        this.channels.on('channelJoined', this.emit.bind(this, 'channelJoined'));\n        this.channels.on('channelLeft', this.emit.bind(this, 'channelLeft'));\n        this.channels.on('channelUpdated',\n          (args: Channel.UpdatedEventArgs) => this.emit('channelUpdated', args));\n\n        this.channels.on('memberJoined', this.emit.bind(this, 'memberJoined'));\n        this.channels.on('memberLeft', this.emit.bind(this, 'memberLeft'));\n        this.channels.on('memberUpdated',\n          (args: Member.UpdatedEventArgs) => this.emit('memberUpdated', args));\n\n        this.channels.on('messageAdded', this.emit.bind(this, 'messageAdded'));\n        this.channels.on('messageUpdated',\n          (args: Message.UpdatedEventArgs) => this.emit('messageUpdated', args));\n        this.channels.on('messageRemoved', this.emit.bind(this, 'messageRemoved'));\n\n        this.channels.on('typingStarted', this.emit.bind(this, 'typingStarted'));\n        this.channels.on('typingEnded', this.emit.bind(this, 'typingEnded'));\n\n        return this.services.users.myself._ensureFetched();\n      });\n\n    this.channelsPromise = this.configurationPromise\n      .then(() => this.channels.fetchChannels())\n      .then(() => this.channels);\n\n    this.services.notificationClient.on('connectionStateChanged', (state: Client.ConnectionState) => {\n      let changedConnectionState = null;\n      switch (state) {\n        case 'connected':\n          changedConnectionState = 'connected';\n          break;\n        case 'denied':\n          changedConnectionState = 'denied';\n          break;\n        case 'disconnecting':\n          changedConnectionState = 'disconnecting';\n          break;\n        case 'disconnected':\n          changedConnectionState = 'disconnected';\n          break;\n        default:\n          changedConnectionState = 'connecting';\n      }\n      if (changedConnectionState !== this.connectionState) {\n        this.connectionState = changedConnectionState;\n        this.emit('connectionStateChanged', this.connectionState);\n      }\n    });\n\n    this.fpaToken = token;\n  }\n\n  /**\n   * These options can be passed to {@link Client#getLocalChannels}.\n   * @typedef {Object} Client#ChannelSortingOptions\n   * @property {('lastMessage'|'friendlyName'|'uniqueName')} [criteria] - Sorting criteria for Channels array\n   * @property {('ascending'|'descending')} [order] - Sorting order. If not present, then default is <code>ascending</code>\n   */\n\n  /**\n   * These options can be passed to Client constructor.\n   * @typedef {Object} Client#ClientOptions\n   * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n   *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n   */\n\n  /**\n   * These options can be passed to {@link Client#createChannel}.\n   * @typedef {Object} Client#CreateChannelOptions\n   * @property {any} [attributes] - Any custom attributes to attach to the Channel\n   * @property {String} [friendlyName] - The non-unique display name of the Channel\n   * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients\n   * @property {String} [uniqueName] - The unique identity name of the Channel\n   */\n\n  /**\n   * Connection state of Client.\n   * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState\n   */\n\n  /**\n   * Notifications channel type.\n   * @typedef {('gcm'|'fcm'|'apn')} Client#NotificationsChannelType\n   */\n\n  /**\n   * Factory method to create Chat client instance.\n   *\n   * @param {String} token - Access token\n   * @param {Client#ClientOptions} [options] - Options to customize the Client\n   * @returns {Promise<Client>}\n   */\n  @validateTypesAsync('string', ['undefined', pureObject])\n  static async create(token: string, options?: Client.Options): Promise<Client> {\n    let client = new Client(token, options);\n    await client.initialize();\n    return client;\n  }\n\n  public get user(): User { return this.services.users.myself; }\n\n  public get reachabilityEnabled(): boolean { return this.configuration.reachabilityEnabled; }\n\n  public get token(): string { return this.fpaToken; }\n\n  private subscribeToPushNotifications(channelType: Client.NotificationsChannelType) {\n    let subscriptions: Promise<any>[] = [];\n    [NotificationTypes.NEW_MESSAGE,\n      NotificationTypes.ADDED_TO_CHANNEL,\n      NotificationTypes.INVITED_TO_CHANNEL,\n      NotificationTypes.REMOVED_FROM_CHANNEL,\n      NotificationTypes.TYPING_INDICATOR,\n      NotificationTypes.CONSUMPTION_UPDATE]\n      .forEach(messageType => {\n        subscriptions.push(this.services.notificationClient.subscribe(messageType, channelType));\n      });\n    return Promise.all(subscriptions);\n  }\n\n  private unsubscribeFromPushNotifications(channelType: Client.NotificationsChannelType) {\n    let subscriptions: Promise<any>[] = [];\n    [NotificationTypes.NEW_MESSAGE,\n      NotificationTypes.ADDED_TO_CHANNEL,\n      NotificationTypes.INVITED_TO_CHANNEL,\n      NotificationTypes.REMOVED_FROM_CHANNEL,\n      NotificationTypes.TYPING_INDICATOR,\n      NotificationTypes.CONSUMPTION_UPDATE]\n      .forEach(messageType => {\n        subscriptions.push(this.services.notificationClient.unsubscribe(messageType, channelType));\n      });\n    return Promise.all(subscriptions);\n  }\n\n  private async initialize() {\n    await this.configurationPromise;\n\n    Client.supportedPushChannels.forEach(channelType => this.subscribeToPushNotifications(channelType));\n\n    this.services.publicChannels = new PublicChannels(this, this.services, this.configuration.links.conversations);\n    this.services.userChannels = new UserChannels(this, this.services, this.configuration.links.myConversations);\n\n    const options = Object.assign(this.options);\n    options.transport = null;\n\n    this.services.mcsClient = new McsClient(this.fpaToken, this.configuration.links.mediaService, options);\n\n    await this.services.typingIndicator.initialize();\n  }\n\n  /**\n   * Gracefully shutting down library instance.\n   * @public\n   * @returns {Promise<void>}\n   */\n  async shutdown(): Promise<void> {\n    await this.services.twilsockClient.disconnect();\n  }\n\n  /**\n   * Update the token used by the Client and re-register with Programmable Chat services.\n   * @param {String} token - Access token\n   * @public\n   * @returns {Promise<Client>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async updateToken(token: string): Promise<Client> {\n    log.info('updateToken');\n\n    if (this.fpaToken === token) {\n      return this;\n    }\n\n    await this.services.twilsockClient.updateToken(token)\n      .then(() => this.fpaToken = token)\n      .then(() => this.services.mcsClient.updateToken(token))\n      .then(() => this.configurationPromise);\n\n    return this;\n  }\n\n  /**\n   * Get a known Channel by its SID.\n   * @param {String} channelSid - Channel sid\n   * @returns {Promise<Channel>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getChannelBySid(channelSid: string): Promise<Channel> {\n    return this.channels.myChannelsRead.promise.then(() =>\n      this.channels.getChannel(channelSid)\n        .then(channel => channel || this.services.publicChannels.getChannelBySid(channelSid).then(x => this.channels.pushChannel(x))));\n  }\n\n  /**\n   * Get a known Channel by its unique identifier name.\n   * @param {String} uniqueName - The unique identifier name of the Channel to get\n   * @returns {Promise<Channel>}\n   */\n  @validateTypesAsync(nonEmptyString)\n  async getChannelByUniqueName(uniqueName: string): Promise<Channel> {\n    return this.channels.myChannelsRead.promise.then(() =>\n      this.services.publicChannels.getChannelByUniqueName(uniqueName).then(x => this.channels.pushChannel(x)));\n  }\n\n  /**\n   * Get the current list of all subscribed Channels.\n   * @returns {Promise<Paginator<Channel>>}\n   */\n  getSubscribedChannels(args?): Promise<Paginator<Channel>> {\n    return this.channelsPromise.then(channels => channels.getChannels(args));\n  }\n\n  /**\n   * Get array of Channels locally known to Client in provided sorting order.\n   * Locally known channels are the ones created and/or joined during client runtime and currently logged in User subscribed Channels.\n   * To ensure full list of subscribed Channels fetched - call the {@link Client#getSubscribedChannels} method\n   * and fetch all pages with help of {@link Paginator#nextPage} method.\n   * @param {Client#ChannelSortingOptions} [sortingOptions] - Options for the Channel sorting\n   * @returns {Promise<Array<Channel>>}\n   */\n  @validateTypesAsync([\n    'undefined',\n    objectSchema('sorting options', {\n      criteria: [literal('lastMessage', 'friendlyName', 'uniqueName'), 'undefined'],\n      order: [literal('ascending', 'descending'), 'undefined']\n    })\n  ])\n  getLocalChannels(sortingOptions?: Client.ChannelSortingOptions): Promise<Array<Channel>> {\n    return this.channelsPromise.then(channels => {\n      let result: Channel[] = [];\n      channels.channels.forEach(value => {\n        result.push(value);\n      });\n\n      const sortingOrder = sortingOptions?.order || 'ascending';\n\n      if (sortingOptions && sortingOptions.criteria) {\n        if (sortingOptions.criteria === 'lastMessage') {\n          result.sort((a: Channel, b: Channel) =>\n            Client.compareChannelsByLastMessage(a, b, sortingOrder));\n        } else if (sortingOptions.criteria === 'uniqueName') {\n          result.sort((a: Channel, b: Channel) =>\n            Client.compareChannelsByStringProperty(a.uniqueName, b.uniqueName, sortingOrder));\n        } else if (sortingOptions.criteria === 'friendlyName') {\n          result.sort((a: Channel, b: Channel) =>\n            Client.compareChannelsByStringProperty(a.friendlyName, b.friendlyName, sortingOrder));\n        }\n      }\n\n      return result;\n    });\n  }\n\n  private static compareChannelsByLastMessage(a: Channel, b: Channel, order: Client.ChannelSortingOrder) {\n    if (a.lastMessage && b.lastMessage) {\n      if (a.lastMessage.dateCreated && b.lastMessage.dateCreated) {\n        if (a.lastMessage.dateCreated.getTime() < b.lastMessage.dateCreated.getTime()) {\n          return (order === 'ascending') ? -1 : 1;\n        } else {\n          return (order === 'ascending') ? 1 : -1;\n        }\n      } else {\n        if (a.lastMessage.dateCreated) {\n          return -1;\n        } else if (b.lastMessage.dateCreated) {\n          return 1;\n        }\n      }\n    }\n\n    if (a.lastMessage) {\n      return -1;\n    } else if (b.lastMessage) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  private static compareChannelsByStringProperty(str1: string, str2: string, order: Client.ChannelSortingOrder) {\n    if (str1 && str2) {\n      return (order === 'ascending') ? str1.localeCompare(str2) : -1 * str1.localeCompare(str2);\n    } else if (str1) {\n      return -1;\n    } else if (str2) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Get the public channels directory content.\n   * @returns {Promise<Paginator<ChannelDescriptor>>}\n   */\n  getPublicChannelDescriptors(): Promise<Paginator<ChannelDescriptor>> {\n    return this.services.publicChannels.getChannels();\n  }\n\n  /**\n   * Get the User's (created by, joined or invited to) channels directory content.\n   * @returns {Promise<Paginator<ChannelDescriptor>>}\n   */\n  getUserChannelDescriptors(): Promise<Paginator<ChannelDescriptor>> {\n    return this.services.userChannels.getChannels();\n  }\n\n  /**\n   * Create a Channel on the server and subscribe to its events.\n   * Default options are public Channel type with empty uniqueName and friendlyName.\n   * @param {Client#CreateChannelOptions} [options] - Options for the Channel\n   * @returns {Promise<Channel>}\n   */\n  @validateTypesAsync([\n    'undefined',\n    objectSchema('channel options', {\n      friendlyName: ['string', 'undefined'],\n      isPrivate: ['boolean', 'undefined'],\n      uniqueName: ['string', 'undefined']\n    })\n  ])\n  createChannel(options?: Client.CreateChannelOptions): Promise<Channel> {\n    options = options || {};\n    return this.channelsPromise.then((channelsEntity) => channelsEntity.addChannel(options));\n  }\n\n  /**\n   * Registers for push notifications.\n   * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported\n   * @param {string} registrationId - Push notification id provided by platform\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(literal('gcm', 'fcm', 'apn'), 'string')\n  async setPushRegistrationId(channelType: Client.NotificationsChannelType, registrationId: string): Promise<void> {\n    await this.subscribeToPushNotifications(channelType)\n      .then(() => {\n        return this.services.notificationClient.setPushRegistrationId(registrationId, channelType);\n      });\n  }\n\n  /**\n   * Unregisters from push notifications.\n   * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(literal('gcm', 'fcm', 'apn'))\n  async unsetPushRegistrationId(channelType: Client.NotificationsChannelType): Promise<void> {\n    if (Client.supportedPushChannels.indexOf(channelType) === -1) {\n      throw new Error('Invalid or unsupported channelType: ' + channelType);\n    }\n    await this.unsubscribeFromPushNotifications(channelType);\n  }\n\n  private static parsePushNotificationChatData(data: Object): Object {\n    let result: Object = {};\n    for (let key in Client.supportedPushDataFields) {\n      if (typeof data[key] !== 'undefined' && data[key] !== null) {\n        if (key === 'message_index') {\n          if (parseToNumber(data[key]) !== null) {\n            result[Client.supportedPushDataFields[key]] = Number(data[key]);\n          }\n        } else {\n          result[Client.supportedPushDataFields[key]] = data[key];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object\n   * @param {Object} notificationPayload - Push notification payload\n   * @returns {PushNotification|Error}\n   */\n  @validateTypes(pureObject)\n  static parsePushNotification(notificationPayload): PushNotification {\n    log.debug('parsePushNotification, notificationPayload=', notificationPayload);\n\n    // APNS specifics\n    if (typeof notificationPayload.aps !== 'undefined') {\n      if (!notificationPayload.twi_message_type) {\n        throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n      }\n\n      let data = Client.parsePushNotificationChatData(notificationPayload);\n\n      let apsPayload = notificationPayload.aps;\n      let body: string = null;\n      let title: string = null;\n      if (typeof apsPayload.alert === 'string') {\n        body = apsPayload.alert || null;\n      } else {\n        body = apsPayload.alert.body || null;\n        title = apsPayload.alert.title || null;\n      }\n\n      return new PushNotification({\n        title: title,\n        body: body,\n        sound: apsPayload.sound || null,\n        badge: apsPayload.badge || null,\n        action: apsPayload.category || null,\n        type: notificationPayload.twi_message_type,\n        data: data\n      });\n    }\n\n    // FCM/GCM specifics\n    if (typeof notificationPayload.data !== 'undefined') {\n      let dataPayload = notificationPayload.data;\n      if (!dataPayload.twi_message_type) {\n        throw new Error('Provided push notification payload does not contain Programmable Chat push notification type');\n      }\n\n      let data = Client.parsePushNotificationChatData(notificationPayload.data);\n      return new PushNotification({\n        title: dataPayload.twi_title || null,\n        body: dataPayload.twi_body || null,\n        sound: dataPayload.twi_sound || null,\n        badge: null,\n        action: dataPayload.twi_action || null,\n        type: dataPayload.twi_message_type,\n        data: data\n      });\n    }\n\n    throw new Error('Provided push notification payload is not Programmable Chat notification');\n  }\n\n  public parsePushNotification = Client.parsePushNotification;\n\n  /**\n   * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.\n   * @param {Object} notificationPayload - Push notification payload\n   * @returns {Promise<void>}\n   */\n  @validateTypesAsync(pureObject)\n  async handlePushNotification(notificationPayload): Promise<void> {\n    log.debug('handlePushNotification, notificationPayload=', notificationPayload);\n    this.emit('pushNotification', Client.parsePushNotification(notificationPayload));\n  }\n\n  /**\n   * Gets user for given identity, if it's in subscribed list - then return the user object from it,\n   * if not - then subscribes and adds user to the subscribed list.\n   * @param {String} identity - Identity of User\n   * @returns {Promise<User>} Fully initialized user\n   */\n  @validateTypesAsync(nonEmptyString)\n  public getUser(identity: string): Promise<User> {\n    return this.services.users.getUser(identity);\n  }\n\n  /**\n   * Gets user descriptor for given identity.\n   * @param {String} identity - Identity of User\n   * @returns {Promise<UserDescriptor>} User descriptor\n   */\n  @validateTypesAsync(nonEmptyString)\n  public async getUserDescriptor(identity: string): Promise<UserDescriptor> {\n    return this.services.users.getUserDescriptor(identity);\n  }\n\n  /**\n   * @returns {Promise<Array<User>>} List of subscribed User objects\n   */\n  public async getSubscribedUsers(): Promise<Array<User>> {\n    return this.services.users.getSubscribedUsers();\n  }\n}\n\nexport { Client };\n\n/**\n * Fired when a Channel becomes visible to the Client.\n * Fired for created and not joined private channels and for all type of channels Client has joined or invited to.\n * @event Client#channelAdded\n * @type {Channel}\n */\n/**\n * Fired when the Client is invited to a Channel.\n * @event Client#channelInvited\n * @type {Channel}\n */\n/**\n * Fired when the Client joins a Channel.\n * @event Client#channelJoined\n * @type {Channel}\n */\n/**\n * Fired when the Client leaves a Channel.\n * @event Client#channelLeft\n * @type {Channel}\n */\n/**\n * Fired when a Channel is no longer visible to the Client.\n * @event Client#channelRemoved\n * @type {Channel}\n */\n/**\n * Fired when a Channel's attributes or metadata have been updated.\n * During Channel's {@link Client.create| creation and initialization} this event might be fired multiple times\n * for same joined or created Channel as new data is arriving from different sources.\n * @event Client#channelUpdated\n * @type {Object}\n * @property {Channel} channel - Updated Channel\n * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons\n */\n/**\n * Fired when Client's connection state has been changed.\n * @event Client#connectionStateChanged\n * @type {Client#ConnectionState}\n */\n/**\n * Fired when a Member has joined the Channel.\n * @event Client#memberJoined\n * @type {Member}\n */\n/**\n * Fired when a Member has left the Channel.\n * @event Client#memberLeft\n * @type {Member}\n */\n/**\n * Fired when a Member's fields has been updated.\n * @event Client#memberUpdated\n * @type {Object}\n * @property {Member} member - Updated Member\n * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons\n */\n/**\n * Fired when a new Message has been added to the Channel on the server.\n * @event Client#messageAdded\n * @type {Message}\n */\n/**\n * Fired when Message is removed from Channel's message list.\n * @event Client#messageRemoved\n * @type {Message}\n */\n/**\n * Fired when an existing Message's fields are updated with new values.\n * @event Client#messageUpdated\n * @type {Object}\n * @property {Message} message - Updated Message\n * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons\n */\n/**\n * Fired when token is about to expire and needs to be updated.\n * @event Client#tokenAboutToExpire\n * @type {void}\n */\n/**\n * Fired when token is expired.\n * @event Client#tokenExpired\n * @type {void}\n */\n/**\n * Fired when a Member has stopped typing.\n * @event Client#typingEnded\n * @type {Member}\n */\n/**\n * Fired when a Member has started typing.\n * @event Client#typingStarted\n * @type {Member}\n */\n/**\n * Fired when client received (and parsed) push notification via one of push channels (apn, gcm, fcm).\n * @event Client#pushNotification\n * @type {PushNotification}\n */\n/**\n * Fired when the Client is subscribed to a User.\n * @event Client#userSubscribed\n * @type {User}\n */\n/**\n * Fired when the Client is unsubscribed from a User.\n * @event Client#userUnsubscribed\n * @type {User}\n */\n/**\n * Fired when the User's properties or reachability status have been updated.\n * @event Client#userUpdated\n * @type {Object}\n * @property {User} user - Updated User\n * @property {User#UpdateReason[]} updateReasons - Array of User's updated event reasons\n */\n/**\n * Fired when connection is interrupted by unexpected reason\n * @event Client#connectionError\n * @type {Object}\n * @property {Boolean} terminal - twilsock will stop connection attempts\n * @property {String} message - root cause\n * @property {Number} [httpStatusCode] - http status code if available\n * @property {Number} [errorCode] - Twilio public error code if available\n */\n"]},"metadata":{},"sourceType":"script"}